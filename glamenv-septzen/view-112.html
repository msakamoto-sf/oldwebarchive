<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Perl/codepiece/array_hash1 - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">Perl/codepiece/array_hash1</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2007-03-12 22:12:10 &nbsp; / &nbsp; last updated at: 2008-12-24 22:19:43<br>
カテゴリ: <a href="category-21.html">Perl</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-130.html" title="Perl/codepiece/OOPメモ">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-343.html" title="Perl/codepiece/array_hash2(関数への参照渡し)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-109.html" title="Perl">Perl</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
配列とハッシュの基本的な作成・アクセス方法を確認する。
<br />
</p>

<ul><li><a href="#ida84f87">参考リンク</a></li>
<li><a href="#id7148f8">配列</a><ul><li><a href="#id9aa64c">コードピース01 : 配列の実体コンストラクタ&quot;(&quot;, &quot;)&quot;</a></li>
<li><a href="#id210d29">コードピース02 : 配列のリファレンスコンストラクタ&quot;[&quot;, &quot;]&quot;</a></li>
<li><a href="#id1526fd">コードピース03 : ループアクセス(for, foreach)</a></li>
<li><a href="#ided70e0">コードピース04 : 間違いやすい配列のスライスについて($ary[x]と@ary[x]の違い)</a></li>
<li><a href="#idb2efca">コードピース05 : ( 先頭 | 末尾 ) 要素の追加削除</a></li>
<li><a href="#ide6f933">コードピース06 : 配列へのundefの代入と、空リストの判別</a></li></ul></li>
<li><a href="#idbeab1c">ハッシュ</a><ul><li><a href="#id745908">コードピース01 : ハッシュの実体コンストラクタ&quot;(&quot;, &quot;)&quot; とループアクセス(while, each)</a></li>
<li><a href="#idf2d495">コードピース02 : ハッシュのリファレンスコンストラクタ&quot;{&quot;, &quot;</a>&quot;}</li>
<li><a href="#id3a1d9b">コードピース03 : ハッシュのコンストラクタの亜種（配列風味）</a></li>
<li><a href="#idcc956a">コードピース04 : ハッシュのスライスとundef</a></li></ul></li></ul>
<hr />

<h3 id="ida84f87">参考リンク</h3>
<ul><li> Perl&amp;CGI最強講座<ul><li> <a class="externallink" href="http://www.rfs.jp/sb/perl/index.html" target="_blank">http://www.rfs.jp/sb/perl/index.html</a></li>
<li> 正直なところ、本ドキュメントが無くとも、こちらさえあれば基本的な部分は全て押さえられる。</li>
<li> 配列周り → <a class="externallink" href="http://www.rfs.jp/sb/perl/02/04.html" target="_blank">http://www.rfs.jp/sb/perl/02/04.html</a></li>
<li> ハッシュ周り → <a class="externallink" href="http://www.rfs.jp/sb/perl/02/05.html" target="_blank">http://www.rfs.jp/sb/perl/02/05.html</a></li></ul></li>
<li> Effective Perlにおいて注目すべき項番を以下に示す。<ul><li> 2項「要素を使いたいとき、スライスを使わないようにする」</li>
<li> 3項「空リストがほしいときに、undefを代入しない」</li>
<li> 12項「foreach, map, grepを、うまく使い分けよう」</li>
<li> 31項「リファレンスで、リストのリストを作る」</li>
<li> 32項「名無し配列を、リストリテラルと混同しないこと」</li>
<li> 33項「名無しハッシュによってC言語スタイルの構造体を構築する」</li></ul></li>
<li> perldocにおいて注目すべきドキュメントを以下に示す。<ul><li> perldata : <a class="externallink" href="http://perldoc.perl.org/perldata.html" target="_blank">http://perldoc.perl.org/perldata.html</a><ul><li> Perlのデータ型に関する基本・基盤ドキュメント</li></ul></li>
<li> perlref : <a class="externallink" href="http://perldoc.perl.org/perlref.html" target="_blank">http://perldoc.perl.org/perlref.html</a><ul><li> Perlのリファレンスに関する基本・基盤ドキュメント</li></ul></li>
<li> perlfaq4 : <a class="externallink" href="http://perldoc.perl.org/perlfaq4.html" target="_blank">http://perldoc.perl.org/perlfaq4.html</a><ul><li> Perlのデータ構造に関するFAQ</li></ul></li>
<li> Data:Arrays : <a class="externallink" href="http://perldoc.perl.org/perlfaq4.html#Data%3a-Arrays" target="_blank">http://perldoc.perl.org/perlfaq4.html#Data%3a-Arrays</a><ul><li> 配列に関するFAQ</li></ul></li>
<li> Data:Hashes : <a class="externallink" href="http://perldoc.perl.org/perlfaq4.html#Data%3a-Hashes-" target="_blank">http://perldoc.perl.org/perlfaq4.html#Data%3a-Hashes-</a>(Associative-Arrays)<ul><li> ハッシュに関するFAQ</li></ul></li>
<li> perllol : <a class="externallink" href="http://perldoc.perl.org/perllol.html" target="_blank">http://perldoc.perl.org/perllol.html</a><ul><li> 配列の配列を作るには。</li></ul></li>
<li> perldsc : <a class="externallink" href="http://perldoc.perl.org/perldsc.html" target="_blank">http://perldoc.perl.org/perldsc.html</a><ul><li> 配列とハッシュが混ざった複雑なデータ構造を作るには。</li></ul></li>
<li> defined : <a class="externallink" href="http://perldoc.perl.org/functions/defined.html" target="_blank">http://perldoc.perl.org/functions/defined.html</a><ul><li> definedは、5.004以降はスカラー変数でしか使用できなくなっている点に注意。</li></ul></li></ul></li></ul>

<h3 id="id7148f8">配列</h3>

<h4 id="id9aa64c">コードピース01 : 配列の実体コンストラクタ&quot;(&quot;, &quot;)&quot;</h4>
<ul><li> コードピース</li></ul>
<pre>use strict;
use warnings;
use Data::Dumper;

my @ary1 = (1, 2, 3, (4, 5, 6), (7, (8, 9), ), );
print @ary1, &quot;\n&quot;;
print Dumper(@ary1), &quot;\n&quot;;
print $ary1[0], &quot;\n&quot;;
print $ary1[@ary1-1], &quot;\n&quot;;
</pre>

<ul><li> 出力</li></ul>
<pre>123456789 # ← print @ary1
$VAR1 = 1;
$VAR2 = 2;
$VAR3 = 3;
$VAR4 = 4;
$VAR5 = 5;
$VAR6 = 6;
$VAR7 = 7;
$VAR8 = 8;
$VAR9 = 9;
#(ここまでがDumper(@ary1)の出力)
1 # ← print $ary1[0]
9 # ← print $ary1[@ary1-1]
</pre>

<p class="paragraph">
配列作成時の&quot;(...)&quot;は、配列の実体<span class="hidden">(</span><a class="footnote" href="#footnote_112_1" id="footnote_112_1_r"  title="&quot;Effective Perl&quot;上では&quot;リストリテラル&quot;と表記されているが・・・上手い日本語が分かりません。">*1</a><span class="hidden">)</span>を作成するコンストラクタ。
<br />
従って、変数の&quot;ary1&quot;は、常にリストとして&quot;@&quot;でアクセスする必要がある。
<br />
</p>
<pre>print Dumper($ary1), &quot;\n&quot;;
</pre>
<p class="paragraph">
は、
<br />
</p>
<pre>Global symbol &quot;$ary1&quot; requires explicit package name at hoge.pl line 7.
Execution of hoge.pl aborted due to compilation errors.
</pre>
<p class="paragraph">
となる。すなわちスカラーとしての&quot;ary1&quot;をシンボルテーブルから探そうとしてしまう。
<br />
</p>

<p class="paragraph">
次の記法にも注意。
<br />
</p>
<pre>print $ary1[@ary1-1], &quot;\n&quot;;
</pre>
<p class="paragraph">
要するに配列の最大要素数-1により、配列の末尾にアクセスしている。ここで@ary1 を -1  することで、
<br />
</p>
<ol><li> 無理矢理スカラーコンテキストで評価</li>
<li> → @ary1はスカラーコンテキストでは配列の要素数を表す</li>
<li> → -1 することで0始まりの配列の末尾INDEXになる。</li></ol>

<p class="paragraph">
ということで、配列の末尾要素にアクセスできている。
<br />
</p>

<h4 id="id210d29">コードピース02 : 配列のリファレンスコンストラクタ&quot;[&quot;, &quot;]&quot;</h4>
<ul><li> コードピース</li></ul>
<pre>my $ary2 = [ 1, 2, 3, (4, 5, 6), [7, 8, 9] ];
print $ary2, &quot;\n&quot;;
print Dumper($ary2), &quot;\n&quot;;

print $ary2-&gt;[0], &quot;\n&quot;;
print $ary2-&gt;[6], &quot;\n&quot;;
print $ary2-&gt;[6][0], &quot;\n&quot;;

my $ary_buf = $ary2-&gt;[6];
print $ary_buf-&gt;[0], &quot;\n&quot;;
print $ary_buf-&gt;[@$ary_buf - 1], &quot;\n&quot;;
</pre>

<ul><li> 出力</li></ul>
<pre>ARRAY(0x18c35ac) # ← print $ary2
$VAR1 = [
          1,
          2,
          3,
          4,
          5,
          6,
          [
            7,
            8,
            9
          ]
        ];

1 # ← print $ary2-&gt;[0]
ARRAY(0x274e6c) # ← print $ary2-&gt;[6]
7 # ← print $ary2-&gt;[6][0]

7 # ← print $ary_buf-&gt;[0]
9 # ← print $ary_buf-&gt;[@$ary_buf - 1]
</pre>

<p class="paragraph">
&quot;[&quot;, &quot;]&quot;は&#039;&#039;名無し配列コンストラクタ&#039;&#039;(Effective Perl)であり、その返すものはリファレンスである。従って、リファレンス全般で要素アクセスに使われる&quot;-&gt;&quot;を用いて各インデックスの値にアクセスできる。
<br />
</p>

<p class="paragraph">
前掲のコードピースでは名無し配列を多段に組んでいる。この場合、入れ子になった配列のリファレンスを取り出し、$ary_bufとしてアクセスできている。
<br />
</p>
<pre>$ary2-&gt;[6][0]
</pre>
<p class="paragraph">
も、
<br />
</p>
<pre>$ary_buf-&gt;[0]
</pre>
<p class="paragraph">
も、両方同じ&quot;7&quot;を取得できている。
<br />
</p>

<h4 id="id1526fd">コードピース03 : ループアクセス(for, foreach)</h4>
<ul><li> コードピース</li></ul>
<pre>my @ary3 = (1, 2, 3);
print join(&quot; &quot;, @ary3), &quot;\n&quot;;          # ... (a)

for(my $i = 0; $i &lt; @ary3; $i++) {
	$ary3[$i]++;
}
print join(&quot; &quot;, @ary3), &quot;\n&quot;;          # ... (b)

foreach my $e (@ary3) {
	$e++;
}
print join(&quot; &quot;, @ary3), &quot;\n&quot;;          # ... (c)

foreach (@ary3) {
	$_++;
}
print join(&quot; &quot;, @ary3), &quot;\n&quot;;          # ... (d)

for my $i (@ary3) {
	$i++;
}
print join(&quot; &quot;, @ary3), &quot;\n&quot;;          # ... (e)

for (@ary3) {
	$_++;
}
print join(&quot; &quot;, @ary3), &quot;\n&quot;;          # ... (f)
</pre>

<ul><li> 出力</li></ul>
<pre>1 2 3 # (a)
2 3 4 # (b)
3 4 5 # (c)
4 5 6 # (d)
5 6 7 # (e)
6 7 8 # (f)
</pre>

<p class="paragraph">
(a)は基本中の基本であるが、よりエレガントに見える書き方は (d) や (f) であろう。いずれにせよ、どの書き方も正しく配列の要素を+1できている。
<br />
</p>

<p class="paragraph">
なお、前掲のコードピースは配列の実体を対象にしてのコードだった。下記に、同じ出力結果になる、名無し配列リファレンスを使用した場合のコードを示す。
<br />
</p>

<pre>my $ary3b = [1, 2, 3];
print join(&quot; &quot;, @$ary3b), &quot;\n&quot;;
for(my $i = 0; $i &lt; @$ary3b; $i++) {
	$ary3b-&gt;[$i]++;
}
print join(&quot; &quot;, @$ary3b), &quot;\n&quot;;
foreach my $e (@$ary3b) {
	$e++;
}
print join(&quot; &quot;, @$ary3b), &quot;\n&quot;;
foreach (@$ary3b) {
	$_++;
}
print join(&quot; &quot;, @$ary3b), &quot;\n&quot;;
for my $i (@$ary3b) {
	$i++;
}
print join(&quot; &quot;, @$ary3b), &quot;\n&quot;;
for (@$ary3b) {
	$_++;
}
print join(&quot; &quot;, @$ary3b), &quot;\n&quot;;
</pre>

<h4 id="ided70e0">コードピース04 : 間違いやすい配列のスライスについて($ary[x]と@ary[x]の違い)</h4>
<p class="paragraph">
print するだけのミニマムテストでは分かりづらいが、
<br />
</p>
<pre>print $ary[0]
</pre>
<p class="paragraph">
と
<br />
</p>
<pre>print @ary[0]
</pre>
<p class="paragraph">
は異なる。
<br />
</p>

<p class="paragraph">
前者は&quot;$&quot;が付いている為スカラーコンテキストで評価され、配列の要素としてアクセスされる。後者は&quot;@&quot;が付いている為、配列、すなわち&#039;&#039;スライス&#039;&#039;としてアクセスされる。
<br />
</p>

<ul><li> コードピース</li></ul>
<pre>my @ary4 = (&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;);
print $ary4[0], &quot;\n&quot;;
print @ary4[0], &quot;\n&quot;; # ← (a)
print $ary4[1, 2], &quot;\n&quot;; # ← (b)
print join(&quot; &quot;, @ary4[1, 2]), &quot;\n&quot;;
print join(&quot; &quot;, @ary4[1 ... 4]), &quot;\n&quot;;
print join(&quot; &quot;, @ary4[1 ... 5]), &quot;\n&quot;; # ← (c)
</pre>

<ul><li> 出力</li></ul>
<pre>Scalar value @ary4[0] better written as $ary4[0] at ... (a)
Multidimensional syntax $ary4[1, 2] not supported at ... (b)
abc # ← print $ary4[0]
abc # ← print @ary4[0] ... (a)
ghi # ← print $ary4[1, 2] ... (b)
def ghi # ← print join(&quot; &quot;, @ary4[1, 2])
def ghi jkl mno # ← print join(&quot; &quot;, @ary4[1 ... 4])
Use of uninitialized value in join or string at ... (c)
def ghi jkl mno
</pre>

<p class="paragraph">
(a), (b) のようにスカラーが予想される値を&quot;@&quot;としてアクセス(a)したり、スライスが予想される値を&quot;$&quot;としてアクセス(b)すると、警告が発せられる。
<br />
またスライスでも、要素INDEXを越えてアクセスしようとすると(c)のように警告が発せられる。
<br />
</p>

<p class="paragraph">
書いている本人自身も実は何回も間違えているように、Perl初学者にとってはとにかく間違いやすい。<strong> Perlにおいてはコンテキストが重要であり、変数がどのコンテキストで評価されるのかは、その冒頭に付く文字($, @, %, *)で判断される </strong>(それに加えて、前後のコードも関係する)。これについて、人間側で感情的な割り切りを行えれば、大分Perlの学習と理解も進むのかも知れない。
<br />
</p>

<h4 id="idb2efca">コードピース05 : ( 先頭 | 末尾 ) 要素の追加削除</h4>
<ul><li> コードピース</li></ul>
<pre>my @ary5 = (&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;);
#--------------------- (a) : 末尾要素を削除
my $buf = pop @ary5;
print join(&quot; &quot;, @ary5), &quot;\n&quot;;
print $buf, &quot;\n&quot;;
#--------------------- (b) : 末尾要素に追加
$buf = push(@ary5, 7);
print join(&quot; &quot;, @ary5), &quot;\n&quot;;
print $buf, &quot;\n&quot;;
#--------------------- (c) : 先頭要素を削除
$buf = shift @ary5;
print join(&quot; &quot;, @ary5), &quot;\n&quot;;
print $buf, &quot;\n&quot;;
#--------------------- (d) : 先頭要素に追加
$buf = unshift(@ary5, &quot;xyz&quot;);
print join(&quot; &quot;, @ary5), &quot;\n&quot;;
print $buf, &quot;\n&quot;;
#--------------------- (e) : スカラーコンテキストで評価
print scalar(@ary5), &quot;\n&quot;;
</pre>

<ul><li> 出力</li></ul>
<pre>#--------------------- (a) : 末尾要素を削除
abc def ghi jkl
mno # 削除された要素の値
#--------------------- (b) : 末尾要素に追加
abc def ghi jkl 7
5 # 追加後の配列の要素数
#--------------------- (c) : 先頭要素を削除
def ghi jkl 7
abc # 削除された要素の値
#--------------------- (d) : 先頭要素に追加
xyz def ghi jkl 7
5 # 追加後の配列の要素数
#--------------------- (e) : スカラーコンテキストで評価
5
</pre>

<h4 id="ide6f933">コードピース06 : 配列へのundefの代入と、空リストの判別</h4>
<p class="paragraph">
undef代入の幾つかのパターンと、空のリストで有ることをどうやって判別を示す。
<br />
</p>
<ul><li> コードピース</li></ul>
<pre>#--------------------- (a)
my @ary6 = ();
if(@ary6) {
	print Dumper @ary6, &quot;\n&quot;;
} else {
	print &quot;ary6 is not defined.(a)\n&quot;;
}
#--------------------- (b)
@ary6 = undef;
if(@ary6) {
	print Dumper @ary6, &quot;\n&quot;;
} else {
	print &quot;ary6 is not defined.(b)\n&quot;;
}
#--------------------- (c)
@ary6 = 1 .. 5;
@ary6[2, 4] = undef;
print Dumper @ary6, &quot;\n&quot;;
#--------------------- (d)
undef @ary6;
if(@ary6) {
	print Dumper @ary6, &quot;\n&quot;;
} else {
	print &quot;ary6 is not defined.(d)\n&quot;;
}
</pre>

<ul><li> 出力</li></ul>
<pre>#--------------------- (a)
ary6 is not defined.(a)
#--------------------- (b)
$VAR1 = undef;
$VAR2 = &#039;
&#039;;
#--------------------- (c)
$VAR1 = 1;
$VAR2 = 2;
$VAR3 = undef;
$VAR4 = 4;
$VAR5 = undef;
$VAR6 = &#039;
&#039;;
#--------------------- (d)
ary6 is not defined.(d)
</pre>

<ul><li> (a) : 空のリスト&quot;()&quot;で初期化した直後の配列は、if()のスカラーコンテキストでは要素数が&quot;0&quot;、すなわち偽として評価される。</li>
<li> (b) : その後、undefを代入してみると、興味深いことに要素数が2で末尾の要素が空になる。</li>
<li> (c) : また、配列のスライスを利用してundefを代入すると、該当要素のみundefになっている。</li>
<li> (d) : undef動詞<span class="hidden">(</span><a class="footnote" href="#footnote_112_2" id="footnote_112_2_r"  title="Effective Perlの訳書の表現">*2</a><span class="hidden">)</span>を使用すると、if()のスカラーコンテキストで偽として評価される。</li></ul>

<p class="paragraph">
注意すべきは、<strong> defined は Perl5.004以降、スカラー変数を対象とするようになり、配列やハッシュは非推奨になっている </strong>点である。
<br />
</p>
<ul><li> <a class="externallink" href="http://perldoc.perl.org/functions/defined.html" target="_blank">http://perldoc.perl.org/functions/defined.html</a></li>
<li> <a class="externallink" href="http://perldoc.perl.org/perlfaq4.html#Why-does-defined%28%29-return-true-on-empty-arrays-and-hashes%3F" target="_blank">http://perldoc.perl.org/perlfaq4.html#Why-does-defined%28%29-return-true-on-empty-arrays-and-hashes%3F</a></li></ul>

<p class="paragraph">
このため、下記のコードはwarningを生成する。
<br />
</p>
<pre>if(defined(@ary6)) { ...
→
defined(@array) is deprecated at ...
       (Maybe you should just omit the defined()?)
</pre>

<p class="paragraph">
では、厳密な意味で &quot;@ary6&quot; がundefなのか、空リストであるのか、をどうやって見分けるのか？については残念ながら現段階では調べ切れていない。%::などを用いて直接シンボルテーブルにアクセス・・・しても、lexical変数であればそれも無意味である。
<br />
</p>

<p class="paragraph">
とりあえず、
<br />
</p>
<pre>my @ary = ();
# or
undef @ary;
</pre>
<p class="paragraph">
は偽になるが、
<br />
</p>
<pre>my @ary = undef;
</pre>
<p class="paragraph">
は偽にならないという点に十分注意する。
<br />
</p>

<h3 id="idbeab1c">ハッシュ</h3>

<p class="paragraph">
ハッシュについてはその基本操作の殆どが、冒頭でリンクとして挙げたPerl講座で網羅されている。ここでは実体のコンストラクタである&quot;(&quot;, &quot;)&quot;と、リファレンスコンストラクタ&quot;{&quot;, &quot;}&quot;の差異をメインに、ざっと流すに留める。<span class="hidden">(</span><a class="footnote" href="#footnote_112_3" id="footnote_112_3_r"  title="というか正直、smartのPerl講座がわかりやすすぎて、自分で実験・検証する気力が無くなりました。やっぱり本職のドキュメントは素晴らしいです。">*3</a><span class="hidden">)</span>
<br />
</p>

<h4 id="id745908">コードピース01 : ハッシュの実体コンストラクタ&quot;(&quot;, &quot;)&quot; とループアクセス(while, each)</h4>
<ul><li> コードピース</li></ul>
<pre>my %h1 = ( abc =&gt; 123, &quot;def&quot; =&gt; 456, &#039;ghi&#039; =&gt; 789 );
#--------------------- (a)
print Dumper(%h1), &quot;\n&quot;;
#--------------------- (b)
print $h1{&#039;abc&#039;}, &quot;\n&quot;;
#--------------------- (c)
while(my ($key, $val) = each(%h1)) {
	print &quot;[$key] = $val\n&quot;;
}
</pre>

<ul><li> 出力</li></ul>
<pre>#--------------------- (a)
$VAR1 = &#039;def&#039;;
$VAR2 = 456;
$VAR3 = &#039;abc&#039;;
$VAR4 = 123;
$VAR5 = &#039;ghi&#039;;
$VAR6 = 789;
#--------------------- (b)
123
#--------------------- (c)
[def] = 456
[abc] = 123
[ghi] = 789
</pre>

<ul><li> (a) を見てみると、Dumperの出力上は通常の配列と何ら変わりないようにも見える。出典は失念したが、どこかのドキュメントにハッシュは内部的には配列の形で保持されていると書かれていたのをおぼえている。その記憶をこの出力は補強している。<span class="hidden">(</span><a class="footnote" href="#footnote_112_4" id="footnote_112_4_r"  title="おそらくEffective Perlの33項「名無しハッシュによってC言語スタイルの構造体を構築する」の&quot;*5&quot;の箇所と思われる。リファレンスを用いたアクセス($h-&gt;{hoge})は配列アクセスに最適化される、という箇所。">*4</a><span class="hidden">)</span></li>
<li> (b) では、普通にキーを指定してスカラーコンテキストでアクセスする方法を示している。代入式の左辺(LVALUE)としても使える。</li>
<li> (c) では、whileとeachを組み合わせて、キーと値のペアをループでアクセスする方法を示している。<ul><li> 但し、出力がそうであるように、while-eachの組み合わせではキー値のソートが保証されない。単純な&quot;for $key (keys(%hash)) &quot;でもそのようである。</li>
<li> キー値をソートして用いる場合は下記コードのようになる。詳しくはsmartのPerl講座を参照。</li></ul></li></ul>
<pre>for my $key (sort(keys(%h1))) {
	print &quot;[$key] = &quot;, $h1{$key}, &quot;\n&quot;;
}
→
[abc] = 123
[def] = 456
[ghi] = 789
</pre>

<h4 id="idf2d495">コードピース02 : ハッシュのリファレンスコンストラクタ&quot;{&quot;, &quot;}&quot;</h4>
<p class="paragraph">
&quot;(&quot;, &quot;)&quot;を用いるとハッシュの実体を作成できた。続いて、<strong> 名無しハッシュ </strong>のコンストラクタである&quot;{&quot;, &quot;}&quot;の使用例を示す。
<br />
</p>

<ul><li> コードピース</li></ul>
<pre>my $h2 = { abc =&gt; 123, &quot;def&quot; =&gt; (4, 5, 6), &quot;ghi&quot; =&gt; [7, 8, 9 ] };
#--------------------- (a)
print Dumper($h2), &quot;\n&quot;;
#--------------------- (b)
print $h2-&gt;{&#039;abc&#039;}, &quot;\n&quot;;
print $h2-&gt;{&#039;def&#039;}, &quot;\n&quot;;
print $h2-&gt;{&#039;ghi&#039;}, &quot;\n&quot;;
print $h2-&gt;{&#039;ghi&#039;}-&gt;[0], &quot;\n&quot;;
print $h2-&gt;{&#039;ghi&#039;}-&gt;[1], &quot;\n&quot;;
print $h2-&gt;{&#039;5&#039;}, &quot;\n&quot;;
#--------------------- (c)
while(my ($key, $val) = each(%$h2)) {
	print &quot;[$key] = $val\n&quot;;
}
</pre>

<ul><li> 出力</li></ul>
<pre>#--------------------- (a)
$VAR1 = {
          &#039;def&#039; =&gt; 4,
          &#039;abc&#039; =&gt; 123,
          &#039;ghi&#039; =&gt; [
                     7,
                     8,
                     9
                   ],
          &#039;5&#039; =&gt; 6  # ← !!注意!!
        };
#--------------------- (b)
123             # $h2-&gt;{&#039;abc&#039;}
4               # $h2-&gt;{&#039;def&#039;}
ARRAY(0x275028) # $h2-&gt;{&#039;ghi&#039;}
7               # $h2-&gt;{&#039;ghi&#039;}-&gt;[0]
8               # $h2-&gt;{&#039;ghi&#039;}-&gt;[1]
6               # $h2-&gt;{&#039;5&#039;}
#--------------------- (c)
[def] = 4
[abc] = 123
[ghi] = ARRAY(0x275028)
[5] = 6  # ← !!注意!!
</pre>

<ul><li> (a) : コンストラクタでリストを用いたり、名無し配列リファレンスを用いた例を示す。<strong> リスト部分(4,5,6)が分割されてしまっている点に注意！！ </strong></li>
<li> (b) : ハッシュリファレンスを用いた一般的なアクセス例を示す。</li>
<li> (c) : ハッシュリファレンスのループ処理の例を示す。eachでは、明示的に&#039;%&#039;を頭に付けてハッシュコンテキストで評価させている点に注意。</li>
<li> この、(4, 5, 6)が展開されている箇所は、次のコードピースを見てみると実に興味深い。<span class="hidden">(</span><a class="footnote" href="#footnote_112_5" id="footnote_112_5_r"  title="けど、実際の内部処理の仕掛けはまだ未調査です・・・。">*5</a><span class="hidden">)</span></li></ul>

<h4 id="id3a1d9b">コードピース03 : ハッシュのコンストラクタの亜種（配列風味）</h4>
<p class="paragraph">
実際のところ、&quot;=&gt;&quot;を使用せずともハッシュは作れるようである。要は変数が&quot;%&quot;としてハッシュコンテキストで実体が代入されるか、&quot;{&quot;, &quot;}&quot; で囲まれたリストとしてハッシュのリファレンスで代入されるか、どちらでもハッシュとして扱えるようである。
<br />
</p>

<ul><li> コードピース</li></ul>
<pre>my %h3 = ( &quot;abc&quot;, 123, &quot;def&quot;, 4, 5, 6, &quot;ghi&quot;, [7, 8, 9] );
my $h4 = { &quot;abc&quot;, 123, &quot;def&quot;, 4, 5, 6, &quot;ghi&quot;, [7, 8, 9] };
#--------------------- (a)
print Dumper(%h3), &quot;\n&quot;;
print Dumper(%$h4), &quot;\n&quot;;
#--------------------- (b)
print Dumper(\%h3), &quot;\n&quot;;
print Dumper($h4), &quot;\n&quot;;
</pre>

<ul><li> 出力</li></ul>
<pre>#--------------------- (a)
# %h3
$VAR1 = &#039;def&#039;;
$VAR2 = 4;
$VAR3 = &#039;abc&#039;;
$VAR4 = 123;
$VAR5 = &#039;ghi&#039;;
$VAR6 = [
          7,
          8,
          9
        ];
$VAR7 = &#039;5&#039;;
$VAR8 = 6;
# %$h4(ハッシュコンテキストで評価)
$VAR1 = &#039;def&#039;;
$VAR2 = 4;
$VAR3 = &#039;abc&#039;;
$VAR4 = 123;
$VAR5 = &#039;ghi&#039;;
$VAR6 = [
          7,
          8,
          9
        ];
$VAR7 = &#039;5&#039;;
$VAR8 = 6;
#--------------------- (b)
# \%h3(リファレンス経由で評価)
$VAR1 = {
          &#039;def&#039; =&gt; 4,
          &#039;abc&#039; =&gt; 123,
          &#039;ghi&#039; =&gt; [
                     7,
                     8,
                     9
                   ],
          &#039;5&#039; =&gt; 6
        };
# $h4
$VAR1 = {
          &#039;def&#039; =&gt; 4,
          &#039;abc&#039; =&gt; 123,
          &#039;ghi&#039; =&gt; [
                     7,
                     8,
                     9
                   ],
          &#039;5&#039; =&gt; 6
        };
</pre>

<p class="paragraph">
見ての通り、コンテキストさえ合わせればどちらも同じ形式で扱えるようである。
<br />
</p>

<h4 id="idcc956a">コードピース04 : ハッシュのスライスとundef</h4>
<ul><li> コードピース</li></ul>
<pre>my %h5 = (&quot;abc&quot; =&gt; 123, &quot;def&quot; =&gt; 456, &quot;ghi&quot; =&gt; 789);
my $h6 = {&quot;abc&quot; =&gt; 123, &quot;def&quot; =&gt; 456, &quot;ghi&quot; =&gt; 789};
#--------------------- (a)
print join(&quot; &quot;, @h5{&quot;abc&quot;, &quot;ghi&quot;}), &quot;\n&quot;;
print join(&quot; &quot;, @$h6{&quot;def&quot;, &quot;ghi&quot;}), &quot;\n&quot;;
#--------------------- (b)
@h5{&quot;ghi&quot;, &quot;abc&quot;} = @h5{&quot;abc&quot;, &quot;ghi&quot;};
@$h6{&quot;def&quot;, &quot;abc&quot;} = @$h6{&quot;abc&quot;, &quot;def&quot;};
for my $key (sort(keys(%h5))) {
	print &quot;[$key] = &quot;, $h5{$key}, &quot;\n&quot;;
}
for my $key (sort(keys(%$h6))) {
	print &quot;[$key] = &quot;, $h6-&gt;{$key}, &quot;\n&quot;;
}
#--------------------- (c)
@h5{&quot;abc&quot;, &quot;ghi&quot;} = (undef, undef);
@$h6{&quot;abc&quot;, &quot;def&quot;} = (undef, undef);
print Dumper(%h5), &quot;\n&quot;;
print Dumper(%$h6), &quot;\n&quot;;
#--------------------- (d)
my %h7 = ();
if(keys(%h7)) {
	print Dumper(%h7);
} else {
	print &quot;%h7 is empty.\n&quot;;
}
</pre>

<ul><li> 出力</li></ul>
<pre>#--------------------- (a)
123 789
456 789
#--------------------- (b)
# %h5
[abc] = 789
[def] = 456
[ghi] = 123
# $h6
[abc] = 456
[def] = 123
[ghi] = 789
#--------------------- (c)
# %h5
$VAR1 = &#039;def&#039;;
$VAR2 = 456;
$VAR3 = &#039;abc&#039;;
$VAR4 = undef;
$VAR5 = &#039;ghi&#039;;
$VAR6 = undef;
# $h6
$VAR1 = &#039;def&#039;;
$VAR2 = undef;
$VAR3 = &#039;abc&#039;;
$VAR4 = undef;
$VAR5 = &#039;ghi&#039;;
$VAR6 = 789;
#--------------------- (d)
%h7 is empty.
</pre>

<ul><li> (a) : 任意のキーをつなげて、&quot;@&quot;によりスライスとして評価され、キーの値のリストが取得できている。</li>
<li> (b) : スライスを利用して、任意のキー間で値のswapを行える。</li>
<li> (c) : スライスに対しundefのリストを代入することで、undefを設定できる。（キー自体の削除は、deleteを使用する。)</li></ul>
<pre>例：delete @hash_slice{&#039;keyA&#039;, &#039;keyC&#039;};
</pre>
<ul><li> (d) : キーが空の場合は、&quot;keys&quot;を使用して、空のハッシュを判別できる。</li></ul>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-130.html" title="Perl/codepiece/OOPメモ">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-343.html" title="Perl/codepiece/array_hash2(関数への参照渡し)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-109.html" title="Perl">Perl</a>&nbsp;]</li>
</ul><div class="footnote">
<a id="footnote_112_1" href="#footnote_112_1_r">*1</a>: &quot;Effective Perl&quot;上では&quot;リストリテラル&quot;と表記されているが・・・上手い日本語が分かりません。<br />
<a id="footnote_112_2" href="#footnote_112_2_r">*2</a>: Effective Perlの訳書の表現<br />
<a id="footnote_112_3" href="#footnote_112_3_r">*3</a>: というか正直、smartのPerl講座がわかりやすすぎて、自分で実験・検証する気力が無くなりました。やっぱり本職のドキュメントは素晴らしいです。<br />
<a id="footnote_112_4" href="#footnote_112_4_r">*4</a>: おそらくEffective Perlの33項「名無しハッシュによってC言語スタイルの構造体を構築する」の&quot;*5&quot;の箇所と思われる。リファレンスを用いたアクセス($h-&gt;{hoge})は配列アクセスに最適化される、という箇所。<br />
<a id="footnote_112_5" href="#footnote_112_5_r">*5</a>: けど、実際の内部処理の仕掛けはまだ未調査です・・・。
</div>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/112<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2007 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>