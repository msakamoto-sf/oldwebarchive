<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>抄訳メモ/unixwiz.net/Using Win32 calling conventions - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">抄訳メモ/unixwiz.net/Using Win32 calling conventions</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-02-05 21:24:04 &nbsp; / &nbsp; last updated at: 2010-02-07 14:09:52<br>
カテゴリ: <a href="category-48.html">Assembler</a>&nbsp;<a href="category-10.html">C言語</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-580.html" title="抄訳メモ/unixwiz.net/Intel x86 Function-call Conventions - Assembly View">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-578.html" title="抄訳メモ">抄訳メモ</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
原文：
<br />
</p>
<ul><li> unixwiz.net, Using Win32 calling conventions<ul><li> <a class="externallink" href="http://unixwiz.net/techtips/win32-callconv.html" target="_blank">http://unixwiz.net/techtips/win32-callconv.html</a></li></ul></li></ul>




<p class="paragraph">
Windows上のC言語プログラミングで、多くの開発者は「呼び出し規約」(calling convention)に注意を払わない。しかしコードの規模が大きくなるに従いソースコードをモジュールに分割する時、特に外部のライブラリやDLLを使う時、呼び出し規約は無視出来なくなる。
<br />
この記事では、特にMicrosoftのVisualC++コンパイラ(MSVC)でサポートする呼び出し規約と、呼び出し規約を適切に選択する理由、より大きなソースコードで注意すべきポイントについて検討する。
<br />
</p>
<ul><li><a href="#idd61c81">呼び出し規約(&quot;Calling Conventions&quot;)</a><ul><li><a href="#id6b43ab">引数をpushする順番は右から？左から？</a></li></ul></li>
<li><a href="#id7f736c">リンカーによるシンボル名修飾</a></li>
<li><a href="#id677a7c">呼び出し規約のミスマッチはコンパイラでは検出しないのか？</a></li>
<li><a href="#idba9b7c">呼び出し規約に注意する場面</a></li>
<li><a href="#idbda4eb">DLLで提供される関数を呼ぶ場合</a></li>
<li><a href="#idb85b72">大規模システムの構築</a></li></ul>
<hr />
<h3 id="idd61c81">呼び出し規約(&quot;Calling Conventions&quot;)</h3>

<p class="paragraph">
伝統的なC言語の関数呼び出しは、次の手順で実現される。
<br />
</p>
<ol><li> 呼び出し側は引数をスタックにpushする。</li>
<li> 関数を呼ぶ。</li>
<li> スタックにpushした引数をpopしてスタックをクリーンアップする。</li></ol>

<pre>/* example of __cdecl */
push arg1
push arg2
push arg3
call function
add  sp,12        // &quot;pop; pop; pop&quot;と同義
</pre>

<p class="paragraph">
Windows上のMicrosoft社のコンパイラは上のような呼び出し規約だけではなく、後で見るように複数の呼び出し規約をサポートしている。
<br />
</p>

<p class="paragraph">
上のような呼び出し規約は、<strong>__cdecl</strong>として知られている。
<br />
</p>

<p class="paragraph">
他の呼び出し規約で有名なのは<strong>__stdcall</strong>がある。呼び出し側で引数群をスタックにpushするところは同じだが、スタックのクリーンアップは<em>呼ばれる側(calee)で</em>実行される。こちらがWin32API関数群の標準的な規約で、windows.h内でWINAPIマクロとして定義されている。また、&quot;Pascal&quot;呼び出し規約と呼ばれる場合もある。
<br />
</p>
<pre>/* example of __stdcall */
push arg1
push arg2
push arg3
call function
// 呼び出し側ではスタックをクリーンアップしない。
</pre>

<p class="paragraph">
スタックのクリーンアップをどちらで行うのかは、僅かな差に見えるが、呼ぶ側・呼ばれる側が同じ規約に従っていないとスタックの内容が破壊されてしまう。
<br />
プログラムの実行時に呼び出し規約のミスマッチが発生すると、プログラムのクラッシュなど破壊的な結果につながる。
<br />
</p>

<p class="paragraph">
他にも<strong>__fastcall</strong>という呼び出し規約を取りあげるが、これについては一般的な場面ではそれほど使わないと考えている。レジスタでの引数渡しは、レジスタの保存と復元が必要で速度上のメリットは得られないと考えている。
<br />
</p>

<ul><li><strong>__stdcall</strong>ではスタックのクリーンアップのコードが関数側に実装される。一方、<strong>__cdecl</strong>では関数を呼び出す場所毎にクリーンアップコードが実装されるため、__cdeclではコードサイズが微増する。巨大なプログラムの場合はこの差ははっきりしてくるだろう。</li>
<li> printf()のような可変長引数を取る関数は __stdcall を使うことが出来ない。なぜなら、呼び側だけが引数をいくつスタックにpushしたのかを知っているからだ。もちろん呼ばれる側で、引数の中身を見ることで引数の数を予想することが可能な「場合もある」だろうが、呼び出し規約の機構としては引数の数は呼ばれる側(calee)では分からないようになっている。呼ぶ側でスタックをクリーンアップする __cdecl だけが可変長引数を使う関数をサポートする。</li>
<li> どの呼び出し規約が「正しいか正しくないか」という議論は無意味である。しかし「呼び出し規約のミスマッチ」は避けなくてはならない。呼ぶ側・呼ばれる側で呼び出し規約が異なると、スタックを破壊する場合がある。</li></ul>

<h4 id="id6b43ab">引数をpushする順番は右から？左から？</h4>

<p class="paragraph">
引数をスタックにpushするとき、右からpushするか左からpushするかどちらが「正しい」かについては明確になっていない。コンパイラの作者の好みで順番が決まるが、大体の場合はマシンアーキテクチャに依存する。
<br />
著者らの意見では、スタックがアドレスの低位方向に伸びていく場合は右から左へpushしていき、アドレスの高位方向に伸びていく場合は左から右へpushしていくように思われる。
<br />
プログラマが明示的に指定出来る呼び出し規約と異なり、引数のpushする順番はコンパイラだけが決定し、本記事で検討する呼び出し規約のミスマッチとは関係ない。もし異なるアーキテクチャに移植が容易なコードを書きたい場合は、引数のpush順序に依存するコードは絶対に書いてはならない。
<br />
</p>

<h3 id="id7f736c">リンカーによるシンボル名修飾</h3>

<p class="paragraph">
上の箇条書きで示したように、呼び出し規約のミスマッチは致命的である。Microsoftはミスマッチを回避する為のメカニズムを提供しており、うまく動いてくれるのだが、理由を知らない人には何故そうなっているのか全く分からないようになっている。
<br />
</p>

<p class="paragraph">
このメカニズムは、リンカレベルで関数名に呼び出し規約に応じた接頭・接尾辞を修飾したシンボル名に変換する。デフォルトの呼び出し規約は __cdecl だが、&quot;/G?&quot; コンパイラオプションで明示的に変更出来る。
<br />
</p>

<dl>
<dt> __cdecl (cl /Gd ...) </dt>
<dd>シンボル名はアンダースコア1つ + 元の関数名に変換される。引数の数は重要ではない為シンボル名には現れない。スタックの準備とクリーンアップは呼び出し側が責任を持つ。もちろん呼ぶ側・呼ばれる側で引数の数についてミスマッチが発生する場合はあり得るが、少なくともスタックは適切に制御される。</dd>
<dt> __stdcall (cl /Gz ...) </dt>
<dd>シンボル名はアンダースコア1つ + 元の関数名 + &quot;@&quot; + スタックにpushされた引数のバイト数に変換される。これにより、異なる呼び出し規約の関数 or 引数の数が異なる同名関数をリンクする危険を回避出来る。</dd>
<dt> __fastcall (cl /Gr ...) </dt>
<dd>シンボル名は&quot;@&quot; + 元の関数名 + &quot;@&quot; + 引数のバイト数に変換される。__fastcallでは引数の最初の2つについてはECX, EDXレジスタに格納され、残りがスタックに積まれるが、シンボル名に出てくる引数のバイト数はレジスタに格納される分も含めて全ての引数の数で計算される。なお __fastcall は __cdecl と同様、スタックのクリーンアップは呼ぶ側で行う。</dd>
</dl>

<p class="paragraph">
例：
<br />
</p>
<table>
	<tr>
		<td> 宣言 </td>
		<td> シンボル名 </td>
	</tr>
	<tr>
		<td> void __cdecl    foo(void); </td>
		<td> _foo </td>
	</tr>
	<tr>
		<td> void __cdecl    foo(int a); </td>
		<td> _foo </td>
	</tr>
	<tr>
		<td> void __cdecl    foo(int a, int b); </td>
		<td> _foo </td>
	</tr>
	<tr>
		<td> void __stdcall  foo(void); </td>
		<td> _foo@0 </td>
	</tr>
	<tr>
		<td> void __stdcall  foo(int a); </td>
		<td> _foo@4 </td>
	</tr>
	<tr>
		<td> void __stdcall  foo(int a, int b); </td>
		<td> _foo@8 </td>
	</tr>
	<tr>
		<td> void __fastcall foo(void); </td>
		<td> @foo@0 </td>
	</tr>
	<tr>
		<td> void __fastcall foo(int a); </td>
		<td> @foo@4 </td>
	</tr>
	<tr>
		<td> void __fastcall foo(int a, int b); </td>
		<td> @foo@8 </td>
	</tr>
</table>

<p class="paragraph">
リンカーレベルでのシンボル名は、Cのソースコードの世界では意識する必要がない。コンパイラ・リンカの内部でシンボル名の処理が行われるので、呼び出し規約が異なる関数がリンクされる危険は回避される。
<br />
以下に、わざと未定義の関数をリンクさせることでリンカレベルでシンボル名がどう変換されているのか確認する例を示す。
<br />
</p>
<pre class="plugin_pre">
C&gt; type testfile.c
extern void __stdcall func1(int a);
extern void __stdcall func2(int a, int b, double d);
extern void __cdecl   func3(int b);
extern void __cdecl   func4(int a, int b, double d);

int __cdecl main(int argc, char **argv)
{
        func1(1);

        func2(2, 3, 4.);

        func3(5);

        func4(6, 7, 8.0);

        return 0;
}

C&gt; cl /nologo testfile.c
testfile.c
testfile.obj : error LNK2001: unresolved external symbol _func1@4  ... __stdcall
testfile.obj : error LNK2001: unresolved external symbol _func2@16 ... __stdcall
testfile.obj : error LNK2001: unresolved external symbol _func3    ... __cdecl
testfile.obj : error LNK2001: unresolved external symbol _func4    ... __cdecl
testfile.exe : fatal error LNK1120: 4 unresolved externals
</pre>
<p class="paragraph">
func2()については、引数が3つなのに4word(4x4=16byte)分の接尾辞がついて&quot;_func2@16&quot;になっている。これは３番目の引数がdoubleのため、2word分占めているためである。またfunc3(), func4()については __cdecl 呼び出し規約なので、引数の数はシンボル名には影響していない。
<br />
</p>

<h3 id="id677a7c">呼び出し規約のミスマッチはコンパイラでは検出しないのか？</h3>

<p class="paragraph">
検出しない。
<br />
</p>

<p class="paragraph">
呼び出し規約によるシンボル名の修飾は、関数プロトタイプより狭い範囲の問題を解決する。
<br />
</p>

<p class="paragraph">
関数のプロトタイプ宣言はC++およびANSI-Cで導入された。以前のK&amp;R-Cでは関数の戻り値だけが関数の宣言に含まれ、引数の数は無視された。C++およびANSI-C以降は引数も含めて関数の宣言とされ、これにより引数が異なる関数呼び出しはコンパイラレベルで警告を発するようになった。
<br />
</p>

<pre>/* somefile.c */

extern int  foo(int a); // prototype
...
n = foo(1, 2, 3);  // mismatch! bad parameter count!
</pre>
<p class="paragraph">
コンパイラはfoo()関数はint型の引数を一つ必要と判断し、引数がそれより少ない or 多い呼び出し、および引数の型が異なる呼び出しについて警告を発する。呼び出し規約に応じたシンボル名の修飾は、この段階では全く関係してこない。
<br />
</p>

<p class="paragraph">
リンカレベルで問題になってくるのは、二つ以上のソースファイルに関数の定義と、関数を呼び出すコードが分離された場合である。
<br />
</p>

<p class="paragraph">
関数を呼ぶ側：
<br />
</p>
<pre class="plugin_pre">
/* in file1.c */

extern int __cdecl foo(int);

...
n = foo(1);
</pre>
<p class="paragraph">
関数の定義側：
<br />
</p>
<pre class="plugin_pre">
/* in file2.c */
int __stdcall foo(int a)
{
....
}
</pre>
<p class="paragraph">
コンパイラはfile1.cとfile2.cを同時にコンパイルすることは無い。そのため、コンパイラレベルでは二つのCソースの間での呼び出し規約のミスマッチを検出することは出来ない。もしシンボル名の修飾が行われず、このままリンクされてしまうとスタックの破壊を引き起こす。上の例で、file1.cで呼び出し規約の宣言を入れ忘れた場合も、コンパイラのデフォルト呼び出し規約である __cdecl が使われ、ミスマッチを引き起こす。
<br />
</p>

<p class="paragraph">
小さなプロジェクトでは、上のような例は明らかに意図的に作り出された状況であるが、大規模なプログラムでは意図せずに頻繁に発生するようになる。また外部のライブラリを使う場合も発生する。ライブラリの提供側が、どの呼び出し規約でコンパイルしたのか・コンパイルオプションの詳細などを伝えないケースは特に注意が必要である。
<br />
</p>

<p class="paragraph">
これらの理由が、リンカレベルで呼び出し規約に応じてシンボル名を修飾する理由である。プロトタイプ宣言により引数の数・型をチェックする機能とは関係ない。
<br />
</p>

<p class="paragraph">
<strong>重要：</strong>
<br />
呼び出し規約によるシンボル名の修飾は、スタック制御を維持するため「だけに」存在する。
<br />
</p>

<h3 id="idba9b7c">呼び出し規約に注意する場面</h3>

<p class="paragraph">
殆どのケースでは、プログラム全体でのデフォルト呼び出し規約と特定の関数の呼び出し規約は変わらない。ただし、デフォルトで __cdecl 以外を使っている場合、幾つかの例外が存在する。
<br />
</p>

<ul><li> &quot;main()&quot;関数および&quot;wmain()&quot;は __cdecl でなければならない。</li>
<li> GUIプログラムのエントリポイント、 &quot;WinMain()&quot;関数は __stdcall でなければならない。(windows.h中のWINAPIマクロ)</li>
<li> printf()のような可変長引数を使う関数は自動的に __cdecl になる。他の呼び出し規約を明示的に指定したとしても、コンパイラにより無視され、自動的に __cdecl として処理される。</li>
<li> 関数ポインタを引数にとるライブラリ関数は、呼び出し規約を合わせる必要がある。例えばqsort()関数は二つの要素を比較する為の関数アドレスを引数にとるが、その関数は __cdecl でなければならない。</li></ul>

<pre class="plugin_pre">
extern void __cdecl qsort( void *base, size_t num, size_t width,
          int (__cdecl *compare )(const void *, const void *) );
....
int __stdcall mycompare(const void *p1, const void *p2)
{
    // compare here
}
....
qsort(base, n, width, mycompare);    // ERROR - mismatch
</pre>

<p class="paragraph">
なおあくまでも「パラメータの呼び出し規約」を合わせるのであって、qsort()それ自体の呼び出し規約は無関係である点に注意する。
<br />
例えば下の例はセーフである。
<br />
</p>
<pre class="plugin_pre">
extern void __cdecl qsort( void *base, size_t num, size_t width,
          int (__stdcall *compare )(const void *, const void *) );
....
int __stdcall mycompare(const void *p1, const void *p2)
{
    // compare here
}
....
qsort(base, n, width, mycompare);
</pre>

<p class="paragraph">
callback関数を使う局面ではいずれにせよ呼び出し規約に注意する。他にもUNIXの場合、シグナルハンドラの呼び出し規約も注意の対象となるだろう。
<br />
</p>

<h3 id="idbda4eb">DLLで提供される関数を呼ぶ場合</h3>

<p class="paragraph">
ゼロからシステムを構築する場合、Makefileなどで呼び出し規約を調整することは自然な流れである。しかしサードパーティ製のDLLを使うようになると「ねじれ」が生じ始める。特に他の言語でコンパイルされたDLLの場合はなおさらである。
<br />
ヘッダーファイルやインポートライブラリが無く、DLLだけしか提供されていない場合はプログラム側で関数ポインタを取り出して呼び出し規約を指定することになり、コンパイラレベルでのサポートは望めない。
<br />
</p>

<p class="paragraph">
例として、バーコードを処理するBARCODE.DLLがあったとして、DLLが提供している関数を二つ、関数名から関数ポインタを取得して呼び出すシーンを考える：
<br />
</p>
<pre class="plugin_pre">
typedef BOOL (__stdcall *INITFUNCTION)(BOOL);
typedef int  (__stdcall *DRAWFUNCTION)(int x, int y, const char *label);

HINSTANCE hInst = LoadLibrary(&quot;barcode.dll&quot;);

INITFUNCTION pfInit = (INITFUNCTION)GetProcAddress(hInst, &quot;Init&quot;);
DRAWFUNCTION pfDraw = (DRAWFUNCTION)GetProcAddress(hInst, &quot;Draw&quot;);

(*pfInit)(TRUE);

(*pfDraw)(1, 1, &quot;12345&quot;);
(*pfDraw)(1, 2, &quot;67890&quot;);
</pre>
<p class="paragraph">
typedefで指定している __stdcall は、実際のDLL側と一致させなければならない。もし一致していないとしても、コンパイラ・リンカ共にそれを検出することは出来ず、実行時に判明することになる。
<br />
</p>

<p class="paragraph">
このような場合は、ライブラリの作者が提供しているドキュメントをチェックする以外の有効な代替策は無い。
<br />
</p>

<h3 id="idb85b72">大規模システムの構築</h3>

<p class="paragraph">
※かなり意訳になってます。
<br />
</p>

<p class="paragraph">
これまで見てきたように、小さなプログラムでは無視出来るが、システムが大きくなるにつれ、あるいは外部ライブラリを使うようになると呼び出し規約に注意する必要が出てくる。Windows以外の、呼び出し規約の概念が無いプラットフォームへ移植する場合はさらに複雑になる。
<br />
外部ライブラリのソースコードがあったとしても、例えばUNIX上で主に構築されたパッケージはMakefileで構築され、一方のWindowsではVisualStudioのプロジェクトファイルを中心としたビルドシステムになっている。このため、一方をもう一方のビルドシステムに組み込むのは簡単ではない。
<br />
</p>

<p class="paragraph">
著者らのお奨めとしては可能であれば &quot;__stdcall&quot; を使うことだが、重要なのは「全ての関数呼び出しで呼び出し規約を一致させること」であり、「どの呼び出し規約を使うか」はあまり重要ではない。全てのソースコードで同じ呼び出し規約を用いる必要はない。特定のライブラリだけ、メインのコード群とは別の呼び出し規約でコンパイルされても良いと考えている。
<br />
</p>

<p class="paragraph">
ここにライブラリを使う時のガイドラインの著者からのガイドラインを示したい：
<br />
</p>
<pre>外部公開するライブラリヘッダでは、全てにおいて呼び出し規約を明示的に指定するべきである。
（コンパイル時のデフォルトに依存しない）
</pre>

<p class="paragraph">
ライブラリヘッダがデフォルトに依存しないのであれば、それを使うモジュールは好きな呼び出し規約でコンパイル出来る。
<br />
</p>

<p class="paragraph">
Win32だけを想定したライブラリであれば、外部公開するライブラリヘッダの全関数に呼び出し規約を明示すれば充分だろう：
<br />
</p>
<pre class="plugin_pre">
/* mylibrary.h */

extern void * __stdcall circalloc(size_t n);
extern char * __stdcall circdup(const char *s);
extern char * __cdecl   circfmt(const char *fmt, ...);
extern BOOL   __stdcall set_inherit_handle(BOOL bInherit, HANDLE h);
extern void   __stdcall init_timestamp(void);
extern size_t __stdcall sprintf_timestamp(char *obuf);

typedef void __stdcall FAILHANDLER(int, const char *, const char *);
extern FAILHANDLER * __stdcall set_fail_handler(FAILHANDLER *pHdlr);
...
</pre>
<p class="paragraph">
typedefにも呼び出し規約を指定している点に注意する。FAILHANDLERはcallbackとしてset_fail_handlerに関数ポインタとして指定されるが、typedefに呼び出し規約を指定することで、アプリケーション側でも自動的にFAILHANDLERの呼び出し規約が適用される。
<br />
</p>

<p class="paragraph">
関数定義にまで呼び出し規約を明示する必要は、現実的にはそこまで厳しく必要とされていない。なぜなら、定義側で呼び出し規約を指定していない場合、ヘッダファイル中の宣言に含まれる呼び出し規約が適用されるからだ。逆に、ヘッダファイル中でのプロトタイプ宣言と実際の定義とで呼び出し規約が一致しない状況は避けなければならない。
<br />
</p>
<pre class="plugin_pre">
/* somefile.c */

extern void __stdcall foo1(void);
..
void foo1(void)      // OK - __stdcall taken from the declaration just seen
{
   ...
}


extern void __stdcall foo2(void);
...
void __cdecl foo2(void) // ERROR - clashes with __stdcall above
{
   ...
}


extern void foo3(void);   // presume __cdecl
...
void __stdcall foo3(void) // ERROR - clashes with presumed __cdecl
{
   ...
}
</pre>

<p class="paragraph">
あるモジュール内でしか使われない非公開な関数については呼び出し規約を明示する必要はない。関数の利用がコンパイルの単位(=ソースファイル)内で閉じていて、外部から呼ばれないようになっていれば、呼ぶ側・呼ばれる側でミスマッチする心配は無い。
<br />
</p>

<p class="paragraph">
呼び出し規約の指定だが、&quot;__stdcall&quot;などのキーワードがsyntax errorになるようなWin32以外のプラットフォームに移植する場合は少しトリックを使う必要が出てくる。
<br />
</p>
<pre>MSVC以外のプラットフォームにスムーズに対応する為、Cプリプロセッサと移植用のヘッダファイルを使う。
</pre>

<p class="paragraph">
著者らは、この問題に対応する為の定義(およびその他移植性を高める為の多数の定義)を含む&quot;portable.h&quot;というヘッダーファイルを作成している。
<br />
</p>
<pre>#ifndef _WIN32
#  define __cdecl    /* nothing */
#  define __stdcall  /* nothing */
#  define __fastcall /* nothing */
#endif /* _WIN32 */
</pre>

<p class="paragraph">
プラットフォームや開発環境によっては多少の調整を要する。また、&quot;_WIN32&quot;ではなく&quot;_MSC_VER&quot;を使ったり、&quot;__stdcall&quot;などを直接マクロで無効化するのではなく、WINAPIのようにラッパマクロを定義して切り替えるようにするなど改良の余地はある。
<br />
</p>

<p class="paragraph">
GCCを使う場合は、&quot;__attribute__&quot; 機能で呼び出し規約を指定出来たりするのでそちらを使っても良い。
<br />
</p>

<p class="paragraph">
重要なのは、「ライブラリをコンパイルした時の関数の呼び出し規約」と、「クライアント側がヘッダーファイルで取り込んだ関数宣言の呼び出し規約」、この２つが一致することである。
<br />
</p>

<p class="paragraph">
以上
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-580.html" title="抄訳メモ/unixwiz.net/Intel x86 Function-call Conventions - Assembly View">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-578.html" title="抄訳メモ">抄訳メモ</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/579<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2001 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" target="_blank" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>