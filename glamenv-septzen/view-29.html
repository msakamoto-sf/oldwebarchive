<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>PHP/「ページの有効期限切れ」対策 - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">PHP/「ページの有効期限切れ」対策</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2005-07-10 23:28:13 &nbsp; / &nbsp; last updated at: 2008-12-16 00:03:24<br>
カテゴリ: <a href="category-6.html">PHP</a>&nbsp;<a href="category-13.html">Web</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-42.html" title="PHP/xdebugメモ">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-37.html" title="PHP/セッションとクッキーの共存">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-25.html" title="PHP">PHP</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
特にIE系でよく見られる「ページの期限切れ」画面。これを発生させないためにはどうすればよいのか、現在は少しGoogleで検索するだけで実に様々な対策方法が蓄積されている。だが、そもそも「ページの期限切れ」とはいったい何を示しているのか？いったいこの画面はユーザーに何を訴えているのだろうか？
<br />
</p>

<p class="paragraph">
今回はPHP言語に限定して、この現象を可能な範囲その原因を追及し、抜本的対策と巷間にあふれる対策方法の是非を検討する。最終的に必要となった知識はHTTPのRFC2616のキャッシュ機能およびPHPのext/session/session.cのソースコードとなった。
<br />
</p>

<ul><li><a href="#id81cbc8">「ページの有効期限切れ」が発生するスクリプト・発生しないスクリプト</a><ul><li><a href="#id474e13">発生方法</a></li>
<li><a href="#id2c9b13">発生するスクリプト</a></li>
<li><a href="#id022111">発生しないスクリプト</a></li>
<li><a href="#id2b0406">ブラウザで異なる挙動(IE/FireFox)</a><ul><li><a href="#id1b8fed">発生するスクリプトの場合(Firefox)</a></li>
<li><a href="#idedc0bf">発生しないスクリプトの場合(IE/Firefox)</a></li></ul></li>
<li><a href="#id0b5376">推測：session_cache_limiter()が原因か？</a></li></ul></li>
<li><a href="#idf5b7e8">HTTPヘッダーの比較</a><ul><li><a href="#idfeda70">比較・解析・推測</a></li></ul></li>
<li><a href="#id90d815">HTTPのキャッシュ制御について</a><ul><li><a href="#id608341">キャッシュされる場所とキャッシュの許可の考え方</a></li>
<li><a href="#id804a6d">HTTP/1.0におけるキャッシュ制御ヘッダーフィールド(Expires, Pragma)</a></li>
<li><a href="#id7b1521">HTTP/1.1におけるキャッシュ制御ヘッダーフィールド(Cache-Control, Last-Modified)</a></li>
<li><a href="#id266bdd">ヘッダーフィールドと「ページの有効期限切れ」画面の関連についての第一のまとめ</a></li></ul></li>
<li><a href="#id68a9d7">そもそもなぜ「ページの有効期限切れ」対策に頭を悩ませるのか？</a></li>
<li><a href="#idc3154d">PHPのソースコードの探索</a><ul><li><a href="#id3fe3c2">PHP_FUNCTION(session_cache_limiter), PHP_FUNCTION(session_cache_expire)</a></li>
<li><a href="#id43028b">PS(cache_limiter), PS(cache_expire)</a></li>
<li><a href="#id555893">php_session_cache_limiter()</a></li>
<li><a href="#idd80bad">CACHE_LIMITER_FUNC(public, private_no_expire, private, nocache)</a></li>
<li><a href="#id72bec9">幾つかの間違いとそれでも動作する理由</a></li></ul></li>
<li><a href="#id76fa9f">まとめ - チケットの導入へ</a></li></ul>

<h3 id="id81cbc8">「ページの有効期限切れ」が発生するスクリプト・発生しないスクリプト</h3>

<p class="paragraph">
まず現象を再現するところから始める。「ページの有効期限切れ」画面が表示されるのはIE系なので、以下に示す各スクリプトもIEで表示させることを前提とする。Firefoxの場合の動作は後述する。
<br />
</p>

<h4 id="id474e13">発生方法</h4>
<ol><li> 「発生するスクリプト」を設置し、IE系のブラウザでアクセスする。</li>
<li> Submitボタンをクリックし、フォームを送信する。(テキストボックスは単に見栄えや何かの問題で付けただけで、特に使用することはないので適当な値を入力しても、空のまま送信しても問題ない)</li>
<li> ３～４回Submitしたのち、ブラウザバックする。（「戻る」ボタン or BackSpace）</li>
<li> 「ページの有効期限切れ」画面が表示される。</li></ol>

<h4 id="id2c9b13">発生するスクリプト</h4>
<ul><li> session01.php</li></ul>
<pre>&lt;?php
session_name(&#039;CacheExpireExperiment01&#039;);
session_start();
?&gt;
&lt;html&gt;
&lt;body&gt;
&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt;
&lt;input type=&quot;text&quot; value=&quot;&quot; name=&quot;&quot;&gt;
&lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<ul><li> session02.php</li></ul>
<pre>&lt;?php
session_cache_limiter(&#039;nocache&#039;);
session_name(&#039;CacheExpireExperiment02&#039;);
session_start();
?&gt;
&lt;html&gt;
&lt;body&gt;
&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt;
&lt;input type=&quot;text&quot; value=&quot;&quot; name=&quot;&quot;&gt;
&lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<h4 id="id022111">発生しないスクリプト</h4>
<ul><li> session03.php</li></ul>
<pre>&lt;?php
session_cache_limiter(&#039;private&#039;);
session_name(&#039;CacheExpireExperiment03&#039;);
session_start();
?&gt;
&lt;html&gt;
&lt;body&gt;
&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt;
&lt;input type=&quot;text&quot; value=&quot;&quot; name=&quot;test&quot;&gt;
&lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<ul><li> (番外編:普通のHTMLでも発生しない。)form01.html</li></ul>
<pre>&lt;html&gt;
&lt;body&gt;
&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt;
&lt;input type=&quot;text&quot; value=&quot;&quot;&gt;
&lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<h4 id="id2b0406">ブラウザで異なる挙動(IE/FireFox)</h4>

<h5 id="id1b8fed">発生するスクリプトの場合(Firefox)</h5>

<p class="paragraph">
「ページの有効期限切れ」画面は主にIE系で取り上げられる現象である。一方のNetscape系(Geckoエンジン系)のブラウザではあまりそう言った話題はあがらない。では、実際どうなるのか？Firefox1.04で前掲のsession01/02.phpにアクセスし、IEの時と同様の手順を踏んでみる。
<br />
</p>

<p class="paragraph">
結論として、「再度POSTして良いですか？」という下図に示すような画面が表示され、OKをクリックすると再度サーバーにリクエストが送られている。(この段階ではあくまでも送られている「らしい」までしか目視確認できないが、後述のFirefoxのLiveHTTPHeadersの解析により実際にリクエストが送られていることを確認できた。)
<br />
</p>

<p class="paragraph">
<a href="./files/画像/PHP/re_post_confirm.jpg" title="画像/PHP/re_post_confirm.jpg" target="_blank"><img src="./files/画像/PHP/re_post_confirm.jpg" alt="画像/PHP/re_post_confirm.jpg" title="画像/PHP/re_post_confirm.jpg"  /></a>
<br />
</p>

<h5 id="idedc0bf">発生しないスクリプトの場合(IE/Firefox)</h5>

<p class="paragraph">
IE/Firefoxとも、発生しないスクリプトの場合特にサーバーにアクセスも発生せず、表示の早さとフォームに入力された値を覚えてくれている辺り(実際、各Submit毎に入力した値を完全に覚えていた)も同様である。どうやらブラウザのキャッシュにアクセスしているらしい。
<br />
</p>

<h4 id="id0b5376">推測：session_cache_limiter()が原因か？</h4>

<p class="paragraph">
発生するスクリプト・しないスクリプトの違いはsession_cache_limiter()の違いである。発生するスクリプトはsession_cache_limiter()を呼んでいないか、&#039;nocache&#039;を渡している。実際にPHPのマニュアルを参照してみる。
<br />
</p>

<p class="paragraph">
<a class="externallink" href="http://jp.php.net/manual/ja/function.session-cache-limiter.php" target="_blank">http://jp.php.net/manual/ja/function.session-cache-limiter.php</a>
<br />
</p>

<p class="paragraph">
これによると、この関数はHTTPヘッダーを操作し、クライアントに対してキャッシュ制御を行う関数らしい。引数はマニュアルを読む限り次の４つ。
<br />
</p>

<dl>
<dt> nocache </dt>
<dd>クライアント（および途中に介在するプロクシ）にキャッシュさせない。</dd>
<dt> public </dt>
<dd>クライアント（および途中に介在するプロクシ）にキャッシュを許す。</dd>
<dt> private </dt>
<dd>クライアントにのみキャッシュを許す。途中に介在するプロクシにはキャッシュを許さない。</dd>
<dt> private_no_expire </dt>
<dd>機能はprivateと同じだが、Mozilla系を混乱させないためExpiresヘッダを送信しない。</dd>
</dl>

<p class="paragraph">
当関数を呼ばない場合、自動的にsession.cache_limiterに指定された値が適用されるらしい。そのデフォルト値は&#039;nocache&#039;であるらしい。従って、前掲のsession01.phpは当関数を呼んでいないため&#039;nocache&#039;が仮定され、結果として動作はsession02.phpと同等のものになっていたことが推測される。
<br />
</p>

<h3 id="idf5b7e8">HTTPヘッダーの比較</h3>

<p class="paragraph">
session_cache_limiter()はHTTPヘッダーを操作する。従って、前掲のスクリプトの動作を解析するにはそのHTTPヘッダーを観察する必要がある。今回はFirefoxの拡張(extension)の一つであるLiveHTTPHeadersを用いて、前掲の三つのスクリプトにアクセスした場合のHTTPヘッダーを観察してみることにした。
<br />
</p>

<p class="paragraph">
session01 - 03.phpにアクセスする。いずれもアクセスの前にCookieとブラウザキャッシュを全クリアする。操作としては以下の手順で統一した。
<br />
</p>
<ol><li> アドレス欄に直接URLを入力し、GETでアクセスする。(GET一回目)</li>
<li> フォームに適当な値を入力し、Submitする。(POST一回目)</li>
<li> フォームに前回とは異なる値を入力し、再度Submitする。(POST二回目)</li>
<li> ブラウザバックする。(IEなら「ページの有効期限切れ」画面が表示されるが、Firefoxの場合は再度POSTされる。)</li></ol>

<p class="paragraph">
このときのLiveHTTPHeadersのヘッダーを以下のファイルに保存した。
<br />
</p>
<ul><li> <a href="./files/添付ファイル/PHP/session01.log" >添付ファイル/PHP/session01.log</a> - session01.phpのログ</li>
<li> <a href="./files/添付ファイル/PHP/session02.log" >添付ファイル/PHP/session02.log</a> - session02.phpのログ</li>
<li> <a href="./files/添付ファイル/PHP/session03.log" >添付ファイル/PHP/session03.log</a> - session03.phpのログ</li></ul>

<p class="paragraph">
以下にログファイルを解析した結果を、要点を絞ってまとめる。
<br />
</p>

<ul><li> session01.phpのサーバーからの応答ヘッダー</li></ul>

<p class="paragraph">
サーバーからの応答の内、Expires, Cache-Control, Pragma 辺りが怪しい。
<br />
</p>
<pre>HTTP/1.x 200 OK
Date: Sat, 09 Jul 2005 15:03:38 GMT
Server: Apache/2.0.50 (Win32) PHP/4.3.8
X-Powered-By: PHP/4.3.8
Set-Cookie: CacheExpireExperiment01=225b4c965b29028b78bec94bfebce4cb; path=/
Expires: Thu, 19 Nov 1981 08:52:00 GMT
Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0
Pragma: no-cache
Keep-Alive: timeout=15, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html; charset=EUC-JP
</pre>

<ul><li> session02.phpのサーバーからの応答ヘッダー</li></ul>

<pre>HTTP/1.x 200 OK
Date: Sat, 09 Jul 2005 15:04:21 GMT
Server: Apache/2.0.50 (Win32) PHP/4.3.8
X-Powered-By: PHP/4.3.8
Set-Cookie: CacheExpireExperiment02=56e20d4184fbe8690b9e1beb00d314e1; path=/
Expires: Thu, 19 Nov 1981 08:52:00 GMT
Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0
Pragma: no-cache
Keep-Alive: timeout=15, max=99
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html; charset=EUC-JP
</pre>

<ul><li> session03.phpのサーバーからの応答ヘッダー</li></ul>
<pre>HTTP/1.x 200 OK
Date: Sat, 09 Jul 2005 15:04:51 GMT
Server: Apache/2.0.50 (Win32) PHP/4.3.8
X-Powered-By: PHP/4.3.8
Set-Cookie: CacheExpireExperiment03=ef639f33f6259fea6437c5aa3255a429; path=/
Expires: Thu, 19 Nov 1981 08:52:00 GMT
Cache-Control: private, max-age=10800, pre-check=10800
Last-Modified: Sat, 09 Jul 2005 15:00:52 GMT
Keep-Alive: timeout=15, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html; charset=EUC-JP
</pre>

<h4 id="idfeda70">比較・解析・推測</h4>

<p class="paragraph">
まず、session01と02において、Expires/Cache-Control/Pragmaヘッダーフィールドが完全に一致している。これは前述のsession_cache_limiter()とsession.cache_limiterのデフォルト設定との関連より推測した、session01と02の動作が同じであることを証明している。
<br />
</p>

<p class="paragraph">
続いてsession03.phpとの比較だが、session03.phpで大きく異なるのが次の部分である。
<br />
</p>
<pre>Expires: Thu, 19 Nov 1981 08:52:00 GMT
Cache-Control: private, max-age=10800, pre-check=10800
Last-Modified: Sat, 09 Jul 2005 15:00:52 GMT
</pre>
<p class="paragraph">
Cache-Controlが no-cache ではなくなり、privateになっている。また幾つかのパラメータが追加されている。さらにLast-Modifiedフィールドが追加されている。ちなみに、session_cache_limiter()にprivate_no_expireを指定するとExpiresフィールドが無くなる。この点についてはPHPのマニュアルと一致している。
<br />
</p>

<p class="paragraph">
以上より、session_cache_limiter()に渡す値は Cache-Control, Pragma のヘッダーフィールドに影響を与える事が確認できた。ではこの二つ（およびExpires, Last-Modified）ヘッダーフィールドが、ブラウザにどういった影響を与えるのかをHTTPのRFC2616を元に調べてみる。
<br />
</p>

<h3 id="id90d815">HTTPのキャッシュ制御について</h3>

<p class="paragraph">
HTTPについての文献は次のURLに日本語で非常に詳しくまとめられている。以下、このHPを元に今回の調査対象となるヘッダーフィールドおよびブラウザのキャッシュ制御について著者の視点からまとめてみる。
<br />
</p>

<ul><li> <a class="externallink" href="http://www.studyinghttp.net/" target="_blank">http://www.studyinghttp.net/</a><ul><li> <a class="externallink" href="http://www.studyinghttp.net/intro" target="_blank">http://www.studyinghttp.net/intro</a> : HTTPの概要と歴史</li>
<li> <a class="externallink" href="http://www.studyinghttp.net/header" target="_blank">http://www.studyinghttp.net/header</a> : HTTP/1.1ヘッダーフィールドの解説</li>
<li> <a class="externallink" href="http://www.studyinghttp.net/caching" target="_blank">http://www.studyinghttp.net/caching</a> : HTTP/1.1, 1.0のキャッシュ機能詳細（詳しすぎて理解不能...）</li>
<li> <a class="externallink" href="http://www.studyinghttp.net/cgi-bin/rfc.cgi?2616" target="_blank">http://www.studyinghttp.net/cgi-bin/rfc.cgi?2616</a> : RFC2616(HTTP/1.1)の日本語訳</li></ul></li></ul>

<p class="paragraph">
<strong> 注意 </strong>：日本語訳の使用上の注意点については必ず <a class="externallink" href="http://www.studyinghttp.net/translations#Notice" target="_blank">http://www.studyinghttp.net/translations#Notice</a> を参照して下さい。あくまでも英語文書が正式版であり、日本語訳した場合の誤訳や誤解については無保証だそうです。
<br />
</p>

<h4 id="id608341">キャッシュされる場所とキャッシュの許可の考え方</h4>

<p class="paragraph">
Webページがキャッシュされる場所はクライアントという視点では二カ所ある。
<br />
</p>
<ul><li> クライアントPCのWebブラウザ（つまりクライアントPC）</li>
<li> プロクシサーバー</li></ul>

<p class="paragraph">
プロクシサーバーは一般に共用サーバーである。この事により、「個人のプライバシーに関わるページのキャッシュの是非」を操作できる必要性が生じる。これにより、キャッシュには主に以下の３段階の&quot;レベル&quot;が導入されるべきである。
<br />
</p>

<ol><li> クライアントPCおよびプロクシサーバーにキャッシュされても大丈夫な&quot;公開(public)&quot;レベル</li>
<li> クライアントPCにのみキャッシュされ、プロクシサーバーにはキャッシュされるべきではない、&quot;個人(private)&quot;レベル</li>
<li> クライアントPC/プロクシサーバーの両方にキャッシュを許さない、&quot;キャッシュ不可(no-cache)&quot;レベル</li></ol>

<p class="paragraph">
さらに重要な点として、「キャッシュが無効化されるのをいつ、どのようにしてブラウザは認識するのか」という問題も出てくる。すなわち、
<br />
</p>
<ol><li> キャッシュレベル</li>
<li> キャッシュ無効化検出</li></ol>

<p class="paragraph">
の二点を制御できて初めてキャッシュを安全に確実に利用できるようになる。
<br />
</p>

<h4 id="id804a6d">HTTP/1.0におけるキャッシュ制御ヘッダーフィールド(Expires, Pragma)</h4>

<p class="paragraph">
現在主なサーバー・ブラウザ（クライアントプログラム）が対応しているHTTPのバージョンは 1.1/1.0 の二種類。このうち、HTTP/1.0時代のキャッシュ制御ヘッダーフィールドについてまとめる。
<br />
</p>

<dl>
<dt> Expires </dt>
<dd>そのWebページ(リソース)がいつ無効になるのかを示す。形式は RFC 1123( <a class="externallink" href="http://www.studyinghttp.net/header#HTTP-Date" target="_blank">http://www.studyinghttp.net/header#HTTP-Date</a> 参照) にて定義<span class="hidden">(</span><a class="footnote" href="#footnote_29_1" id="footnote_29_1_r"  title="PHPのsession.cのソース内では gmdate(&quot;D, d M Y H:i:s&quot;) として生成されている。">*1</a><span class="hidden">)</span>されている。</dd>
<dt> Pragma </dt>
<dd>本来は汎用に使えるOptionalなヘッダーフィールドを目的としていたが、実際にはキャッシュを許可しない<span class="hidden">(</span><a class="footnote" href="#footnote_29_2" id="footnote_29_2_r"  title="正確には、たとえクライアントプログラムがキャッシュを保持していたとしても、それを無視して再度リクエストを送出することをRequestする。">*2</a><span class="hidden">)</span>&quot;no-cache&quot;のみが定義されている。</dd>
</dl>

<p class="paragraph">
Expires, Pragma ともにHTTP/1.0時代のフィールドだが、下位互換性のため使用している。HTTP/1.1に対応したプログラムの場合はCache-Controlヘッダーフィールドがこれらより優先して使用される。
<br />
</p>

<h4 id="id7b1521">HTTP/1.1におけるキャッシュ制御ヘッダーフィールド(Cache-Control, Last-Modified)</h4>

<p class="paragraph">
近年の主要なサーバー・ブラウザが対応しているHTTPバージョン1.1では、Cache-Controlがキャッシュ制御用のヘッダーフィールドとして利用されている。
<br />
</p>

<dl>
<dt> Cache-Control </dt>
<dd>次のURLを参照のこと。 <a class="externallink" href="http://www.studyinghttp.net/cgi-bin/rfc.cgi?2616#Sec14.9" target="_blank">http://www.studyinghttp.net/cgi-bin/rfc.cgi?2616#Sec14.9</a></dd>
<dt> Last-Modified </dt>
<dd>一般的にメッセージの最終更新日を表す。ファイルアクセスであればそのサーバーのファイルシステムにおける最終更新日を返すべきであるし、CGIなどによるなにがしかのメッセージであれば、そのメッセージが生成された（すなわちそのCGIが起動・生成した）日付を返すべきである。</dd>
</dl>

<p class="paragraph">
Last-Modifiedヘッダーは、Cache-Controlでno-cache以外が指定されてキャッシュが利用されるシーンにおいて、有効期限の判別材料として使われるらしい。。RFCではキャッシュの有効性チェック関連で大まかな規定はされているようだが、細かい部分は個々のプログラムに依ってしまうようだ。（ <a class="externallink" href="http://www.studyinghttp.net/caching" target="_blank">http://www.studyinghttp.net/caching</a> ）
<br />
</p>

<h4 id="id266bdd">ヘッダーフィールドと「ページの有効期限切れ」画面の関連についての第一のまとめ</h4>

<p class="paragraph">
以上の調査より、以下の結論を導き出せる。
<br />
</p>

<p class="paragraph">
「ページの有効期限切れ」画面が・・・
<br />
</p>
<ol><li> 表示される場合とは、すなわちHTTPヘッダーのキャッシュ制御フィールドにおいてキャッシュ不可を指示された場合である。</li>
<li> 表示されない場合とは、すなわちHTTPヘッダーのキャッシュ制御フィールドにおいてキャッシュ可能である事を指示された場合である。</li></ol>

<p class="paragraph">
つまるところ件の画面はIEのバグでも何でもなく、RFCに従った正常な動作であることが導き出せた。Firefoxの場合も、キャッシュがないため再度リクエストを送る動作なのでRFCから逸脱していない。ではいったいなぜ、標準に従っている筈のこの動作について多くのWebプログラマーが頭を悩ませるのか？また、巷間にあふれる処方箋はどこまでが正しいのか？
<br />
</p>

<p class="paragraph">
以下では、この二つの疑問について「そもそも論」と「PHPのソースコード」の二つの側面から追求し、もっとも効果的かつ抜本的な対策案「チケットの導入」を考える。
<br />
</p>

<h3 id="id68a9d7">そもそもなぜ「ページの有効期限切れ」対策に頭を悩ませるのか？</h3>

<p class="paragraph">
まずこの点について考えなければならない。なぜなら&quot;「ページの有効期限切れ」画面を表示させたくない&quot;という要求自体が無くなれば、そもそもこの対策に頭を悩ませる必要はなくなる。
<br />
</p>

<ul><li> なぜ件の画面が表示されると都合が悪いのか？<ul><li> 格好と見栄えが悪い。</li>
<li> 意味不明の画面。何か異状があったのかと戸惑う。</li></ul></li>
<li> では、なぜ件の画面が表示されるのか？<ul><li> ユーザーがブラウザバックを実行する。</li>
<li> なぜブラウザバックを実行するのか？<ul><li> (確認画面などで確認した結果)フォームに入力した値が間違っていたので、&#039;&#039;前の画面に戻って&#039;&#039;修正したい。</li>
<li> フォームに入力したが、続く手続きをキャンセルしたい。</li></ul></li></ul></li>
<li> ではユーザーはブラウザバックをしたとき何が表示されていることを望むのか？<ul><li> 直前の入力画面</li>
<li> 当然、自分が入力した値が表示されているべき。</li></ul></li></ul>

<p class="paragraph">
ユーザーの立場に立てばいずれも至極まっとうな要求である。しかしWebプログラマはこれらの要求を聞くと眉をひそめる。なぜか？
<br />
</p>
<ul><li> ブラウザバックされた後に再度POSTされるとまずい。</li>
<li> なぜまずいのか？<ul><li> 登録した後にブラウザバックされてPOSTされると、同じ情報がPOSTされてエラーとなる。→<strong>プログラマーとして気持ち悪い。</strong></li></ul></li></ul>

<p class="paragraph">
つまり以下の二点が頭を悩ませる最大の要因である。
<br />
</p>
<ul><li> 本来は再度POSTされると面倒なので、キャッシュを不可にしてブラウザバックを無効化したい。</li>
<li> ユーザーとしては直感的に「データの修正」のためにブラウザバックを実行してしまい、またブラウザバックができて当然だと考えている。</li></ul>

<p class="paragraph">
これが為に本来であれば意味的に至極まっとうな、IEの「ページの有効期限切れ」画面やFirefoxの「再POSTの確認」ダイアログを、ユーザーを戸惑わせたくないが為にどうにかして無効化する必要が出てくるのであろう。元々入力値や個人情報の安全性を補助するためのキャッシュ無効化機能が、そのクライアントプログラム側のインターフェイス故に、結果としてユーザーを戸惑わせる機能として否定されようとしているのだ。Webプログラマは、結果としてキャッシュ機能を有効化することにより元の入力フォームに&quot;戻らせ&quot;、代わりに再POST防止のため頭をひねることとなる。
<br />
</p>

<h3 id="idc3154d">PHPのソースコードの探索</h3>

<p class="paragraph">
ではいったい、キャッシュ機能を正しく有効にするにはどうすればよいのか？PHPに限定して、その処方箋をざっとGoogleで検索してみた結果を以下に列挙する。
<br />
</p>
<ul><li> <a class="externallink" href="http://www.workspot.jp/tech/php_tips.html" target="_blank">http://www.workspot.jp/tech/php_tips.html</a></li>
<li> <a class="externallink" href="http://www.stackasterisk.jp/tech/php/searchAction.do?cid=15#58" target="_blank">http://www.stackasterisk.jp/tech/php/searchAction.do?cid=15#58</a></li>
<li> <a class="externallink" href="http://ns1.php.gr.jp/pipermail/php-users/2001-October/003062.html" target="_blank">http://ns1.php.gr.jp/pipermail/php-users/2001-October/003062.html</a></li>
<li> <a class="externallink" href="http://ns1.php.gr.jp/pipermail/php-users/2004-October/024018.html" target="_blank">http://ns1.php.gr.jp/pipermail/php-users/2004-October/024018.html</a></li>
<li> <a class="externallink" href="http://ns1.php.gr.jp/pipermail/php-users/2004-October/024022.html" target="_blank">http://ns1.php.gr.jp/pipermail/php-users/2004-October/024022.html</a></li>
<li> <a class="externallink" href="http://ns1.php.gr.jp/pipermail/php-users/2004-October/024024.html" target="_blank">http://ns1.php.gr.jp/pipermail/php-users/2004-October/024024.html</a></li>
<li> <a class="externallink" href="http://ns1.php.gr.jp/pipermail/php-users/2005-January/024581.html" target="_blank">http://ns1.php.gr.jp/pipermail/php-users/2005-January/024581.html</a></li></ul>

<p class="paragraph">
どうやらsession_cache_limiter()に結局は落ち着くようである。関連するPHPマニュアルを以下に列挙する。
<br />
</p>
<ul><li> <a class="externallink" href="http://jp.php.net/manual/ja/ref.session.php" target="_blank">http://jp.php.net/manual/ja/ref.session.php</a> : php.ini設定関連</li>
<li> <a class="externallink" href="http://jp.php.net/manual/ja/function.session-cache-expire.php" target="_blank">http://jp.php.net/manual/ja/function.session-cache-expire.php</a> : session_cache_expire()</li>
<li> <a class="externallink" href="http://jp.php.net/manual/ja/function.session-cache-limiter.php" target="_blank">http://jp.php.net/manual/ja/function.session-cache-limiter.php</a> : session_cache_limiter()</li></ul>

<p class="paragraph">
PHPソースコードの探索に入る。ソースコードのバージョンは4.3.11, ターゲットは ext/session/session.c のみである。
<br />
</p>

<h4 id="id3fe3c2">PHP_FUNCTION(session_cache_limiter), PHP_FUNCTION(session_cache_expire)</h4>
<p class="paragraph">
まずPHP関数を定義している&quot;PHP_FUNCTION&quot;マクロを使用した関数の中からsession_cache_limiter, session_cache_expireを探る。1331行目以降に出てくる。以下、適当に省略して要点のみを抜き出す。
<br />
</p>

<pre>// 現在のcache_limiterを返す。引数が渡されれば、引数でcache_limiterを更新する。
PHP_FUNCTION(session_cache_limiter)
{
    zval **p_cache_limiter;
    char *old;
    zend_get_parameters_ex(ac, &amp;p_cache_limiter);
    old = estrdup(PS(cache_limiter));
    convert_to_string_ex(p_cache_limiter);
    zend_alter_ini_entry(&quot;session.cache_limiter&quot;, sizeof(&quot;session.cache_limiter&quot;), 
       Z_STRVAL_PP(p_cache_limiter), ...);
    RETVAL_STRING(old, 0);
}
// 現在のcache_expireを返す。引数が渡されれば、引数でcache_expireを更新する。
PHP_FUNCTION(session_cache_expire)
{
    zval **p_cache_expire;
    long old;
    old = PS(cache_expire);
    zend_get_parameters_ex(ac, &amp;p_cache_expire);
    convert_to_long_ex(p_cache_expire);
    PS(cache_expire) = Z_LVAL_PP(p_cache_expire);
    RETVAL_LONG(old);
}
</pre>
<p class="paragraph">
どうやらPS(cache_limiter), PS(cache_expire), session.cache_limiter辺りが怪しいようです。ただ、なぜcache_limiterではiniエントリを更新していてexpireの方ではそれをしないかは不明です。
<br />
</p>

<h4 id="id43028b">PS(cache_limiter), PS(cache_expire)</h4>
<p class="paragraph">
147行目でこの二つがiniファイルより初期化されています。
<br />
</p>
<pre>STD_PHP_INI_ENTRY(&quot;session.cache_limiter&quot;, &quot;nocache&quot;, PHP_INI_ALL, OnUpdateString, cache_limiter, ...)
STD_PHP_INI_ENTRY(&quot;session.cache_expire&quot;, &quot;180&quot;, PHP_INI_ALL, OnUpdateInt, cache_expire, ...)
</pre>
<p class="paragraph">
このマクロの詳細は不明ですが、デフォルト値とおぼしき値はマニュアルと一致しています。
<br />
</p>

<p class="paragraph">
PS(cache_limiter)は前述のPHP_FUNCTION(session_cache_limiter)および822行から始まる
<br />
</p>
<pre>static int php_session_cache_limiter(TSRMLS_D)
</pre>
<p class="paragraph">
内でしか使われていません。
<br />
</p>

<p class="paragraph">
PS(cache_expire)は770行目
<br />
</p>
<pre>CACHE_LIMITER_FUNC(public)
</pre>
<p class="paragraph">
および789行目
<br />
</p>
<pre>CACHE_LIMITER_FUNC(private_no_expire)
</pre>
<p class="paragraph">
の二カ所で使われています。
<br />
</p>

<p class="paragraph">
ざっとみてだいぶ本命に近づいてきたようです。cache_expireは秒数として使われているようです。cache_limiterを探ると本命に近づけそうです。
<br />
</p>

<h4 id="id555893">php_session_cache_limiter()</h4>
<p class="paragraph">
PS(cache_limiter)が使われているphp_session_cache_limiter()について探索してみます。
<br />
</p>
<pre>// 238行目：session_cache_limiter()の各引数と対応する関数のマッピング用構造体の定義
typedef struct {
    char *name;
    void (*func)(TSRMLS_D);
} php_session_cache_limiter_t;

// 814行目：実際の構造体の実体
static php_session_cache_limiter_t php_session_cache_limiters[] = {
    CACHE_LIMITER_ENTRY(public)
    CACHE_LIMITER_ENTRY(private)
    CACHE_LIMITER_ENTRY(private_no_expire)
    CACHE_LIMITER_ENTRY(nocache)
   {0}
};

// 822行目：php_session_cache_limiter()の要点のみ抜粋
static int php_session_cache_limiter(TSRMLS_D)
{
    php_session_cache_limiter_t *lim;
    // 構造体の中から、現在のcache_limiterに一致するのを取り出し、対応付けされている関数を実行する。
    for (lim = php_session_cache_limiters; lim-&gt;name; lim++) {
        if (!strcasecmp(lim-&gt;name, PS(cache_limiter))) {
            lim-&gt;func(TSRMLS_C);
            return 0;
        }
    }
    return -1;
}
</pre>

<p class="paragraph">
php_session_cache_limiter()自体はsession_start()内で	php_session_reset_id(TSRMLS_C) の後に呼ばれています(1097行目)。
<br />
</p>

<p class="paragraph">
確信まであと少しです。構造体に使われているマクロで注目してみると、構造体の実体のすぐ上にCACHE_LIMITER_FUNCと言う一連の関数が定義されていました。ヘッダーフィールドらしき文字列も見えます。
<br />
</p>

<h4 id="idd80bad">CACHE_LIMITER_FUNC(public, private_no_expire, private, nocache)</h4>
<p class="paragraph">
この一連の関数こそが、Expires/Pragma/Cache-Control/Last-Modifierをセッション使用時に制御している中枢です。実体は751行目のlast_modifiedから始まり813行目まで続きますが、要はどの関数がどのヘッダーフィールドを送信しているのか分かればよいので、そこだけまとめました。
<br />
</p>

<ul><li> CACHE_LIMITER_FUNC(public)<ul><li> Expires: （PS(cache_expire)などを吟味して送出）</li>
<li> Cache-Control: public, max-age=PS(cache_expire)*60</li>
<li> Last-Modified: （last_modified関数）</li></ul></li>
<li> CACHE_LIMITER_FUNC(private_no_expire)<ul><li> Cache-Control: private, max-age=PS(cache_expire)*60, pre-check=PS(cache_expire)*60</li>
<li> Last-Modified: （last_modified関数）</li></ul></li>
<li> CACHE_LIMITER_FUNC(private)<ul><li> Expires: Thu, 19 Nov 1981 08:52:00 GMT （固定）</li>
<li> Cache-Control: （private_no_cache呼び出し）</li>
<li> Last-Modified: （private_no_cache呼び出し）</li></ul></li>
<li> CACHE_LIMITER_FUNC(nocache) （全て固定）<ul><li> Expires: Thu, 19 Nov 1981 08:52:00 GMT</li>
<li> Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0</li>
<li> Pragma: no-cache</li></ul></li></ul>

<p class="paragraph">
<strong> ようやく追いつめました。 </strong>これらが、session_cache_limiter()により呼び出されるキャッシュ制御ヘッダーフィールドを送出している部分です。これらはphp_session_cache_limiter()内で、現在のcache_limiterから呼び出されます。
<br />
</p>

<h4 id="id72bec9">幾つかの間違いとそれでも動作する理由</h4>

<p class="paragraph">
Webを調べていると、session_cache_limiter()について次の例がそれぞれ別の場所で見つかった。
<br />
</p>
<pre>session_cache_limiter(&#039;none&#039;);
session_cache_limiter(&#039;no-cache&#039;);
session_cache_limiter(&#039;private, must-revalidate&#039;);
</pre>
<p class="paragraph">
これまでの調査によると、これらの引数は明らかに無効である。しかし掲載場所ではいずれも「これで思った通りに件の画面が表示されなくなった。」と報告されていた。
<br />
</p>

<p class="paragraph">
この理由は簡単で、php_session_cache_limiter()では引数（つまり現在のcache_limiter）にヒットしなかった場合はそのままスルーしている。スルーするとどうなるか。単にキャッシュ制御ヘッダーフィールドが送出されなくなるだけである。そうなると、只のHTMLと同様に普通にブラウザにキャッシュされ、結果、「ページの有効期限切れ」画面はブラウザバックでは表示されなくなる。
<br />
</p>

<p class="paragraph">
これが今まで明らかにされていなかった理由としては、session_cache_limiter()に指定した値が有効かどうか判別するためのインターフェイスが無いことが考えられる。それに加え、関数名からCache-Controlヘッダーに指定するものを渡せばよいと誤解を招いた可能性もある。前掲の２・３番目の間違いがそれにあたると思われる。
<br />
</p>

<h3 id="id76fa9f">まとめ - チケットの導入へ</h3>

<p class="paragraph">
以上より、今回の件に関する動作はほぼ押さえられた。結論としては「ページの有効期限切れ」画面を表示させない対策としてはsession_cache_limiter(&#039;private_no_expire&#039;)をコールすることが最大公約数として導き出せる。<span class="hidden">(</span><a class="footnote" href="#footnote_29_3" id="footnote_29_3_r"  title="&#039;public&#039;だとプロクシに残るCache-Controlになるので個人情報保護の観点からN.G.となる。&#039;private&#039;ではMozilla系が混乱するという情報があり、残った&#039;private_no_expire&#039;が公約数として使用できる。無効な文字列を指定してそもそもヘッダーを送出させないのは、全てを分かった上での反則技としてなら有効。">*3</a><span class="hidden">)</span>
<br />
</p>

<p class="paragraph">
しかし、再POSTの危険性に対してはどうすればよいのか？多くが試行錯誤中ではあり、たとえばDBにレコードを挿入・更新する場面ではUNIQUE違反を検出する場合がある。しかし、この場合UNIQUEキーが無く単純にシーケンスと関連づけされたPrimary Keyだけが有効となる場面ではUNIQUEを検出できない。
<br />
</p>

<p class="paragraph">
一つの手法としては、都度ユニークなキー値を生成し、hiddenとしてフォームに埋め込んでおく「チケット」の導入が考えられる。アプリケーションは裏側でチケットを管理し、アクションが発生すればチケットに「使用済み」マークを付ける。もしも使用済みマークのついたチケットがPOSTされてきたら、エラーで弾く。Javaでの開発では導入される場合があるようだが、これが比較的安全であろう。
<br />
</p>

<p class="paragraph">
あるいは、そもそも個人情報をキャッシュさせないためのキャッシュ制御であるのだから、ユーザーに「そういうもの」として受け止めて頂くよう説得し、「ページの有効期限切れ」画面が表示されることに対して理解を求める、という手もある。
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-42.html" title="PHP/xdebugメモ">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-37.html" title="PHP/セッションとクッキーの共存">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-25.html" title="PHP">Up</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-25.html" title="PHP">PHP</a>&nbsp;]</li>
</ul><div class="footnote">
<a id="footnote_29_1" href="#footnote_29_1_r">*1</a>: PHPのsession.cのソース内では gmdate(&quot;D, d M Y H:i:s&quot;) として生成されている。<br />
<a id="footnote_29_2" href="#footnote_29_2_r">*2</a>: 正確には、たとえクライアントプログラムがキャッシュを保持していたとしても、それを無視して再度リクエストを送出することをRequestする。<br />
<a id="footnote_29_3" href="#footnote_29_3_r">*3</a>: &#039;public&#039;だとプロクシに残るCache-Controlになるので個人情報保護の観点からN.G.となる。&#039;private&#039;ではMozilla系が混乱するという情報があり、残った&#039;private_no_expire&#039;が公約数として使用できる。無効な文字列を指定してそもそもヘッダーを送出させないのは、全てを分かった上での反則技としてなら有効。
</div>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/29<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2007 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>