<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>C言語系/「デーモン君のソース探検」読書メモ/A11(Intermission), exit(2) → wait4(2) - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">C言語系/「デーモン君のソース探検」読書メモ/A11(Intermission), exit(2) → wait4(2)</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-11-24 16:26:01 &nbsp; / &nbsp; last updated at: 2010-11-24 16:31:09<br>
カテゴリ: <a href="category-32.html">BSD</a>&nbsp;<a href="category-10.html">C言語</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-850.html" title="C言語系/「デーモン君のソース探検」読書メモ/A10, popen(3)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-533.html" title="C言語系/ポインタ・配列の定義と宣言メモ1">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
お題：sys_wait4を中心に、だらだら、ぐだぐだと関連ソースを眺めてみる
<br />
</p>

<p class="paragraph">
・・・つもりが、気が付いたら&quot;exit(2) → wait4(2)&quot;の流れの舞台裏を調べていた。
<br />
</p>

<p class="paragraph">
※この章は「デーモン君のソース探検」に載っていませんが、msakamoto-sf自身が個人的に興味を持って調べ、&quot;Appendix&quot;として読書メモシリーズに入れてありますのでご注意下さい。
<br />
</p>



<ul><li><a href="#id42e832">Intermission : 一休み</a></li>
<li><a href="#iddf0142">「へ～」その１：セッションリーダーのプロセスが終了するとき、同じ制御端末のプロセス群にSIGHUP送信してる箇所</a></li>
<li><a href="#id26dc47">「へ～」その２：シグナル関連のソースはkern_sig.c</a></li>
<li><a href="#id0b917e">「へ～」その３：NetBSD1.6では、wait/waitpid/wait3全てがwait4で実装されている</a></li>
<li><a href="#id9b3bc3">「へ～」その４：終了プロセスをゾンビにしてる箇所発見(kern_exit.c)</a></li>
<li><a href="#id490914">「へ～」その５：親プロセスが終了するとき、子プロセスの親を&quot;init&quot;に変更している箇所発見</a></li>
<li><a href="#id82f963">「へ～」その６：親プロセスが&quot;SA_NOCLDWAIT&quot;をsigaction()に使っていたら、initに親を変更する箇所発見</a></li>
<li><a href="#id08914f">「へ～」その７：wait4()中でゾンビプロセスを回収している箇所を発見</a></li>
<li><a href="#id78a63e">まとめ：exit() → sys_wait4()での回収まで</a><ul><li><a href="#ideeacde">１．exit()システムコール → exit1()</a></li>
<li><a href="#id57c145">２．exit1() → SDEAD, 終了コードの設定, zombprocへ追加, cpu_exit()</a></li>
<li><a href="#id3fbfde">３．cpu_exit() → (scheduling) → exit2() → (kernel thread) → reaper()</a><ul><li><a href="#id63b46a">親プロセスへのSIGCHLD送信箇所を特定</a></li></ul></li>
<li><a href="#id2f2116">４．親プロセスのSIGCHLD受信 → シグナルハンドラ</a></li>
<li><a href="#id0cff9f">５．シグナルハンドラ → sys_wait4() → ゾンビ回収</a></li></ul></li></ul>
<hr />
<h3 id="id42e832">Intermission : 一休み</h3>

<p class="paragraph">
今回は休憩回です。ちょっと振り返ってみます。
<br />
</p>

<p class="paragraph">
2010年の1-2月は、「デーモン君のソース探検」を読んでました。
<br />
</p>
<pre>2010-01 ～ 2010-02 : 01-06, A01-04
</pre>

<p class="paragraph">
2010年の10月に &quot;Understanding Linux/UNIX Programming&quot; を読み終えました。
<br />
</p>
<ul><li> <a href="./view-818.html" >日記/2010/10/28/「Unix/Linuxプログラミング理論と実践」読み終わった</a></li></ul>

<p class="paragraph">
2010年の11月に &quot;Advanced UNIX Programming&quot; を読み終えました。
<br />
</p>
<ul><li> <a href="./view-842.html" >読書メモ/&quot;Advanced UNIX Programming&quot;</a></li></ul>

<p class="paragraph">
&quot;Understanding Linux/UNIX Programming&quot;, &quot;Advanced UNIX Programming&quot; を読んでいて内部実装が気になって調べてみたのが、
<br />
</p>
<pre>A05, time(1) - A10, popen(3)
</pre>
<p class="paragraph">
になります。
<br />
</p>

<p class="paragraph">
他に気になってる部分、もうちょっと深く調べたり、実験プログラムを組んでみたい部分もありますが、その殆どが &quot;Advanced Programming in the UNIX Environment&quot;(APUE) の方に載っていました。自分で1から調べる必要は無いでしょう。
<br />
</p>

<p class="paragraph">
つまり、ひとまず、「ひどく気になる部分」はこれにてお仕舞い、ということになります。
<br />
</p>

<p class="paragraph">
ということで繰り返しになりますが今回は休憩回です。たまたまA05でsys_write4のシステムコールを見てまして、exit(2)してから親プロセスにSIGCHLDが伝播し、wait4(2)を呼ぶまでの流れをだらだら、ぐだぐだ、べろんべろんと気楽に、ぶらぶらふらついてみることにします。
<br />
</p>

<p class="paragraph">
かなり当て推量とか知ったかぶりの半可通知識で読み飛ばしていくので、情報の正確性には期待しないでください。
<br />
じゃぁなんのために休憩回を用意したの？っていうと、もともとはwait()をもうちょっと深く調べてみる・・・予定だった、かもしれないんです。ただ、メモに「wait(), waitpid()」しか書き残してなかったので、wait()とかのどの辺が気になったのか、覚えてないんですよ。で、どうしようかな～とsys_write4のソースを眺めてるうちに、「あ、これってここでやってるんだ～」っていうのがぽろぽろ見つかってきちゃって。exit(2)とかwait4(2)周りのコードを読んでて「へ～」ボタンを押したくなるポイントが多かったので、メモしておきたかった次第です。
<br />
</p>

<p class="paragraph">
システムコールの内部、カーネルソースまで潜れるようになると、同じ風景でも見え方が違ってくるようです。
<br />
その楽しさの片鱗でもお伝えできればと思います。
<br />
</p>

<h3 id="iddf0142">「へ～」その１：セッションリーダーのプロセスが終了するとき、同じ制御端末のプロセス群にSIGHUP送信してる箇所</h3>

<p class="paragraph">
src/sys/kern/kern_exit.c をだらだら眺めてると、sys_exit()からexit1()というのをcallしていて、その中でセッションリーダーだった場合に、SIGHUPを送ってるところを見つけました。
<br />
あれってここで処理してたんだ・・・。
<br />
</p>

<pre class="plugin_pre">
/*
 * exit --
 *      Death of process.
 */
int
sys_exit(struct proc *p, void *v, register_t *retval)
{
    struct sys_exit_args /* {
        syscallarg(int) rval;
    } */ *uap = v;

    exit1(p, W_EXITCODE(SCARG(uap, rval), 0));
    /* NOTREACHED */
    return (0);
}

/*
 * Exit: deallocate address space and other resources, change proc state
 * to zombie, and unlink proc from allproc and parent&#039;s lists.  Save exit
 * status and rusage for wait().  Check for child processes and orphan them.
 */
void
exit1(struct proc *p, int rv)
{
/* (省略) */
if (SESS_LEADER(p)) {
    struct session *sp = p-&gt;p_session;

    if (sp-&gt;s_ttyvp) {
        /*
         * Controlling process.
         * Signal foreground pgrp,
         * drain controlling terminal
         * and revoke access to controlling terminal.
         */
        if (sp-&gt;s_ttyp-&gt;t_session == sp) {
            if (sp-&gt;s_ttyp-&gt;t_pgrp)
                pgsignal(sp-&gt;s_ttyp-&gt;t_pgrp, SIGHUP, 1);
            (void) ttywait(sp-&gt;s_ttyp);
            /*
             * The tty could have been revoked
             * if we blocked.
             */
            if (sp-&gt;s_ttyvp)
                VOP_REVOKE(sp-&gt;s_ttyvp, REVOKEALL);
        }
        if (sp-&gt;s_ttyvp)
            vrele(sp-&gt;s_ttyvp);
        sp-&gt;s_ttyvp = NULL;
        /*
         * s_ttyp is not zero&#039;d; we use this to indicate
         * that the session once had a controlling terminal.
         * (for logging and informational purposes)
         */
    }
    sp-&gt;s_leader = NULL;
}
</pre>

<h3 id="id26dc47">「へ～」その２：シグナル関連のソースはkern_sig.c</h3>

<p class="paragraph">
上のexit1()を読んでいて、
<br />
</p>
<pre>pgsignal(sp-&gt;...);
</pre>
<p class="paragraph">
というのが出てきました。
<br />
grepしてみると、シグナル関連のソースはkern_sig.cにまとめられているようです。
<br />
</p>

<p class="paragraph">
src/sys/kern/kern_sig.c:
<br />
</p>
<pre class="plugin_pre">
...
/*
 * Send a signal to a process group. If checktty is 1,
 * limit to members which have a controlling terminal.
 */
void
pgsignal(struct pgrp *pgrp, int signum, int checkctty)
{
    struct proc *p;

    if (pgrp)
        for (p = pgrp-&gt;pg_members.lh_first; p != 0;
          p = p-&gt;p_pglist.le_next)
            if (checkctty == 0 || p-&gt;p_flag &amp; P_CONTROLT)
                psignal(p, signum);
}
...
/*
 * Send the signal to the process.  If the signal has an action, the action
 * is usually performed by the target process rather than the caller; we add
 * the signal to the set of pending signals for the process.
 *
 * Exceptions:
 *   o When a stop signal is sent to a sleeping process that takes the
 *   default action, the process is stopped without awakening it.
 *   o SIGCONT restarts stopped processes (or puts them back to sleep)
 *   regardless of the signal action (eg, blocked or ignored).
 *
 * Other ignored signals are discarded immediately.
 *
 * XXXSMP: Invoked as psignal() or sched_psignal().
 */
void
psignal1(struct proc *p, int signum,
    int dolock)       /* XXXSMP: works, but icky */
{
...
</pre>

<p class="paragraph">
psignal()とpsignal1()は sys/signalvar.hで見つかります。
<br />
</p>
<pre>$ grep psignal *
...
signalvar.h:void        psignal1 __P((struct proc *p, int sig, int dolock));
signalvar.h:#define     psignal(p, sig)         psignal1((p), (sig), 1)
...
</pre>

<h3 id="id0b917e">「へ～」その３：NetBSD1.6では、wait/waitpid/wait3全てがwait4で実装されている</h3>

<p class="paragraph">
なので、waitを調べるにはwait4のシステムコールに辿り着いてしまうんですね。
<br />
</p>
<pre class="plugin_pre">
$ locate wait
/usr/include/sys/wait.h
...
/usr/src/lib/libc/gen/wait.c
/usr/src/lib/libc/gen/wait3.c
/usr/src/lib/libc/gen/waitpid.c
...

$ wc -l /usr/src/lib/libc/gen/wait.c
      61 /usr/src/lib/libc/gen/wait.c
$ wc -l /usr/src/lib/libc/gen/wait3.c
      62 /usr/src/lib/libc/gen/wait3.c
$ wc -l /usr/src/lib/libc/gen/waitpid.c
      66 /usr/src/lib/libc/gen/waitpid.c
</pre>

<p class="paragraph">
man 2 wait:
<br />
</p>
<pre class="plugin_pre">
WAIT(2)                   NetBSD Programmer&#039;s Manual                   WAIT(2)

NAME
  wait, waitpid, wait4, wait3 - wait for process termination

LIBRARY
  Standard C Library (libc, -lc)

SYNOPSIS
  #include &lt;sys/wait.h&gt;

  pid_t wait(int *status);
  pid_t waitpid(pid_t wpid, int *status, int options);

  #include &lt;sys/resource.h&gt;
  pid_t wait3(int *status, int options, struct rusage *rusage);
  pid_t wait4(pid_t wpid, int *status, int options, struct rusage *rusage);
</pre>

<p class="paragraph">
/usr/src/lib/libc/gen/wait.c:
<br />
</p>
<pre class="plugin_pre">
pid_t
wait(istat)
        int *istat;
{
        return (wait4(WAIT_ANY, istat, 0, (struct rusage *)0));
}
</pre>

<p class="paragraph">
/usr/src/lib/libc/gen/waitpid.c:
<br />
</p>
<pre class="plugin_pre">
pid_t
#if __STDC__
waitpid(pid_t pid, int *istat, int options)
#else
waitpid(pid, istat, options)
        pid_t pid;
        int *istat;
        int options;
#endif
{
        return (wait4(pid, istat, options, (struct rusage *)0));
}
</pre>

<p class="paragraph">
/usr/src/lib/libc/gen/wait3.c:
<br />
</p>
<pre class="plugin_pre">
pid_t
wait3(istat, options, rup)
        int *istat;
        int options;
        struct rusage *rup;
{
        return (wait4(WAIT_ANY, istat, options, rup));
}
</pre>

<p class="paragraph">
全部wait4()に委譲されてます。
<br />
</p>

<h3 id="id9b3bc3">「へ～」その４：終了プロセスをゾンビにしてる箇所発見(kern_exit.c)</h3>

<p class="paragraph">
kern_exit.cをだらだら眺めてると、カーネルスレッドから呼ばれる&quot;reaper&quot;という関数が見つかりました。
<br />
&quot;deadproc&quot;というリストをfor()で走査してるようです。見ていくと、&quot;SZOMB&quot;をセットしている箇所が見つかりました。src/sys/kern/中のソースコードでも、SZOMBを代入しているのはここだけのようです。
<br />
コメントからも、どうやらここが、終了後まだ親プロセスでwait()されていないプロセスに&quot;ゾンビマーク&quot;をつけている箇所と推測できます。
<br />
</p>
<pre class="plugin_pre">
/*
 * Process reaper.  This is run by a kernel thread to free the resources
 * of a dead process.  Once the resources are free, the process becomes
 * a zombie, and the parent is allowed to read the undead&#039;s status.
 */
void
reaper(void *arg)
{
    struct proc *p;

    KERNEL_PROC_UNLOCK(curproc);

    for (;;) {
        simple_lock(&amp;deadproc_slock);
        p = LIST_FIRST(&amp;deadproc);

/* (省略) */

        /* Process is now a true zombie. */
        p-&gt;p_stat = SZOMB;

        /* Wake up the parent so it can get exit status. */
        if ((p-&gt;p_flag &amp; P_FSTRACE) == 0 &amp;&amp; p-&gt;p_exitsig != 0)
            psignal(p-&gt;p_pptr, P_EXITSIG(p));
        KERNEL_PROC_UNLOCK(curproc);
        wakeup((caddr_t)p-&gt;p_pptr);
    }
}
</pre>

<h3 id="id490914">「へ～」その５：親プロセスが終了するとき、子プロセスの親を&quot;init&quot;に変更している箇所発見</h3>

<p class="paragraph">
これもkern_exit.cのexit1()中で見つけたコードです。コメントもそのものズバリです。
<br />
</p>
<pre class="plugin_pre">
/*
 * Give orphaned children to init(8).
 */
q = p-&gt;p_children.lh_first;
if (q)      /* only need this if any child is S_ZOMB */
    wakeup((caddr_t)initproc);
for (; q != 0; q = nq) {
    nq = q-&gt;p_sibling.le_next;

    /*
     * Traced processes are killed since their existence
     * means someone is screwing up. Since we reset the
     * trace flags, the logic in sys_wait4() would not be
     * triggered to reparent the process to its
     * original parent, so we must do this here.
     */
    if (q-&gt;p_flag &amp; P_TRACED) {
        if (q-&gt;p_opptr != q-&gt;p_pptr) {
            struct proc *t = q-&gt;p_opptr;
            proc_reparent(q, t ? t : initproc);
            q-&gt;p_opptr = NULL;
        } else
            proc_reparent(q, initproc);
        q-&gt;p_flag &amp;= ~(P_TRACED|P_WAITED|P_FSTRACE);
        psignal(q, SIGKILL);
    } else {
        proc_reparent(q, initproc);
    }
}
</pre>
<p class="paragraph">
ここで処理してたんですね・・・。
<br />
</p>

<p class="paragraph">
proc_reparent()も、kern_exit.cの最後に定義されています。
<br />
</p>
<pre class="plugin_pre">
/*
 * make process &#039;parent&#039; the new parent of process &#039;child&#039;.
 */
void
proc_reparent(struct proc *child, struct proc *parent)
{
    if (child-&gt;p_pptr == parent)
        return;

    if (parent == initproc)
        child-&gt;p_exitsig = SIGCHLD;

    LIST_REMOVE(child, p_sibling);
    LIST_INSERT_HEAD(&amp;parent-&gt;p_children, child, p_sibling);
    child-&gt;p_pptr = parent;
}
</pre>

<h3 id="id82f963">「へ～」その６：親プロセスが&quot;SA_NOCLDWAIT&quot;をsigaction()に使っていたら、initに親を変更する箇所発見</h3>

<p class="paragraph">
kern_exit.cの終わりの方で見つかりました。プロセスが終了するとき、親プロセスにP_NOCLDWAITフラグが立っていれば、親プロセスをinitに変更しています。これにより、ゾンビプロセスの回収などはinit側が受け持つことになります。
<br />
</p>
<pre class="plugin_pre">
/*
 * Notify parent that we&#039;re gone.  If parent has the P_NOCLDWAIT
 * flag set, notify init instead (and hope it will handle
 * this situation).
 */
if (p-&gt;p_pptr-&gt;p_flag &amp; P_NOCLDWAIT) {
    struct proc *pp = p-&gt;p_pptr;
    proc_reparent(p, initproc);
    /*
     * If this was the last child of our parent, notify
     * parent, so in case he was wait(2)ing, he will
     * continue.
     */
    if (pp-&gt;p_children.lh_first == NULL)
            wakeup((caddr_t)pp);
}
</pre>
<p class="paragraph">
ここで処理してたんですね・・・。
<br />
</p>

<h3 id="id08914f">「へ～」その７：wait4()中でゾンビプロセスを回収している箇所を発見</h3>

<p class="paragraph">
sys_wait4()中で見つけました。
<br />
</p>
<pre class="plugin_pre">
int
sys_wait4(struct proc *q, void *v, register_t *retval)
{

/* (省略) */

 loop:
    nfound = 0;
    for (p = q-&gt;p_children.lh_first; p != 0; p = p-&gt;p_sibling.le_next) {

/* (省略) */

        if (p-&gt;p_stat == SZOMB) {

/* (省略) */

            /*
             * Finally finished with old proc entry.
             * Unlink it from its process group and free it.
             */
            leavepgrp(p);

            s = proclist_lock_write();
            LIST_REMOVE(p, p_list); /* off zombproc */
            proclist_unlock_write(s);

            LIST_REMOVE(p, p_sibling);
</pre>

<h3 id="id78a63e">まとめ：exit() → sys_wait4()での回収まで</h3>

<p class="paragraph">
あっちこっちつまみ食いしてきましたが、そろそろ絵が描けそうなので、exit()からの流れをまとめてみます。簡単にするため、親プロセスはNOCLDWAITを使っておらず、礼儀正しくSIGCHLDでwait4()を呼ぶパターンで見ていきます。
<br />
</p>

<h4 id="ideeacde">１．exit()システムコール → exit1()</h4>

<pre class="plugin_pre">
int sys_exit(struct proc *p, void *v, register_t *retval) {
    ...
    exit1(p, W_EXITCODE(SCARG(uap, rval), 0));
</pre>

<h4 id="id57c145">２．exit1() → SDEAD, 終了コードの設定, zombprocへ追加, cpu_exit()</h4>

<pre class="plugin_pre">
void exit1(struct proc *p, int rv) {
    ...
    p-&gt;p_stat = SDEAD;
    ...
    LIST_REMOVE(p, p_hash);
    LIST_REMOVE(p, p_list);
    LIST_INSERT_HEAD(&amp;zombproc, p, p_list);
    ...
    p-&gt;p_xstat = rv;
    ...
    /*
     * Finally, call machine-dependent code to switch to a new
     * context (possibly the idle context).  Once we are no longer
     * using the dead process&#039;s vmspace and stack, exit2() will be
     * called to schedule those resources to be released by the
     * reaper thread.
     *
     * Note that cpu_exit() will end with a call equivalent to
     * cpu_switch(), finishing our execution (pun intended).
     */
    cpu_exit(p);
}
</pre>

<p class="paragraph">
&quot;「へ～」その４：終了プロセスをゾンビにしてる箇所発見(kern_exit.c)&quot;で reaper() がゾンビにしている、と書きましたが、実際にreaper()が呼ばれるまでにはタイムラグが存在するようです。
<br />
</p>

<h4 id="id3fbfde">３．cpu_exit() → (scheduling) → exit2() → (kernel thread) → reaper()</h4>

<p class="paragraph">
reaper()では&quot;deadproc&quot;のリストを手繰っていますが、exit1()の中では&quot;zombproc&quot;に追加しているだけです。
<br />
実際に&quot;deadproc&quot;に追加しているのは、cpu_exit()から呼ばれるexit2()です。
<br />
</p>

<p class="paragraph">
kern_exit.c:
<br />
</p>
<pre class="plugin_pre">
/*
 * We are called from cpu_exit() once it is safe to schedule the
 * dead process&#039;s resources to be freed (i.e., once we&#039;ve switched to
 * the idle PCB for the current CPU).
 *
 * NOTE: One must be careful with locking in this routine.  It&#039;s
 * called from a critical section in machine-dependent code, so
 * we should refrain from changing any interrupt state.
 *
 * We lock the deadproc list (a spin lock), place the proc on that
 * list (using the p_hash member), and wake up the reaper.
 */
void
exit2(struct proc *p)
{

    simple_lock(&amp;deadproc_slock);
    LIST_INSERT_HEAD(&amp;deadproc, p, p_hash);
    simple_unlock(&amp;deadproc_slock);

    wakeup(&amp;deadproc);
}
</pre>

<p class="paragraph">
これで、終了プロセスが&quot;deadproc&quot;に追加されます。
<br />
</p>

<p class="paragraph">
その後さらにカーネルスレッドからreaper()が呼ばれ、deadprocから外され、ゾンビマークが付けられ、親プロセスにシグナルが送信されます。
<br />
</p>
<pre class="plugin_pre">
/*
 * Process reaper.  This is run by a kernel thread to free the resources
 * of a dead process.  Once the resources are free, the process becomes
 * a zombie, and the parent is allowed to read the undead&#039;s status.
 */
void
reaper(void *arg)
{
    struct proc *p;

    KERNEL_PROC_UNLOCK(curproc);

    for (;;) {
        simple_lock(&amp;deadproc_slock);
        p = LIST_FIRST(&amp;deadproc);

        /* ... */

        /* Remove us from the deadproc list. */
        LIST_REMOVE(p, p_hash);
        simple_unlock(&amp;deadproc_slock);
        KERNEL_PROC_LOCK(curproc);

        /* ... */

        /* Process is now a true zombie. */
        p-&gt;p_stat = SZOMB;

        /* Wake up the parent so it can get exit status. */
        if ((p-&gt;p_flag &amp; P_FSTRACE) == 0 &amp;&amp; p-&gt;p_exitsig != 0)
            psignal(p-&gt;p_pptr, P_EXITSIG(p));

        /* ... */
    }
}
</pre>

<p class="paragraph">
結論から言うと、これが親プロセスへSIGCHLDを送信している箇所です。
<br />
</p>
<pre>psignal(p-&gt;p_pptr, P_EXITSIG(p));
</pre>

<h5 id="id63b46a">親プロセスへのSIGCHLD送信箇所を特定</h5>

<pre>P_EXITSIG(p)
</pre>
<p class="paragraph">
このマクロ定義は sys/proc.h にあります。
<br />
sys/proc.h:
<br />
</p>
<pre class="plugin_pre">
/*
 * Macro to compute the exit signal to be delivered.
 */
#define P_EXITSIG(p)    (((p)-&gt;p_flag &amp; (P_TRACED|P_FSTRACE)) ? SIGCHLD : \
                         p-&gt;p_exitsig)
</pre>
<p class="paragraph">
&quot;TRACE&quot;はデバッグ絡みですのでこの際無視します。すると、
<br />
</p>
<pre>P_EXITSIG(p)
=
p-&gt;p_exitsig
</pre>
<p class="paragraph">
ということになります。
<br />
</p>

<p class="paragraph">
名前からして、いかにも「終了時のシグナル」という感じですが、これはどこで設定されているのか？適当にsrc/sys/kern/内をgrepしてみます。
<br />
すると、kern_fork.c内でそれらしき行がヒットしました。
<br />
</p>
<pre class="plugin_pre">
int
fork1(struct proc *p1, int flags, int exitsig, void *stack, size_t stacksize,
    void (*func)(void *), void *arg, register_t *retval,
    struct proc **rnewprocp)
{
    struct proc     *p2, *tp;


    /* Record the signal to be delivered to the parent on exit. */
    p2-&gt;p_exitsig = exitsig;
</pre>
<p class="paragraph">
コメントの通りで、fork1()の三番目の引数exitsigを、プロセス終了時に親プロセスに送られるシグナル番号としてp_exitsigに設定しています。
<br />
</p>

<p class="paragraph">
あとは src/sys/kern/ 内を&quot;fork1&quot;でgrepすれば、明らかにexitsigがSIGCHLDであることが分かります。
<br />
</p>
<pre class="plugin_pre">
$ grep fork1 *
init_main.c:    if (fork1(p, 0, SIGCHLD, NULL, 0, start_init, NULL, NULL, &amp;initproc))
init_sysent.c:      sys___vfork14 },                    /* 282 = __vfork14 */
kern_fork.c:    return (fork1(p, 0, SIGCHLD, NULL, 0, NULL, NULL, retval, NULL));
kern_fork.c:    return (fork1(p, FORK_PPWAIT, SIGCHLD, NULL, 0, NULL, NULL,
kern_fork.c:sys___vfork14(struct proc *p, void *v, register_t *retval)
kern_fork.c:    return (fork1(p, FORK_PPWAIT|FORK_SHAREVM, SIGCHLD, NULL, 0,
kern_fork.c:    return (fork1(p, flags, sig, SCARG(uap, stack), 0,
kern_fork.c:fork1(struct proc *p1, int flags, int exitsig, void *stack, size_t stacksize,
kern_kthread.c: error = fork1(&amp;proc0, FORK_SHAREVM | FORK_SHARECWD | FORK_SHAREFILES |
syscalls.c:     &quot;__vfork14&quot;,                    /* 282 = __vfork14 */
syscalls.master:282     STD             { int sys___vfork14(void); }
</pre>

<p class="paragraph">
kern_exit.c のreaper()に戻すと、親プロセスにシグナルを送信している
<br />
</p>
<pre>psignal(p-&gt;p_pptr, P_EXITSIG(p));
</pre>
<p class="paragraph">
ですが、これまでの調査により一般的には
<br />
</p>
<pre>psignal(p-&gt;p_pptr, SIGCHLD);
</pre>
<p class="paragraph">
と同じことが分かりました。
<br />
</p>

<p class="paragraph">
<strong>ようやく、exit(2) → 親プロセスへのSIGCHLD送信の道筋が掴めました！！</strong>
<br />
</p>

<h4 id="id2f2116">４．親プロセスのSIGCHLD受信 → シグナルハンドラ</h4>

<p class="paragraph">
この辺はkern_sig.cの話になりますが、さすがに追いきれませんでした。
<br />
とりあえずシグナルハンドラ → wait4()が呼ばれ、sys_wait4()に入ってきたものとして進めます。
<br />
</p>

<h4 id="id0cff9f">５．シグナルハンドラ → sys_wait4() → ゾンビ回収</h4>

<p class="paragraph">
&quot;「へ～」その７：wait4()中でゾンビプロセスを回収している箇所を発見&quot;に書いてある通りです。
<br />
</p>

<p class="paragraph">
<strong>お疲れ様でした。</strong>
<br />
</p>

<p class="paragraph">
これでようやく、exit(2) → wait4(2) までの流れを、舞台裏から見ることが出来ました。
<br />
シグナル送受信の箇所については、タスク切り替えなども絡みそうで追いきれませんでしたが、それでも、「あ～、manページ載ってたあの動作って、ここで処理してたのか～」という驚きは感じられました。・・・よね？
<br />
</p>

<p class="paragraph">
今回はIntermissionということで、ぐだぐだ、だらだらとソースを眺めてみました。
<br />
個人的には、ソースを調べてでも中身を確認しておきたい機能はひとまず、消化完了です。ですのでこのシリーズは暫くお休みになります。
<br />
「どうしてもソースを調べて中身を確認しないと気になって夜も眠れない」ようなトピックが出てきたら、またその時再開します。
<br />
</p>

<p class="paragraph">
では・・・
<br />
</p>

<p class="paragraph">
「今回のお題については、ここまで。」
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-850.html" title="C言語系/「デーモン君のソース探検」読書メモ/A10, popen(3)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-533.html" title="C言語系/ポインタ・配列の定義と宣言メモ1">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-546.html" title="C言語系/「デーモン君のソース探検」読書メモ">Up</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/851<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2001 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" target="_blank" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>