<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>技術/Linux/手作りLinuxシステム/05. Boot from Network(PXE) (kernel-2.6.x) - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">技術/Linux/手作りLinuxシステム/05. Boot from Network(PXE) (kernel-2.6.x)</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2011-04-26 16:07:19 &nbsp; / &nbsp; last updated at: 2011-04-29 15:37:36<br>
カテゴリ: <a href="category-20.html">Linux</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-953.html" title="技術/Linux/手作りLinuxシステム/04. Boot from CD (kernel-2.6.x)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-959.html" title="技術/Linux/手作りLinuxシステム/06. Boot from Network(PXE + NFS + KGDB) (kernel-2.6.x)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-23.html" title="技術">技術</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
今回はPXE(Preboot Execution Environment)を使ったネットワークブートに挑戦してみます。ローカルHDDのマウントは考慮しません。
<br />
</p>

<p class="paragraph">
ステップ１：SYSLINUXの提供するPXE対応BootLoader, PXELINUXを使ってkernelと初期RAMディスク(initrd)をロードし、そのままinitrdをrootとしてマウントします。
<br />
kernelとinitrdは前回： <a href="./view-953.html" >技術/Linux/手作りLinuxシステム/04. Boot from CD (kernel-2.6.x)</a> と同じで、BootLoaderがISOLINUX(前回)からPXELINUX(今回)に切り替わっただけです。
<br />
</p>

<p class="paragraph">
ステップ２：ステップ３の下準備としてカーネルの起動時メッセージ(dmesgで確認できるアレ)をシリアルコンソールに表示させてみます。
<br />
</p>

<p class="paragraph">
ステップ３：rootファイルシステムをNFS経由でマウントしてます。
<br />
</p>




<ul><li><a href="#idc10f15">ステップ１：kernel + initrdの構成をPXELINUXで起動してみる</a><ul><li><a href="#id433a8f">PXEについて</a></li>
<li><a href="#id0e4aa5">DHCP, tftp, PXELINUXの設定と動作確認</a></li></ul></li>
<li><a href="#id49e19b">ステップ２：起動時メッセージをシリアルコンソールで確認できるようにする</a><ul><li><a href="#idadaddc">仮想マシンのシリアルポート設定</a></li>
<li><a href="#idf0ea08">Linux Kernelの設定</a></li>
<li><a href="#id0bea8e">PXELINUXの設定</a></li>
<li><a href="#id945219">minicomの設定</a></li>
<li><a href="#idd7f3f2">動作確認</a></li></ul></li>
<li><a href="#id54f6d9">ステップ３：rootファイルシステムをNFSマウントしてみる</a><ul><li><a href="#ide931c1">NFSサーバの準備</a><ul><li><a href="#id19aacf">NFSとTCP Wrappersのアクセス制御について</a></li></ul></li>
<li><a href="#id26f397">ルートファイルシステムの準備</a></li>
<li><a href="#idf0ea08">Linux Kernelの設定</a><ul><li><a href="#id5fef14">ネットワークカードのデバイスドライバの組み込み</a></li>
<li><a href="#idf9f5c5">kernel起動時のIPスタック機能</a></li>
<li><a href="#id721ce3">NFSファイルシステムとrootマウント</a></li>
<li><a href="#id8246c6">NFS rootマウントするとき、Buildroot, BusyBox, uClibc側で特別な設定は必要か？</a></li></ul></li>
<li><a href="#id0bea8e">PXELINUXの設定</a></li>
<li><a href="#idd7f3f2">動作確認</a></li>
<li><a href="#id11f8f5">NFSrootマウント出来ないときは</a></li></ul></li>
<li><a href="#idaa37b1">その他の参考URL</a></li></ul>
<hr />
<h3 id="idc10f15">ステップ１：kernel + initrdの構成をPXELINUXで起動してみる</h3>

<h4 id="id433a8f">PXEについて</h4>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Preboot_Execution_Environment" target="_blank">http://en.wikipedia.org/wiki/Preboot_Execution_Environment</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/BOOTP" target="_blank">http://en.wikipedia.org/wiki/BOOTP</a></li>
<li> <a class="externallink" href="http://syslinux.zytor.com/wiki/index.php/PXELINUX" target="_blank">http://syslinux.zytor.com/wiki/index.php/PXELINUX</a></li>
<li> <a class="externallink" href="http://www.znet.or.jp/~clare/bsd/pxeboot.html" target="_blank">http://www.znet.or.jp/~clare/bsd/pxeboot.html</a></li></ul>

<p class="paragraph">
最初にPXEと周辺技術についてごく簡単にまとめておきます。
<br />
PXEはIntelによりまとめられた「仕様」であり、実装はBIOSベンダやネットワークカードのメーカに任されています。
<br />
PXEはDHCP, BOOTPなどネットワーク関連技術を活用し、カーネル等をDL・展開するプロトコルなどを規定しています。
<br />
PXEはロードされたカーネル(実際はPXELINUXなどのBootLoader)が引き続きネットワーク機能を使えるよう、各種APIを定義しています。
<br />
</p>

<p class="paragraph">
PXELINUXとは、PXEを使ってLinuxカーネルをロードし、ブートするためのプログラムになります。
<br />
</p>

<p class="paragraph">
PXEを使ったブート時の流れをごく簡単にまとめます。
<br />
</p>
<ol><li> PXEに対応したターゲットマシンの電源がON, PXE処理開始</li>
<li> DHCP/BOOTPでターゲットマシンのIPアドレス、BootLoaderファイル名、ダウンロード先TFTPサーバのIPアドレスを取得</li>
<li> BootLoaderをTFTPサーバよりダウンロードし展開・実行</li></ol>

<p class="paragraph">
ここから先は、実行されるBootLoaderによってLinuxを起動したり、その他のOSを起動したりします。
<br />
</p>

<p class="paragraph">
PXELINUXの場合は、設定ファイルをTFTPサーバよりダウンロードし、bootプロンプトやメニューなどを表示します。
<br />
その後TFTPサーバよりLinuxカーネルやinitrdをダウンロードし、kernelの起動を開始します。
<br />
</p>

<p class="paragraph">
PXEによるネットワークブートを行う際、様々なWeb上の記事を参考にすると思います。
<br />
PXEが何であって何でないのか、それを把握しておくことで記事毎の細かい差異に振り回されず、無用なトラブルを回避できます。
<br />
</p>

<h4 id="id0e4aa5">DHCP, tftp, PXELINUXの設定と動作確認</h4>

<p class="paragraph">
PXELINUXに必要な構成要素：
<br />
</p>
<ul><li> DHCP/BOOTP サーバ：CentOS 5.5 の ISC DHCP(Version 3) を使用</li>
<li> TFTPサーバ：CentOS 5.5 の tftp, tftp-server パッケージを使用</li>
<li> PXELINUX：CentOS 5.5 の syslinux-3.11 パッケージ提供の pxelinux.0 を使用</li></ul>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> mk-mode BLOG ≫ ＣｅｎｔＯＳ － ＰＸＥサーバ構築<ul><li> <a class="externallink" href="http://www.mk-mode.com/wordpress/?p=3082" target="_blank">http://www.mk-mode.com/wordpress/?p=3082</a></li></ul></li>
<li> PXEを使ったネットワークブート<ul><li> <a class="externallink" href="http://mitty.jp/pc/networkboot/" target="_blank">http://mitty.jp/pc/networkboot/</a></li></ul></li></ul>

<p class="paragraph">
１．DHCP, tftp, syslinux等必要なパッケージをインストールしておきます。
<br />
</p>

<p class="paragraph">
２．tftpとPXELINUXの準備
<br />
</p>

<p class="paragraph">
CentOS 5.5, tftp-server-0.49 の場合はパッケージインストール時に
<br />
</p>
<pre>/tftpboot
</pre>
<p class="paragraph">
ディレクトリが自動的に作成されます。また、xinetd用の設定ファイルも
<br />
</p>
<pre>/etc/xinetd.d/tftp
</pre>
<p class="paragraph">
に作成されます。
<br />
</p>

<p class="paragraph">
tftpを有効化するには /etc/xinetd.d/tftp の
<br />
</p>
<pre>disable                 = yes
</pre>
<p class="paragraph">
を
<br />
</p>
<pre>disable                 = no
</pre>
<p class="paragraph">
に修正し、xinetdを再起動します。
<br />
細かい設定や動作確認については &quot;man tftpd&quot;, &quot;man tftp&quot; を参照してください。
<br />
</p>

<p class="paragraph">
続いて pxelinux.0 を &quot;/tftpboot/&quot; の下にコピーします。
<br />
</p>
<pre># rpm -ql syslinux | grep pxelinux
/usr/lib/syslinux/pxelinux.0
# cp /usr/lib/syslinux/pxelinux.0 /tftpboot/
</pre>

<p class="paragraph">
PXELINUXの設定ファイルを作成します。MACアドレスやIPで設定ファイルを分けることもできますが、今回は単一のdefaultというファイル名で設定ファイルを用意します。設定ファイルの分け方などはPXELINUXのドキュメントを参照してください。
<br />
</p>
<pre># mkdir -p /tftpboot/pxelinux.cfg
# vi /tftpboot/pxelinux.cfg/default
</pre>
<p class="paragraph">
内容：
<br />
</p>
<pre>default linux
label linux
  kernel bzImage
  append initrd=rootfs.gz root=/dev/ram0
</pre>

<p class="paragraph">
３．DHCPを設定します。
<br />
</p>

<p class="paragraph">
今回、CentOS 5.5 と ターゲットマシンは両方共 VMware のNAT上で動作します。
<br />
VMware NAT でもDHCPを有効化しているので、それと重複しないIPアドレス範囲を設定しておきます。
<br />
</p>
<pre class="plugin_pre">
allow booting;
allow bootp;

subnet 192.168.240.0 netmask 255.255.255.0 {
        option domain-name &quot;glamenv-septzen.net&quot;;
        option broadcast-address 192.168.240.255;
        option domain-name-servers 192.168.240.2;
        option routers 192.168.240.2;

        # TFTPサーバ IPアドレス
        next-server 192.168.240.10;
        # &quot;/tftpboot&quot; をルートとしたファイル名で指定
        filename &quot;/pxelinux.0&quot;;

        # VMware NAT のDHCPと重ならないIPアドレス範囲
        range dynamic-bootp 192.168.240.100 192.168.240.110;
}

ddns-update-style ad-hoc;
</pre>

<p class="paragraph">
DHCPサービスを起動します。
<br />
</p>
<pre># service dhcpd start
# chkconfig --level 345 dhcpd on
</pre>

<p class="paragraph">
４．PXLINUXの起動確認
<br />
</p>

<p class="paragraph">
この段階で、&quot;/tftpboot/pxelinux.0&quot; が起動することを確認してみます。
<br />
ターゲットマシンのVMware仮想マシンを開始してみます。
<br />
</p>

<p class="paragraph">
<a href="./../images/reduced.linux/05_01.png" title="" target="_blank"><img src="./../images/reduced.linux/05_01.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
このようにPXELINUXの&quot;boot:&quot;プロンプトが表示されればOKです。
<br />
</p>

<p class="paragraph">
５．Linuxカーネルとinitrdの起動確認
<br />
</p>

<p class="paragraph">
<a href="./view-953.html" >技術/Linux/手作りLinuxシステム/04. Boot from CD (kernel-2.6.x)</a> でISOイメージに格納した bzImage と rootfs.gz を &quot;/tftpboot/&quot; 以下に配置します。
<br />
</p>
<pre>/tftpboot/
    pxelinux.0
    bzImage
    rootfs.gz
    pxelinux.cfg/
        default
</pre>

<p class="paragraph">
これで起動してみます。(スクリーンショットは省略)
<br />
前回と同様にuClibc + BusyBox環境が立ち上がれば成功です。
<br />
</p>

<h3 id="id49e19b">ステップ２：起動時メッセージをシリアルコンソールで確認できるようにする</h3>

<p class="paragraph">
NFSのrootマウント絡みで問題が発生した場合、頼りになるのはコンソールに表示された起動時メッセージになります。
<br />
しかしディスプレイ画面ですと起動時メッセージはスクロールしてしまい、メッセージ全体を把握できません。ユーザーランドでshellが動き始めれば「Shift + PageDown/PageUp」でスクロールしたり dmesg コマンドで確認できますが、そもそもrootマウントに失敗すればユーザーランドも動きません。
<br />
そういう時に頼りになるのが、シリアルコンソール経由で取得できる起動時メッセージです。
<br />
</p>

<p class="paragraph">
というわけで、NFSをrootマウント出来るようにする下準備として、Linux Kernelの起動時メッセージをシリアルコンソールで確認できるようにしてみます。
<br />
シリアルコンソールからのログインについてはユーザーランドに関わるため、本記事では取り扱いません。
<br />
</p>

<h4 id="idadaddc">仮想マシンのシリアルポート設定</h4>

<p class="paragraph">
今回はホストマシン、ターゲットマシン共にVMware上で動かしています。VMware自体のホストOSはWin7です。
<br />
そこで、両方のマシンにシリアルポートデバイスを追加しておきます。
<br />
物理ポートではなく、Windowsの名前付きパイプを使います。
<br />
</p>

<p class="paragraph">
ホストマシン(CentOS 5.5)：
<br />
<a href="./../images/reduced.linux/05_02.jpg" title="" target="_blank"><img src="./../images/reduced.linux/05_02.jpg" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
&quot;.vmx&quot;ファイルの設定：
<br />
</p>
<pre>serial0.present = &quot;TRUE&quot;
serial0.fileType = &quot;pipe&quot;
serial0.fileName = &quot;\\.\pipe\console&quot;
serial0.pipe.endPoint = &quot;client&quot;
</pre>

<p class="paragraph">
ターゲットマシン：
<br />
<a href="./../images/reduced.linux/05_03.jpg" title="" target="_blank"><img src="./../images/reduced.linux/05_03.jpg" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
&quot;.vmx&quot;ファイルの設定：
<br />
</p>
<pre>serial0.present = &quot;TRUE&quot;
serial0.fileType = &quot;pipe&quot;
serial0.fileName = &quot;\\.\pipe\console&quot;
serial0.pipe.endPoint = &quot;server&quot;
</pre>

<h4 id="idf0ea08">Linux Kernelの設定</h4>

<p class="paragraph">
次のオプションを有効にして、bzImageを再コンパイルします(&quot;make bzImage&quot;)。
<br />
</p>
<pre>CONFIG_SERIAL_8250
CONFIG_SERIAL_8250_CONSOLE
</pre>
<p class="paragraph">
&quot;make menuconfig&quot;からは以下の階層を辿ります。
<br />
</p>
<pre>Device Drivers ---&gt;
    Character devices ---&gt;
        Serial drivers
</pre>

<p class="paragraph">
出来上がったbzImageは、&quot;bzImageSer&quot;など区別しやすい名前で &quot;/tftpboot&quot; の下にコピーしておきます。
<br />
</p>

<h4 id="id0bea8e">PXELINUXの設定</h4>

<p class="paragraph">
&quot;/tftpboot/pxelinux.cfg/default&quot; にシリアルコンソール用のカーネルとカーネルパラメータを指定したエントリを追加します。
<br />
</p>
<pre>prompt 1
label linux
  kernel bzImage
  append initrd=rootfs.gz root=/dev/ram0
label sercons
  kernel bzImageSer
  append initrd=rootfs.gz root=/dev/ram0 console=ttyS0,115200 console=tty0
</pre>

<p class="paragraph">
今回はディスプレイ画面とシリアルポートの両方に起動時メッセージを出力したいので、&quot;console=&quot;を二つ指定してみました。
<br />
二つ以上の&quot;console=&quot;指定があると、最後に指定されたデバイスが &quot;/dev/console&quot; になります。ユーザーランドのシェルなどはディスプレイ画面とキーボード、つまり tty0 を使いたいので、&quot;console=tty0&quot;を最後に指定しています。
<br />
</p>

<p class="paragraph">
シリアルコンソールの詳細は &quot;Documentation/serial-console.txt&quot; を参照してください。
<br />
</p>

<h4 id="id945219">minicomの設定</h4>

<p class="paragraph">
Linuxでシリアルコンソールに接続するためのツールとしては kermit と minicom が著名なようです。
<br />
今回ホストマシンとして使用する CentOS 5.5 では、minicomをパッケージとして提供しています。
<br />
</p>

<p class="paragraph">
というわけで、minicomを使ってシリアルコンソールに接続するための設定を行います。
<br />
最初にminicomをインストールしておいてください。
<br />
</p>
<pre># yum install minicom
</pre>

<p class="paragraph">
ttyS0用の設定を作成します。minicomを設定モードで起動します。日本語化されていますが、minicomの画面レイアウトが崩れたり文字化けしてしまい、使いづらいです。そのため、英語モードで起動するよう &quot;LANG=C&quot; を指定します。
<br />
</p>
<pre># LANG=C minicom -s
</pre>

<pre>┌─────[configuration]─┐
│ Filenames and paths        │
│ File transfer protocols    │
│ Serial port setup          │
│ Modem and dialing          │
│ Screen and keyboard        │
│ Save setup as dfl          │
│ Save setup as..            │
│ Exit                       │
│ Exit from Minicom          │
└────────────―─┘
</pre>

<p class="paragraph">
&quot;Serial port setup&quot; を選択して適当にセットアップします。
<br />
</p>
<pre>┌─────────────────────
│ A -    Serial Device      : /dev/ttyS0   
│ B - Lockfile Location     : /var/lock    
│ C -   Callin Program      :              
│ D -  Callout Program      :              
│ E -    Bps/Par/Bits       : 115200 8N1   
│ F - Hardware Flow Control : Yes          
│ G - Software Flow Control : No           
│                                          
│    Change which setting?                 
└─────────────────────
</pre>

<p class="paragraph">
&quot;Modem and dialing&quot;機能は使わないので、モデム向けの各種送信文字列を空にしておきます。
<br />
</p>
<pre class="plugin_pre">
┌────[Modem and dialing parameter setup]──────────────
│                                                                       
│ A - Init string .........                                             
│ B - Reset string ........                                             
│ C - Dialing prefix #1....                                             
│ D - Dialing suffix #1....                                             
│ E - Dialing prefix #2....                                             
│ F - Dialing suffix #2....                                             
│ G - Dialing prefix #3....                                             
│ H - Dialing suffix #3....                                             
│ I - Connect string ......                                             
│ J - No connect strings ..                                             
│                                                                       
│ K - Hang-up string ......                                             
│ L - Dial cancel string ..                                             
│                                                                       
│ M - Dial time ........... 45      Q - Auto bps detect ..... No        
│ N - Delay before redial . 2       R - Modem has DCD line .. Yes       
│ O - Number of tries ..... 10      S - Status line shows ... DTE speed 
│ P - DTR drop time (0=no). 1       T - Multi-line untag .... No        
│                                                                       
│ Change which setting?       (Return or Esc to exit)                   
└────────────────────────────────────
</pre>

<p class="paragraph">
&quot;Save setup as..&quot;を選択し、&quot;ttyS0&quot;という名前で保存します。
<br />
</p>
<pre>┌────────────────────┐
│Give name to save this configuration?   │
│&gt; ttyS0                                 │
└────────────────────┘
</pre>

<p class="paragraph">
ファイルの実体は &quot;/etc/minirc.ttyS0&quot; になります。
<br />
</p>

<p class="paragraph">
&quot;Exit from Minicom&quot; で一旦終了します。
<br />
</p>

<p class="paragraph">
minicomの設定・使い方参考：
<br />
</p>
<ul><li> minicomの使い方 - パパ日記<ul><li> <a class="externallink" href="http://shirata.ddo.jp/papa/blog/2007/11/minicom.html" target="_blank">http://shirata.ddo.jp/papa/blog/2007/11/minicom.html</a></li></ul></li>
<li> シリアル接続による開発ボードの動作確認 － ＠IT MONOist<ul><li> <a class="externallink" href="http://monoist.atmarkit.co.jp/fembedded/dev02/dev02b.html" target="_blank">http://monoist.atmarkit.co.jp/fembedded/dev02/dev02b.html</a></li></ul></li>
<li> minicomでシリアル通信 - 3日目の坊主<ul><li> <a class="externallink" href="http://blog.goo.ne.jp/amichang/e/fc231ef2e231d569af0a0610ead7726f" target="_blank">http://blog.goo.ne.jp/amichang/e/fc231ef2e231d569af0a0610ead7726f</a></li></ul></li></ul>

<ul><li> DEBUG HACKS, HACK#16, 「minicomでシリアルコンソール接続を行う」</li></ul>
<a href="https://www.amazon.co.jp/dp/4873114047" target="_blank">Amazon.co.jp: Debug Hacks -デバッグを極めるテクニック&amp;ツール : 吉岡 弘隆, 大和 一洋, 大岩 尚宏, 安部 東洋, 吉田 俊輔: 本</a><br>

<p class="paragraph">
minicom, kermitについてはWebで調べると沢山記事が出てくるので、適当に調べてみてください。
<br />
</p>

<h4 id="idd7f3f2">動作確認</h4>

<p class="paragraph">
まずホストマシン側でminicomを起動します。
<br />
</p>
<pre># LANG=C minicom ttyS0
</pre>
<p class="paragraph">
これで先ほど設定を保存した &quot;/etc/minirc.ttyS0&quot; を読み込んでminicomが起動します。
<br />
</p>

<p class="paragraph">
続いて minicom 上で行の折り返しを有効にします。
<br />
</p>
<pre>&quot;Ctrl+A&quot; -&gt; &quot;W&quot;
</pre>
<p class="paragraph">
で有効になります。小文字の&quot;w&quot;だと無効になります。
<br />
</p>

<p class="paragraph">
次にVMwareのターゲットマシンを起動します。&quot;boot:&quot;プロンプトで、&quot;console=&quot;を追加したラベルを指定します。
<br />
</p>

<p class="paragraph">
全てが上手く行けば、minicomで起動時メッセージが表示されます：
<br />
</p>
<pre class="plugin_pre">
Linux version 2.6.38.2 (msakamoto@siranui.localdomain) (gcc version 4.1.2 200807
04 (Red Hat 4.1.2-48)) #1 Thu Apr 28 13:45:04 JST 2011
BIOS-provided physical RAM map:
 BIOS-e820: 0000000000000000 - 000000000009f400 (usable)
 BIOS-e820: 000000000009f400 - 00000000000a0000 (reserved)
 BIOS-e820: 00000000000ca000 - 00000000000cc000 (reserved)
 BIOS-e820: 00000000000dc000 - 00000000000e4000 (reserved)
 BIOS-e820: 00000000000e8000 - 0000000000100000 (reserved)
 BIOS-e820: 0000000000100000 - 0000000007ef0000 (usable)
 BIOS-e820: 0000000007ef0000 - 0000000007eff000 (ACPI data)
 BIOS-e820: 0000000007eff000 - 0000000007f00000 (ACPI NVS)
 BIOS-e820: 0000000007f00000 - 0000000008000000 (usable)
 BIOS-e820: 00000000e0000000 - 00000000f0000000 (reserved)
 BIOS-e820: 00000000fec00000 - 00000000fec10000 (reserved)
 BIOS-e820: 00000000fee00000 - 00000000fee01000 (reserved)
 BIOS-e820: 00000000fffe0000 - 0000000100000000 (reserved)
Notice: NX (Execute Disable) protection cannot be enabled: non-PAE kernel!
DMI present.
Hypervisor detected: VMware
last_pfn = 0x8000 max_arch_pfn = 0x100000
x86 PAT enabled: cpu 0, old 0x0, new 0x7010600070106
init_memory_mapping: 0000000000000000-0000000008000000
RAMDISK: 07d6d000 - 07ed0000
0MB HIGHMEM available.
128MB LOWMEM available.
  mapped low ram: 0 - 08000000
  low ram: 0 - 08000000
Zone PFN ranges:
  DMA      0x00000010 -&gt; 0x00001000
  Normal   0x00001000 -&gt; 0x00008000
  HighMem  empty
Movable zone start PFN for each node
early_node_map[3] active PFN ranges
    0: 0x00000010 -&gt; 0x0000009f
    0: 0x00000100 -&gt; 0x00007ef0
    0: 0x00007f00 -&gt; 0x00008000
Allocating PCI resources starting at 8000000 (gap: 8000000:d8000000)
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 32383
Kernel command line: initrd=rootfs.gz root=/dev/ram0 console=ttyS0,115200 consol
e=tty0 BOOT_IMAGE=bzImageSer
PID hash table entries: 512 (order: -1, 2048 bytes)
Dentry cache hash table entries: 16384 (order: 4, 65536 bytes)
Inode-cache hash table entries: 8192 (order: 3, 32768 bytes)
Initializing CPU#0
Initializing HighMem for node 0 (00000000:00000000)
Memory: 126156k/131072k available (1003k kernel code, 4400k reserved, 354k data,
 208k init, 0k highmem)
virtual kernel memory layout:
    fixmap  : 0xfffe5000 - 0xfffff000   ( 104 kB)
    pkmap   : 0xff800000 - 0xffc00000   (4096 kB)
    vmalloc : 0xc8800000 - 0xff7fe000   ( 879 MB)
    lowmem  : 0xc0000000 - 0xc8000000   ( 128 MB)
      .init : 0xc1154000 - 0xc1188000   ( 208 kB)
      .data : 0xc10faf2b - 0xc1153aa0   ( 354 kB)
      .text : 0xc1000000 - 0xc10faf2b   (1003 kB)
Checking if this processor honours the WP bit even in supervisor mode...Ok.
SLUB: Genslabs=15, HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
NR_IRQS:16
Console: colour VGA+ 80x25
console [tty0] enabled
console [ttyS0] enabled
TSC freq read from hypervisor : 3059.060 MHz
Detected 3059.060 MHz processor.
Calibrating delay loop (skipped) preset value.. 6118.12 BogoMIPS (lpj=12236240)
pid_max: default: 32768 minimum: 301
Mount-cache hash table entries: 512
CPU: Intel(R) Core(TM) i3 CPU         540  @ 3.07GHz stepping 02
Performance Events: Westmere events, Broken PMU hardware detected, using softwar
e events only.
bio: create slab &lt;bio-0&gt; at 0
Switching to clocksource pit
Unpacking initramfs...
Freeing initrd memory: 1420k freed
platform rtc_cmos: registered platform RTC device (no PNP device found)
io scheduler noop registered (default)
Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled
serial8250: ttyS0 at I/O 0x3f8 (irq = 4) is a 16550A
serial8250: ttyS1 at I/O 0x2f8 (irq = 3) is a 16550A
serio: i8042 KBD port at 0x60,0x64 irq 1
serio: i8042 AUX port at 0x60,0x64 irq 12
mousedev: PS/2 mouse device common for all mice
Freeing unused kernel memory: 208k freed
input: AT Translated Set 2 keyboard as /devices/platform/i8042/serio0/input/inpu
t0
Switching to clocksource tsc
</pre>

<p class="paragraph">
minicomを終了する：
<br />
</p>
<pre>&quot;Ctrl-A&quot; -&gt; &quot;q&quot;
</pre>

<h3 id="id54f6d9">ステップ３：rootファイルシステムをNFSマウントしてみる</h3>

<p class="paragraph">
これまでrootファイルシステムはinitrdをそのまま使っていました。initrdをそのまま使う場合のデメリットとして、ファイル構成を変更する度にloopbackマウントしたり、Buildrootでmakeする必要がありました。
<br />
しかしPXEでネットワークブートが可能になった今、NFSでRootFSをマウントすることでこれらinitrdのデメリットを回避することができます。ホストマシン上でのファイル変更が、ターゲットマシンでもすぐに利用可能で、initrdの時のような中間ステップが不要になります。
<br />
</p>

<p class="paragraph">
NFSの基本や仕組みについては割愛します。適宜Webで調べておいてください。
<br />
</p>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> NFS-Root mini-HOWTO<ul><li> <a class="externallink" href="http://www.tldp.org/HOWTO/NFS-Root.html" target="_blank">http://www.tldp.org/HOWTO/NFS-Root.html</a></li></ul></li>
<li> Linux NFS-HOWTO<ul><li> <a class="externallink" href="http://www.tldp.org/HOWTO/NFS-HOWTO/index.html" target="_blank">http://www.tldp.org/HOWTO/NFS-HOWTO/index.html</a></li></ul></li></ul>

<h4 id="ide931c1">NFSサーバの準備</h4>

<p class="paragraph">
今回のホストマシン CentOS 5.5 では、パッケージをインストールするだけでNFSサーバとして利用できます。
<br />
次のパッケージをインストールして下さい。
<br />
</p>
<pre>nfs-utils
nfs-utils-lib
</pre>

<p class="paragraph">
インストール後、exportsするディレクトリを用意します。とりあえず空のディレクトリを用意してみます。
<br />
</p>
<pre># mkdir -p /opt/nfsexports/root1
</pre>

<p class="paragraph">
&quot;/etc/exports&quot; に設定します。
<br />
</p>
<pre># cat /etc/exports
/opt/nfsexports/root1 *(rw,sync,no_root_squash)
</pre>

<p class="paragraph">
NFSサービスを起動します。
<br />
</p>
<pre># service nfs start
NFS サービスを起動中:                                      [  OK  ]
NFS クォータを起動中:                                      [  OK  ]
NFS デーモンを起動中:                                      [  OK  ]
NFS mountd を起動中:                                       [  OK  ]
RPC idmapd を起動中:                                       [  OK  ]
</pre>

<p class="paragraph">
マウントして動作確認してみます。
<br />
</p>
<pre># mkdir -p /mnt/nfstest
# mount -t nfs localhost:/opt/nfsexports/root1 /mnt/nfstest
</pre>

<p class="paragraph">
&quot;/mnt/nfstest&quot; 内でファイルを作成してみて、 &quot;/opt/nfsexports/root1/&quot; 以下からもアクセスできることを確認して下さい。
<br />
</p>

<p class="paragraph">
/var/log/messages : mount時
<br />
</p>
<pre>... mountd[xxx]: authenticated mount request from 127.0.0.1:764 for /... (/...)
</pre>

<p class="paragraph">
/var/log/messages : umount時
<br />
</p>
<pre>... mountd[xxx]: authenticated unmount request from 127.0.0.1:775 for /... (/...)
</pre>

<h5 id="id19aacf">NFSとTCP Wrappersのアクセス制御について</h5>

<p class="paragraph">
NFSはRPC(Remote Procedure Call)を使っています。
<br />
ディストリビューションやNFSのバージョンによっては、アクセス制御をTCP Wrappersを使って実現している場合があります。
<br />
今回のホストマシン CentOS 5.5 では設定する必要がありませんでしたが、場合によっては
<br />
</p>
<pre>/etc/hosts.allow, /etc/hosts.deny
</pre>
<p class="paragraph">
ファイルを編集する必要があるかもしれません。
<br />
</p>

<p class="paragraph">
ディストリビューションのパッケージにより配布されているドキュメントやmanページを入念にチェックし、もし他にLinuxマシンを用意できるのであれば、まずは外部Linuxマシンから問題なくmount出来ることを確認しておいてください。
<br />
</p>

<p class="paragraph">
CentOS 5.5の場合、以下のmanページに /etc/hosts.allow, hosts.deny ファイルの編集内容が記載されています。
<br />
</p>
<pre>$ man rpc.mountd
$ man rpc.statd
</pre>

<h4 id="id26f397">ルートファイルシステムの準備</h4>

<p class="paragraph">
上で用意した
<br />
</p>
<pre>/opt/nfsexports/root1
</pre>
<p class="paragraph">
の中にルートファイルシステムを準備します。
<br />
</p>

<p class="paragraph">
これまで使ってきた initrd は、 <a href="./view-953.html" >技術/Linux/手作りLinuxシステム/04. Boot from CD (kernel-2.6.x)</a> でBuildrootを使ってgzipされたcpioイメージでした。
<br />
よって、このinitrdをそのままgunzipしてcpioで展開すればOKです。
<br />
あるいはBuildrootのビルドディレクトリの &quot;images&quot; ディレクトリの中に、gzipする前のcpioファイルがありますので、これを使っても構いません。
<br />
さらに、Buildrootのオプションとしてルートファイルシステムをtarボールで作成することも可能です。
<br />
</p>

<p class="paragraph">
何種類か方法が用意されていますが、最終的に&quot;images/&quot;の下に作成されたルートファイルシステムのアーカイブなりイメージファイルを展開出来ればOKです。
<br />
</p>

<p class="paragraph">
cpioアーカイブの場合の展開例：rootユーザで展開してください。
<br />
</p>
<pre># cd /opt/nfsexports/root1
# cpio -i &lt; /home/msakamoto/reduced.linux/04_cdboot/br/images/rootfs.cpio
</pre>

<h4 id="idf0ea08">Linux Kernelの設定</h4>

<p class="paragraph">
NFSをrootマウントするためにkernel設定を変更します。
<br />
大きく３つのパートに分かれます。
<br />
</p>
<ol><li> ネットワークカードのデバイスドライバの組み込み</li>
<li> kernel起動時のIPスタック機能</li>
<li> NFSファイルシステムとrootマウント</li></ol>

<p class="paragraph">
順に見ていきます。
<br />
</p>

<h5 id="id5fef14">ネットワークカードのデバイスドライバの組み込み</h5>

<p class="paragraph">
今回は VMware Workstation 7 上の仮想マシンを使います。
<br />
その場合、ネットワークカード(=ネットワークアダプタ)は AMD PCNET PCI アダプタまたは Intel Pro/1000 MT サーバアダプタとしてゲストOSに認識されます。
<br />
</p>

<p class="paragraph">
これまでのVMwareの使用してきた経験上、殆どのLinuxディストリビューションで pcnet32 モジュール(=AMD PCNET PCI アダプタ相当)が自動認識され、利用できています。
<br />
今回もこれに倣い、pcnet32を組み込みます。
<br />
</p>

<p class="paragraph">
&quot;make menuconfig&quot;の検索機能で&quot;PCNET32&quot;を検索した結果です（以降、&quot;[=y]&quot;, &quot;[=n]&quot;など現在設定を示す出力は削除しています）
<br />
</p>
<pre>Symbol: PCNET32
Type  : tristate
Prompt: AMD PCnet32 PCI support
  Defined at drivers/net/Kconfig:1381
  Depends on: NETDEVICES &amp;&amp; NET_ETHERNET &amp;&amp; NET_PCI &amp;&amp; PCI
  Location:
    -&gt; Device Drivers
      -&gt; Network device support (NETDEVICES)
        -&gt; Ethernet (10 or 100Mbit) (NET_ETHERNET)
          -&gt; EISA, VLB, PCI and on board controllers (NET_PCI)
  Selects: CRC32 &amp;&amp; MII
</pre>

<p class="paragraph">
&quot;Depends on&quot; の行の依存性をクリアしないと、このオプションを組み込むことが出来ません。
<br />
&quot;NETDEVICES&quot;, &quot;NET_ETHERNET&quot;, &quot;NET_PCI&quot; については&quot;Device Drivers&quot;以下の階層を辿れば組み込めます。
<br />
&quot;PCI&quot;については &quot;Bus options&quot; -&gt; &quot;PCI Support&quot; を組み込みます。
<br />
</p>
<pre>Symbol: PCI
Type  : boolean
Prompt: PCI support
  Defined at arch/x86/Kconfig:1859
  Location:
    -&gt; Bus options (PCI etc.)
  Selects: ARCH_SUPPORTS_MSI
</pre>

<p class="paragraph">
&quot;PCI&quot;組み込んだあと、&quot;Device Drivers&quot;以下を辿っていけば、必要なオプションを組み込めるはずです。
<br />
逆に &quot;PCI&quot; を組み込んでいない状態では、&quot;make menuconfig&quot;の設定画面で上記オプションが表示されず、組み込めないようになっています。
<br />
</p>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> Linux Ethernet-Howto<ul><li> <a class="externallink" href="http://www.tldp.org/HOWTO/Ethernet-HOWTO.html" target="_blank">http://www.tldp.org/HOWTO/Ethernet-HOWTO.html</a></li></ul></li></ul>

<h5 id="idf9f5c5">kernel起動時のIPスタック機能</h5>

<p class="paragraph">
起動時にDHCPやBOOTPで自分のIPアドレスを決定する機能を組み込みます。
<br />
</p>
<pre>CONFIG_IP_PNP_DHCP
CONFIG_IP_PNP_BOOTP
</pre>
<p class="paragraph">
上記オプションを組み込んでください。
<br />
</p>

<p class="paragraph">
参考：CONFIG_IP_PNP_DHCPを&quot;make menuconfig&quot;で検索したときの情報です。
<br />
</p>
<pre>Symbol: IP_PNP_DHCP [=y]
Type  : boolean
Prompt: IP: DHCP support
  Defined at net/ipv4/Kconfig:154
  Depends on: NET [=y] &amp;&amp; INET [=y] &amp;&amp; IP_PNP [=y]
  Location:
    -&gt; Networking support (NET [=y])
      -&gt; Networking options
        -&gt; TCP/IP networking (INET [=y])
          -&gt; IP: kernel level autoconfiguration (IP_PNP [=y])
</pre>

<h5 id="id721ce3">NFSファイルシステムとrootマウント</h5>

<p class="paragraph">
NFSファイルシステムを組み込みます。CONFIG_NFS_FSを組み込むことで、SUNRPCなどその他必要なオプションも組み込まれます。
<br />
</p>
<pre>Symbol: NFS_FS
Type  : tristate
Prompt: NFS client support
  Defined at fs/nfs/Kconfig:1
  Depends on: NETWORK_FILESYSTEMS &amp;&amp; INET &amp;&amp; FILE_LOCKING
  Location:
    -&gt; File systems
      -&gt; Network File Systems (NETWORK_FILESYSTEMS)
  Selects: LOCKD &amp;&amp; SUNRPC &amp;&amp; NFS_ACL_SUPPORT
</pre>
<p class="paragraph">
&quot;CONFIG_NFS_V3&quot; は組み込まなくとも問題有りませんでした。
<br />
また、今回使用した 2.6.38.2 ではCONFIG_NFS_FSを組み込むと自動的に CONFIG_RPCSEC_GSS_KRB5 (&quot;Secure RPC: Kerberos V mechanism&quot;)も有効化されました。
<br />
</p>

<p class="paragraph">
rootファイルシステムをNFSマウントするためにCONFIG_ROOT_NFSを組み込みます。
<br />
</p>
<pre>Symbol: ROOT_NFS
Type  : boolean
Prompt: Root file system on NFS
  Defined at fs/nfs/Kconfig:90
  Depends on: NETWORK_FILESYSTEMS &amp;&amp; NFS_FS &amp;&amp; IP_PNP
  Location:
    -&gt; File systems
      -&gt; Network File Systems (NETWORK_FILESYSTEMS)
</pre>

<p class="paragraph">
以上のオプションを組み込んだら、&quot;make bzImage&quot;でbzImageをリビルドします。
<br />
出来上がったbzImageは、&quot;bzImageNfs&quot;など区別しやすい名前で &quot;/tftpboot&quot; の下にコピーしておきます。 
<br />
</p>

<h5 id="id8246c6">NFS rootマウントするとき、Buildroot, BusyBox, uClibc側で特別な設定は必要か？</h5>

<p class="paragraph">
Linux Kernelの設定が適切であれば、uClibc, BusyBox, Buildroot側で特別な設定は必要ないようです。
<br />
参考：
<br />
</p>
<ul><li> [Buildroot] [PATCH] docs/howto: add howto for nfsroot<ul><li> <a class="externallink" href="http://lists.busybox.net/pipermail/buildroot/2010-March/032773.html" target="_blank">http://lists.busybox.net/pipermail/buildroot/2010-March/032773.html</a></li></ul></li>
<li> Using Buildroot on Nitrogen ≪ Boundary Devices<ul><li> <a class="externallink" href="http://boundarydevices.com/blogs/using-buildroot-on-nitrogen" target="_blank">http://boundarydevices.com/blogs/using-buildroot-on-nitrogen</a></li></ul></li></ul>

<h4 id="id0bea8e">PXELINUXの設定</h4>

<p class="paragraph">
&quot;/tftpboot/pxelinux.cfg/default&quot; にNFSマウント用のカーネルとカーネルパラメータを指定したエントリを追加します。
<br />
追加分：&quot;append&quot;の行は、実際は折り返し無しで一行で記述します。
<br />
</p>
<pre>label nfs
  kernel bzImageNfs
  append console=ttyS0,115200 console=tty0 \
    root=/dev/nfs rw ip=dhcp nfsroot=192.168.240.10:/opt/nfsexports/root1
</pre>
<p class="paragraph">
&quot;192.168.240.10&quot;は実際のVMwareホストマシン(CentOS5.5)のIPアドレスに読み替えてください。
<br />
</p>

<p class="paragraph">
&quot;ip=&quot;, &quot;nfsroot=&quot;のカーネルパラメータに付いてはカーネルソースの
<br />
</p>
<pre>Documentation/filesystems/nfs/nfsroot.txt
</pre>
<p class="paragraph">
に詳しく書かれています。
<br />
</p>

<p class="paragraph">
&quot;root=/dev/nfs&quot;については、実際に&quot;/dev/nfs&quot;というデバイスノードを作成する必要はありません。単に&quot;NFSrootマウントをします&quot;という印です。
<br />
</p>

<p class="paragraph">
最初のうちは
<br />
</p>
<pre>nfsrootdebug
</pre>
<p class="paragraph">
を追加して、NFSマウントのデバッグメッセージを出力するとよいでしょう：
<br />
</p>
<pre>label nfsdebug
  kernel bzImageNfs
  append console=ttyS0,115200 console=tty0 \
    root=/dev/nfs rw ip=dhcp nfsroot=192.168.240.10:/opt/nfsexports/root1 \
    nfsrootdebug
</pre>


<h4 id="idd7f3f2">動作確認</h4>

<p class="paragraph">
minicomを立ち上げた後、VMware仮想マシンを起動します。
<br />
&quot;boot:&quot;プロンプトが表示されたら、NFSroot用のboot labelを指定してシステムを立ち上げてみます。
<br />
</p>

<p class="paragraph">
全てが成功したときの起動時メッセージの例：(nfsrootdebugパラメータを有効化しています)
<br />
</p>
<ul><li> <a href="./../images/reduced.linux/nfsroot-success.txt" target="_blank" >./../images/reduced.linux/nfsroot-success.txt</a></li></ul>

<h4 id="id11f8f5">NFSrootマウント出来ないときは</h4>

<p class="paragraph">
NFSrootマウントに失敗する場合、いくつかの原因が考えられます。
<br />
これまで解説してきた手順に従っているかもう一度チェックしてみてください。
<br />
</p>

<p class="paragraph">
自分の場合、<strong>ネットワークカードのデバイスドライバを組み込むことに気づかず</strong>、数日を費やしました。
<br />
・・・多くの記事では、どうもこの事が<strong>誰でも気づくような当然の前提として省略されている</strong>ようです。
<br />
</p>

<p class="paragraph">
さらに、「もしかして・・・誰も書いてないけど・・・当たり前すぎて誰も書いてないくらいの前提として・・・ネットワークカードのデバイスドライバを組み込まないと駄目？」とようやく気づいたあとも、「じゃぁどれを組み込めば良いの？」で半日ほど嵌ってしまいました。
<br />
</p>
<pre>CONFIG_PCNET32に気づかない
→ CONFIG_PCI に気づかない
→ 適切なデバイスドライバの選択肢がそもそも make menuconfig で表示されない
→ 以下ループ
</pre>
<p class="paragraph">
という無限地獄に陥り、ようやく抜けだしたのが「そういえば、今までVMwareでLinux使ってきた時って、&quot;pcnet32&quot;モジュールでだいたい上手く動いてたよな」と思い出してからです。そこでようやくCONFIG_PCNET32に辿り着き、そこから全てがスムーズに動き出しました。
<br />
</p>

<p class="paragraph">
ネットワークカードのデバイスドライバを組み込まず、失敗したときの起動時メッセージの例：(nfsrootdebugパラメータを有効化しています)
<br />
</p>
<ul><li> <a href="./../images/reduced.linux/nfsroot-failure.txt" target="_blank" >./../images/reduced.linux/nfsroot-failure.txt</a></li></ul>

<p class="paragraph">
&quot;IP-Config: ...&quot; でちゃんとDHCPからIPアドレスを取得しているか？がポイントになると思います。これが出来ていないと、そもそもネットワークカードを認識していない可能性があります。
<br />
</p>

<p class="paragraph">
本シリーズでは<strong>allnoconfig を出発点として</strong>、最低限必要なkernelオプションを少しずつ組み込んでいくスタイルですので、このように「当たり前すぎてわざわざドキュメントに書く必要すら無い暗黙の前提」を知らずに躓くパターンに注意が必要です。
<br />
・・・というか本シリーズで躓いて時間を取られたのは大体このパターンでした。
<br />
</p>

<h3 id="idaa37b1">その他の参考URL</h3>

<p class="paragraph">
他、VMware + PXEブートなど参考資料：
<br />
</p>
<ul><li> PXE boot with vmware - りおてく<ul><li> <a class="externallink" href="http://www.rio.tc/2006/04/25-072242.php" target="_blank">http://www.rio.tc/2006/04/25-072242.php</a></li></ul></li>
<li> VMwareでゲストOSをネットワークブートするためのメモ - NightWalker の日記<ul><li> <a class="externallink" href="http://slashdot.jp/~NightWalker/journal/347114" target="_blank">http://slashdot.jp/~NightWalker/journal/347114</a></li></ul></li>
<li> ウノウラボ Unoh Labs: Linuxをネットワーク経由で自動インストールする方法（前編）<ul><li> <a class="externallink" href="http://labs.unoh.net/2007/11/linux_1.html" target="_blank">http://labs.unoh.net/2007/11/linux_1.html</a></li></ul></li>
<li> PXEを使ったネットワークブート<ul><li> <a class="externallink" href="http://mitty.jp/pc/networkboot/" target="_blank">http://mitty.jp/pc/networkboot/</a></li></ul></li>
<li> CS411 - PXE Boot in VMware How To<ul><li> <a class="externallink" href="http://cosi.clarkson.edu/docs/pxeboot.html" target="_blank">http://cosi.clarkson.edu/docs/pxeboot.html</a></li></ul></li>
<li> ITmedia エンタープライズ : Linux Tips「ネットワークブートインストールをしたい」<ul><li> <a class="externallink" href="http://www.itmedia.co.jp/help/tips/linux/l0631.html" target="_blank">http://www.itmedia.co.jp/help/tips/linux/l0631.html</a></li></ul></li>
<li> Murao Lab. - ネットブートLinuxシステム構築メモ<ul><li> <a class="externallink" href="http://i.cla.kobe-u.ac.jp/murao/docs/NetbootLinux/index.html" target="_blank">http://i.cla.kobe-u.ac.jp/murao/docs/NetbootLinux/index.html</a></li></ul></li></ul>

<hr />
<p class="paragraph">
ここまでで、FDブート/CDブート/PXEネットワークブートを網羅できました。
<br />
次回は仕上げとして、PXEネットワークブート後にホストマシンからKGDBでターゲットマシンのkernelをデバッグしてみます。
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-953.html" title="技術/Linux/手作りLinuxシステム/04. Boot from CD (kernel-2.6.x)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-959.html" title="技術/Linux/手作りLinuxシステム/06. Boot from Network(PXE + NFS + KGDB) (kernel-2.6.x)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-940.html" title="技術/Linux/手作りLinuxシステム">Up</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-23.html" title="技術">技術</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/958<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2007 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>