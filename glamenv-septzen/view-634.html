<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>技術/歴史/&quot;WindowsOS内部のアーキテクチャのすべて&quot;読書メモ/4章 - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">技術/歴史/&quot;WindowsOS内部のアーキテクチャのすべて&quot;読書メモ/4章</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-04-04 18:13:22 &nbsp; / &nbsp; last updated at: 2010-05-19 22:54:39<br>
カテゴリ: <a href="category-48.html">Assembler</a>&nbsp;<a href="category-8.html">Windows</a>&nbsp;<a href="category-46.html">読書</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-633.html" title="技術/歴史/&quot;WindowsOS内部のアーキテクチャのすべて&quot;読書メモ/1-3章">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-635.html" title="技術/歴史/&quot;WindowsOS内部のアーキテクチャのすべて&quot;読書メモ/5-6章">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-23.html" title="技術">技術</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
&quot;WindowsOS内部のアーキテクチャのすべて&quot;の第４章の要約、読書メモとなります。
<br />
本記事では以降、&quot;WindowsOS内部のアーキテクチャのすべて&quot; を &quot;Windows OS Internal Architecture&quot; として &quot;WOIA&quot; と略します。
<br />
</p>

<a href="https://www.amazon.co.jp/dp/4886487270" target="_blank">Windows OS内部のアーキテクチャのすべて | 前川 武弘 |本 | 通販 | Amazon</a><br>



<ul><li><a href="#idd8a046">(4章) Intel 80286 (16bit時代, 1982 - ) と Windows 3.0/3.1時代</a><ul><li><a href="#idb92ccc">Intel 80286</a><ul><li><a href="#id4453aa">内部レジスタ構成</a></li>
<li><a href="#idae29e5">リアルモードでのアドレス指定とメモリレイアウト</a></li>
<li><a href="#id3b7331">&quot;特権レベル&quot;(Privilege Level)について</a></li>
<li><a href="#id01e6e7">プロテクトモードのアドレス指定(セグメントディスクリプタを使ったセグメント方式)</a></li>
<li><a href="#idb91bb5">プロテクトモードとディスクリプタテーブルのその他の話題について</a></li>
<li><a href="#id3dd6f5">80286のプロテクトモードでも存在した64KBの壁</a></li></ul></li>
<li><a href="#id2342e0">1980年代後半～1990年代前半の Windows2.x/Windows3.x の流れ</a></li>
<li><a href="#id553f05">Windows 3.xのブートシーケンス(WIN.COM + DOSX.EXE/WIN386.EXE)</a><ul><li><a href="#idb23146">Windows 3.x起動完了後のメモリレイアウト</a></li>
<li><a href="#idd68dd9">参考資料</a></li></ul></li>
<li><a href="#id4ccc34">Win16 API</a><ul><li><a href="#id108deb">DPMI(DOS Protected Mode Interface)について</a></li>
<li><a href="#id95d8a3">Win16 APIの登場</a></li>
<li><a href="#idb6f1cc">Windows 3.x における Win16APIの仕組み</a></li>
<li><a href="#ide84b85">KRNL286.EXE/USER.EXE/GDI.EXE の役割分担</a></li>
<li><a href="#id78ea3f">Win16 API とマルチタスクの仕組み</a></li>
<li><a href="#ide26bfa">&quot;Standard Mode&quot; と &quot;386 Enhanced Mode&quot;</a></li>
<li><a href="#id3db315">64KBの壁によるリソース不足</a></li>
<li><a href="#idcd9e8b">まとめ</a></li></ul></li></ul></li>
<li><a href="#idce7d97">メモ：&quot;A20ライン&quot;</a><ul><li><a href="#idd23d15">8086/8088での FFFFFh 以降のアドレスについて</a></li>
<li><a href="#id55d1c4">80286での FFFFFh 以降のアドレスについて</a></li>
<li><a href="#idbad90f">&quot;IBM PC AT&quot; から登場した &quot;A20ゲート&quot;</a></li>
<li><a href="#id96bdda">A20ラインとEMS/XMSの関係</a></li>
<li><a href="#id912e98">参考資料</a></li></ul></li></ul>
<hr />
<h3 id="idd8a046">(4章) Intel 80286 (16bit時代, 1982 - ) と Windows 3.0/3.1時代</h3>

<p class="paragraph">
1982年、アドレスバスを24bitに増やし、プロテクトモードを搭載した 80286が発表される。
<br />
プロテクトモードやセグメントディスクリプタによるアドレス指定、CPUの動作レベル(「特権」「リング０」～「リング３」)についても80286が発祥となっており、まずはIntel 80286の機能について簡単に紹介する。
<br />
続いてWindows3.xを取りあげ、80286上でどのようにプロテクトモードを活用したかをまとめる。
<br />
</p>

<h4 id="idb92ccc">Intel 80286</h4>

<p class="paragraph">
80286のスペック：
<br />
</p>
<table>
	<tr>
		<td> アドレスバス </td>
		<td> 24bit </td>
	</tr>
	<tr>
		<td> 汎用レジスタ </td>
		<td> 16bit </td>
	</tr>
	<tr>
		<td> 外部データバス </td>
		<td> 16bit </td>
	</tr>
	<tr>
		<td> 内部データバス </td>
		<td> 16bit </td>
	</tr>
</table>

<p class="paragraph">
bit幅に注目する限り、アドレスバスが24bitに増えた以外は8086と変わらないように見える。
<br />
しかし80286は以下の２大機能が登場した事で、続く80386の基礎を作った重要なCPUである。
<br />
</p>
<dl>
<dt> プロテクトモード </dt>
<dd>
<p class="paragraph">
24bit(16MB)のアドレス幅全てを使うにはプロテクトモードを使う必要がある。プロテクトモードでは、後述のセグメントディスクリプタを使ったアドレス指定方式により、bit幅の組み合わせ上は(=論理上は)1GBまでのアドレスを16MBの物理メモリに割り当てることが可能になっている。
<br />
プロテクトモードでのメモリや割り込みベクタ管理に必要な&quot;ディスクリプタテーブル&quot;(Descriptor Table)が登場したのも80286からである。
<br />
さらに、プロテクトモードで扱うデータの随所で「Privilege Level」を導入することでCPUの動作レベルを4段階に分け、アクセス出来るメモリや実行可能な命令を動作レベル毎に制限することが可能になった。これこそが「プロテクト」と呼ばれる所以である。
<br />
</p>

<p class="paragraph">
なお、80286ではリアルモードからプロテクトモードへ移行することは出来たがその逆、プロテクトモードからリアルモードへ戻ることは出来なかった（リセットする必要があった）。
<br />
</p></dd>
<dt> マルチタスク機能 </dt>
<dd>&quot;Task State Segment&quot;(TSS)と&quot;Task Register&quot;(TR)により、複数のタスクを切り替えて実行出来るようになった。タスク切り替えのトリガーとしてはソフトウェア割り込みやJMP/CALL/IRETなど。またこれにより、タスク毎のメモリ空間を持てるようになった。</dd>
</dl>

<p class="paragraph">
以下、Web上で入手出来た80286(M80C286)のデータシートに沿いつつ、汎用レジスタの構成や上記新機能の概要と関連する命令セットなどを簡単に紹介していく。
<br />
</p>


<h5 id="id4453aa">内部レジスタ構成</h5>

<p class="paragraph">
基本的に8086/8088のレジスタ構成と同じである。全て16bitで構成されている。
<br />
プロテクトモードやタスク切り替え機能の追加に伴い、&quot;MSW&quot;(Machine Status Word)レジスタが追加されている。
<br />
</p>

<pre class="plugin_pre">
+---------+                     +---------+
| AH | AL |=AX : ACCUMULATOR    |   S P   | STACK POINTER
+---------+                     +---------+
| BH | BL |=BX : BASE           |   B P   | BASE POINTER
+---------+                     +---------+
| CH | CL |=CX : COUNT          |   S I   | SOURCE INDEX
+---------+                     +---------+
| DH | DL |=DX : DATA           |   D I   | DESTINATION INDEX
+---------+                     +---------+

+---------+                     +---------+
|   C S   | CODE SEGMENT        |   I P   | INSTRUCTION POINTER
+---------+                     +---------+
|   D S   | DATA SEGMENT        |   FLAG  | STATUS FLAGS
+---------+                     +---------+
|   S S   | STACK SEGMENT       |   MSW   | MACHINE STATUS WORD
+---------+                     +---------+
|   E S   | EXTRA SEGMENT
+---------+
</pre>

<p class="paragraph">
MSWレジスタは次のような構成になっている。
<br />
</p>
<pre class="plugin_pre">
       15          3    2    1    0
     +----+-   -+----+----+----+----+
MSW: |    | ... | TS | EM | MP | PE |
     +----+-   -+----+----+----+----+

TS : Task Switch
EM : Processor Extnsion Emulator
MP : Monito Processor Extension
PE : Protection Enable
</pre>

<p class="paragraph">
タスク切り替えではTSビットを使い、プロテクトモードへ切り替えるにはPEビットを1にする。初期状態ではPEビットは0、つまりリアルモードで動作するようになっている。
<br />
</p>

<p class="paragraph">
MSWレジスタを読み書きするために、以下の命令が追加されている。
<br />
</p>
<pre>LMSW : Load Machine Status Word from register/memory
SMSW : Store Machine Status Word
</pre>

<p class="paragraph">
その他、プロテクトモードで使われる「ディスクリプタテーブル」のアドレスを格納する為の内部レジスタが複数追加されているが、これらは専用の命令を使って操作するようになっている。
<br />
</p>

<h5 id="idae29e5">リアルモードでのアドレス指定とメモリレイアウト</h5>

<p class="paragraph">
初期状態、つまりリアルモードでのアドレス指定は8086/8088と同じである。
<br />
16bitのセグメントレジスタ(CS, DS, SS, ES)を4bit左シフトしてセグメントアドレスとし、オフセットアドレスと組み合わせる。
<br />
CS, SSレジスタは特定のポインタレジスタと組み合わせる。
<br />
</p>
<pre>CS : Code Segment → IPと組み合わせる。
SS : Stack Segment → SP, BPと組み合わせる。BPからの相対アドレスを指定する時に使われる。
</pre>
<p class="paragraph">
DS, ESレジスタについてはメモリ上のデータを指定する時に汎用的に使われる。
<br />
</p>

<p class="paragraph">
このように大きく「実行コード」「データ」「スタック」の３種類にメモリ領域を分割するCPUの機能は、プログラムの構成にも影響を及ぼしている。特にOSが実行可能ファイルをロードしてメモリ上に展開する際に、実行可能ファイルのフォーマットおよびその解析・展開処理でかならずこの３種類のメモリ領域が関わってくる。
<br />
</p>

<p class="paragraph">
リアルモードでのアドレス指定では、8086/8088と同様にアドレスバスを20bitまでしか使えない。つまり指定可能な物理メモリの上限は1MBのままである。
<br />
</p>

<p class="paragraph">
CPUが関わるメモリレイアウトについては、80286起動時点ではリアルモードであり、8086/8088のメモリレイアウトと同一である。
<br />
0 - 3FFhまでが割り込みベクタとしてCPU予約領域となり、FFFF0hがCPUリセット後に最初にフェッチされる命令のアドレスとなる。
<br />
</p>

<p class="paragraph">
プロテクトモードを利用することで、割り込みベクタ領域を任意の領域に指定することが可能となった。（もちろん、プロテクトモードでも従来通り0 - 3FFhを割り込みベクタ領域として指定出来る）
<br />
</p>

<h5 id="id3b7331">&quot;特権レベル&quot;(Privilege Level)について</h5>

<p class="paragraph">
80286ではアクセスコントロールを強化する為に&quot;特権レベル&quot;(Privilege Level)という仕組みが導入されている。
<br />
メモリアクセスや実行アドレスの切り替え(JMP, CALL, 割り込み)において、CPUの現在の特権レベルと、アクセスするメモリやジャンプ先のアドレスの特権レベルを調べ、適切なアクセスコントロールを行う。また実行出来る命令の種類についても、現在の特権レベルで実行可能な命令かチェックされるようになる。
<br />
</p>

<p class="paragraph">
80286以降では次の4つのレベルが存在する。
<br />
</p>
<pre>レベル0 : &quot;KERNEL&quot;レベル
レベル1 : &quot;SYSTEM SERVICE&quot;レベル
レベル2 : &quot;OS EXTENSIONS&quot;レベル
レベル3 : &quot;APPLICATIONS&quot;レベル
</pre>
<p class="paragraph">
&quot;レベル&quot;は&quot;リング&quot;と呼ばれる時もあり、「リング０」～「リング３」と呼ばれる場合もある。
<br />
</p>

<p class="paragraph">
レベルの数が小さいほど使える機能が多く、アクセス権限も強くなる。レベル0ではCPUの全機能を利用出来る。ハードウェアやCPUの機能の全てにアクセスするOSのカーネル部分は、一般的にレベル0で動作する。ユーザープログラムは一般的にレベル3で動作する。
<br />
レベルの数が大きい特権レベルは、それより数の小さい特権レベルの機能・メモリにはアクセス出来ない。レベル3の状態では、レベル0のメモリにはアクセス出来ない。その逆は可能である。
<br />
</p>

<p class="paragraph">
80286以降のプロテクトモードでは、メモリアドレスが出てくるところでは必ず、後述の「セグメントディスクリプタ」が使われる。セグメントディスクリプタの中にはそのメモリセグメントの特権レベルを表す2bitのフィールドが存在する。メモリアクセスやJMP/CALL/割り込みによりジャンプする場合には、CPUによりセグメントディスクリプタ中の特権レベルが自動的にチェックされることになる。
<br />
</p>

<h5 id="id01e6e7">プロテクトモードのアドレス指定(セグメントディスクリプタを使ったセグメント方式)</h5>

<p class="paragraph">
プロテクトモードにおいても、セグメントレジスタでセグメントを指定し、オフセットを加える仕組みはリアルモードと同じである。しかしセグメントレジスタによるセグメントの指定方式が大きく異なる。
<br />
</p>
<dl>
<dt> Real Mode </dt>
<dd>セグメントレジスタの値により、セグメントアドレスを直接指定していた。</dd>
<dt> Protected Mode </dt>
<dd>セグメントレジスタは「セグメントディスクリプタ(Segment Descriptor)」の番号を指定するようになる。実際の物理アドレスは、指定された「セグメントディスクリプタ」のbitフィールドからCPUが自動的に読み取る。</dd>
</dl>

<p class="paragraph">
セグメントディスクリプタは64bit=8バイトで構成され、以下のようなbitフィールドになっている。
<br />
</p>
<pre class="plugin_pre">
  +--------------+--------------+
7 |         (RESERVED)          | 6
  +--------------+--------------+
5 |P|DPL|S|TYPE|A|BASE (23 - 16)| 4
  +--------------+--------------+
3 |        BASE (15 - 0)        | 2
  +--------------+--------------+
1 |       LIMIT (15 - 0)        | 0
  +--------------+--------------+
 15              7              0
</pre>
<dl>
<dt> BASE (0 - 23) </dt>
<dd>24bit, セグメントの先頭アドレスを物理メモリアドレスで指定する。</dd>
<dt> LIMIT (0 - 15) </dt>
<dd>16bit, セグメントのサイズを指定する。</dd>
<dt> P(Present) </dt>
<dd>1bit, 物理メモリマッピング済フラグ</dd>
<dt> DPL(Descriptor Privilege Level) </dt>
<dd>2bit, セグメントの特権レベル</dd>
<dt> S(Segment Descriptor) </dt>
<dd>1bit, コードorデータセグメントの場合は1, 割り込みハンドラやTSSなどのシステムセグメントの場合は0。</dd>
<dt> TYPE </dt>
<dd>3bit, コード or データセグメントの場合に、セグメントの属性(実行可能やRead/Write)を指定する。</dd>
<dt> A(Accessed) </dt>
<dd>直近アクセスフラグ</dd>
</dl>

<p class="paragraph">
これを必要とするセグメントの分だけ用意した、セグメントディスクリプタの一覧が「<strong>セグメントディスクリプタテーブル(Segment Descriptor Table)</strong>」である。セグメントディスクリプタテーブルは、リアルモードの段階で用意しておき、その先頭アドレスをLGDT(Load Global Descriptor Table)/LLDT(Load Local Descriptor Table)によりCPUに登録しておく。
<br />
LGDT/LLDT命令では、セグメントディスクリプタの領域をBASE+LIMIT形式で指定したメモリ領域を指示する。
<br />
</p>
<pre class="plugin_pre">
LGDT命令の例(LLDTの場合も指定するメモリ領域の構造は同じ)

  +--------------+--------------+
5 |  (RESERVED)  | BASE (23-16) | 4
  +--------------+--------------+
3 |        BASE (15 - 0)        | 2
  +--------------+--------------+
1 |       LIMIT (15 - 0)        | 0 ------&gt; LGDT
  +--------------+--------------+            |
 15              7              0            |
                                             |
メモリ：                                     |
| (...)    |                                 |
+---+------+&lt;------+                         |
|   | DT-n |       |                         |
| G +------+       |   +---[ CPU ]-----------|---------+
|   |  ... |       |   |                     |         |
| D +------+       |   |                     V         |
|   | DT-2 |       |   |  +--------------------------+ |
| T +------+       +------|  GDT LIMIT (16bit = 64KB)| |
|   | DT-1 |           |  +--------------------------+ |
+---+------+&lt;-------------| GDT BASE 24bit物理メモリ | |
| (...)    |           |  +--------------------------+ |
                       +-------------------------------+
</pre>

<p class="paragraph">
CS, DSなどのセグメントレジスタでは、プロテクトモードにおいてはセグメントディスクリプタテーブル上のインデックス番号を使ってセグメントディスクリプタを指定する。セグメントディスクリプタを選択することから、プロテクトモードにおけるCS/SSなどのセグメントレジスタのことを「セレクタ(Selector)」呼ぶ場合もある。
<br />
セレクタの16bitフィールドは、次のような構造になっている。
<br />
</p>
<pre> +-----------+----+-----+
 |   INDEX   | TI | RPL |
 +-----------+----+-----+
15          3    2     0
</pre>

<dl>
<dt> INDEX </dt>
<dd>13bitで8192個のセグメントディスクリプタを指定可能。</dd>
<dt> TI(Table Indicator) </dt>
<dd>グローバルなディスクリプタテーブル(Global Descriptor Table)を使う時は&quot;1&quot;, ローカルなディスクリプタテーブル(Local Descriptor Table)を使う時は&quot;0&quot;</dd>
<dt> RPL(Requested Privilege Level) </dt>
<dd>特権レベル</dd>
</dl>

<p class="paragraph">
以下に、CS(Code Segment)でINDEXが&quot;2&quot;を示した時の、セグメントセレクタとGDTの関係を示す。
<br />
</p>
<pre class="plugin_pre">
| (...)    |
+---+------+
|   | DT-n |
| G +------+
|   |  ... |        Segment Selector (ex: CS, Code Segment)
| D +------+        +-----------+----+-----+
|   | DT-2 |&lt;-------|       |1|0| TI | RPL |
| T +------+        +-----------+----+-----+
|   | DT-1 |       15          3    2     0
+---+------+
| (...)    |
</pre>

<p class="paragraph">
Segment SelecotrのINDEXサイズは13bit、つまり8192個のセグメントディスクリプタを指定出来るのは前述の通りである。
<br />
従って、一つのディスクリプタテーブルには8192個のセグメントディスクリプタが格納出来る。ディスクリプタは一つにつき8バイトなので、一つのディスクリプタテーブルの最大サイズは
<br />
</p>
<pre>8192個 x 8バイト = 65536 = 64KB
</pre>
<p class="paragraph">
となり、丁度LGDT/LLDTで指定可能なディスクリプタテーブルの最大LIMIT値(16bit)と同じになる。
<br />
</p>

<p class="paragraph">
「1GBを16MBの物理メモリにマッピングできる」という表現は、単純に
<br />
</p>
<pre>セグメントセレクタの INDEX フィールド → 13bit
                  同 TIフィールド     →  1bit
                           オフセット → 16bit
</pre>
<p class="paragraph">
の計30bit幅だけ「セグメントセレクタ：オフセット」のbit幅があるので、&quot;論理上は&quot; 1GBを表現出来る、という意味である。
<br />
</p>

<h5 id="idb91bb5">プロテクトモードとディスクリプタテーブルのその他の話題について</h5>

<p class="paragraph">
これまで紹介したのは、主にCS/SS/DS/ESで使われるセグメントを指定する場合のディスクリプタテーブルの構造である。
<br />
80286ではこの他に、割り込みハンドラやタスク切り替えで使われる&quot;System Segment Descriptor&quot;, &quot;Gate Descriptor&quot;というディスクリプタが存在する。割り込みベクタ用に&quot;Interrupt Descriptor Table&quot;を登録することも出来る。これらのディスクリプタテーブルの操作用に&quot;LIDT(Load Interrupt Descriptor Table)&quot;命令などが追加されている。
<br />
</p>

<p class="paragraph">
これらについては、&quot;WOIA&quot;の要約である本記事では取り扱わない。これら割り込みやタスク切り替えに使われる特殊なディスクリプタテーブルについては、OS開発やアセンブラプログラミングの話題に属するからである。
<br />
</p>

<p class="paragraph">
一点だけ注意しておくとしたら、<strong>プロテクトモードでのソフトウェア割り込み(Gate Descriptor)を使うと特権レベルを変更出来る</strong>事だろう。リング3で動作していたプログラムが、ソフトウェア割り込み(INT命令)をかけることでリング0に切り替わり、OSカーネルの機能を実行することができる。80286以降のプロテクトモードに対応したOSでは、基本的にこの仕組みで「システムコール」を実現している。
<br />
</p>

<h5 id="id3dd6f5">80286のプロテクトモードでも存在した64KBの壁</h5>

<p class="paragraph">
アドレスバスが24bitになり、プロテクトモードが導入され、セグメント自体は1MBを超えて16MBまでに配置することが出来るようになった。
<br />
しかし<strong>オフセットを指定する汎用レジスタ群が16bitのままだった</strong>ため、80286の時点でも「一セグメントあたり64KBの壁」は存在している。
<br />
これは80286対応のWindows 3.xのメモリ管理方式に影響を与えている。
<br />
</p>

<p class="paragraph">
以上で80286プロテクトモードに関する必要な予備知識はまとめ終えた。いよいよ、1980年代後半～1990年代前半の流れとからめてWindows 3.xの内部構造を俯瞰していく。
<br />
</p>

<h4 id="id2342e0">1980年代後半～1990年代前半の Windows2.x/Windows3.x の流れ</h4>

<p class="paragraph">
1980年代後半～1990年代前半は、8086/8088/80286/80386(1988年発売)搭載マシンが同時に存在した時代であり、OSもDOS/Windows2.x/Windows3.xが矢継ぎ早に発表されると同時に次々と新バージョンが投入、なおかつ旧バージョンもまだまだ現役というめまぐるしい時代だった。1987年には386DXを搭載した IBM Personal System/2 Model 80 (8580-xx) が発売されている。
<br />
</p>

<p class="paragraph">
なお、Windows3.x以前まではMS-DOSの拡張製品として販売されていた為、MS-DOSとWindowsをそれぞれ購入する必要があった。
<br />
</p>

<dl>
<dt> Windows 2.10 </dt>
<dd>1988年発表。当初は80286対応だったが、後に80386にも対応する。80286に対応した版が&quot;Windows/286&quot;, 80386に対応した版が&quot;Windows/386&quot;という名前に変更される。HIMEM.SYS登場により、HMAおよびXMSが公式に対応される。</dd>
<dt> Windows 2.11 </dt>
<dd>
<p class="paragraph">
1989年発表。Windos 2.10のマイナーアップデート版。
<br />
ここでWindows 2.x系列について少しだけ整理しておく。
<br />
</p>
<ol><li> Windows 2.0は元々8086/8088に対応しており、ハードウェアタイプのEMSを利用出来る、リアルモードのプログラムだった。</li>
<li> Windows 2.10以降は Windows/286, Windows/386と分岐した。</li>
<li> Windows/286については Windows 2.0 と同様リアルモードのプログラムだったようだ。しかしHIMEM.SYSの導入でHMA/XMSが使えるようになるなど、一部80286のプロテクトモードの機能の活用が始まっている。</li>
<li> Windows/386は、MS-DOSアプリを仮想86機能でマルチタスクで動作出来るようになってたらしい。Windows用のアプリケーションについては、アプリ自身が制御をOSに戻す協調型マルチタスク(ノンプリエンプティブ)になっていた。この棲み分けはWindows3.xに引き継がれている。また、ソフトウェアエミュレーションタイプのEMSが利用出来るようになっている。</li></ol></dd>
<dt> Windows 3.0 </dt>
<dd>
<p class="paragraph">
1990年発表。CPUに応じた三つのモードで動作するようになっていた。
<br />
</p>
<ol><li> 8086/8088用 &quot;Real Mode&quot; : リアルモードで動作する。</li>
<li> 80286用 &quot;Standard Mode&quot; : 80286のプロテクトモードを利用する。</li>
<li> 80386用 &quot;386 Enhanced Mode&quot; : 80386のプロテクトモードおよび仮想86機能を利用する。</li></ol>

<p class="paragraph">
HIMEM.SYSがXMS仕様2.0に対応。EMM386.SYS導入。
<br />
</p></dd>
<dt> Windows 3.1 </dt>
<dd>1992年発表。この時点で80286以上、80386が推奨になり、<strong>8086/8088用のリアルモードが無くなった。</strong>日本語版Windows 3.1では80286対応も外され、Standard Modeでも80386以降が必須となった。HIMEM.SYSがXMS仕様3.0に対応。EMM386.EXE導入。</dd>
</dl>


<p class="paragraph">
Windows 2.x/3.x/95に至まで、基本的にはまずDOSが立ち上がり、その後Windowsが起動する仕組みになっている。この場合、HIMEM.SYSはDOSカーネルをExtended Memory(HMA含む)以降にロードするだけの役割である。しかしEMM386についてはプロテクトモードのメモリを操作する為、Windows3.0のStandard Modeと競合してしまう。このためEMM386.SYS/EMM386.EXEはWindowsを使う時は無効化する必要があった。
<br />
</p>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> Cannot Use EMM386.SYS/EMM386.EXE in Standard Mode Windows 3.0<ul><li> <a class="externallink" href="http://support.microsoft.com/kb/82081/EN-US/" target="_blank">http://support.microsoft.com/kb/82081/EN-US/</a></li></ul></li></ul>

<p class="paragraph">
以降はWOIAに沿ってWindows3.xの構造を追っていくが、こうしてWindows2.xまで俯瞰してみると、Windows/386をベースにWindows3.xが出来たようにも見えてくる。協調型マルチタスクや、仮想86機能によるDOSアプリのマルチタスク機能についてはWindows/386がベースとなっているようだ。
<br />
</p>


<h4 id="id553f05">Windows 3.xのブートシーケンス(WIN.COM + DOSX.EXE/WIN386.EXE)</h4>

<p class="paragraph">
Windows 3.xまではMS-DOSと別で販売されていた。このため、パソコンを起動して最初に立ち上がるのはあくまでもリアルモードのMS-DOSであった。
<br />
Windowsを立ち上げるには、MS-DOSのコマンドプロンプトから<strong>&quot;WIN.COM&quot;</strong>を実行する。
<br />
WIN.COMが実行されると、CPUが80286の場合は<strong>DOSX.EXE</strong>というプログラムを実行し、CPUが80386以上の場合は<strong>WIN386.EXE</strong>が実行される。以降は80286用である&quot;DOSX.EXE&quot;について話を進める。
<br />
</p>
<pre>MS-DOS -&gt; &quot;WIN.COM&quot; --+-- 80286 --&gt; &quot;DOSX.EXE&quot; ---&gt; 286版のWindows 3.xが起動
                      |
                      +-- 80386 --&gt; &quot;WIN386.EXE&quot; -&gt; 386版のWindows 3.xが起動
</pre>

<p class="paragraph">
WIN.COMまではCPUはMS-DOS、つまりリアルモードで動作している。DOSX.EXEが実行されると、その内部でPEビットをONにし、プロテクトモードに移行する。同時に各種セグメントディスクリプタテーブルを作成・登録し、プロテクトモードでのメモリ管理の準備を整える。
<br />
なお、Windows全般(Win3.x/9x/NT/2000以降含む)でシステム起動時にセグメントディスクリプタテーブルを作成し、登録している。
<br />
</p>

<p class="paragraph">
DOSX.EXEは引き続きメモリ上に常駐するが、その特権レベルは0、つまりリング0で動作することになる。
<br />
</p>

<h5 id="idb23146">Windows 3.x起動完了後のメモリレイアウト</h5>

<p class="paragraph">
Windows 3.x起動完了後のメモリレイアウトは次のようになっている。
<br />
</p>
<pre class="plugin_pre">
+---------------------------+ 16MB
| Win16アプリケーション領域 |
+---------------------------+
| Windows 3.x システム      |
| (DOSX.EXE, 他)            |
+---------------------------+ 1MB
| VRAM/ROM/BIOS領域         |
+---------------------------+ 640KB
| (ユーザ領域)              |
| Win16API                  |
| (KRNL286,USER,GDI)        |
+---------------------------+
| MS-DOSシステム領域,       |
| 割り込みベクタ            |
+---------------------------+ 0KB
</pre>

<h5 id="idd68dd9">参考資料</h5>

<ul><li> WIN.COM<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/WIN.COM" target="_blank">http://en.wikipedia.org/wiki/WIN.COM</a></li></ul></li>
<li> Windows 95/98 Win.com Command-Line Switches<ul><li> <a class="externallink" href="http://support.microsoft.com/kb/142544/EN-US/" target="_blank">http://support.microsoft.com/kb/142544/EN-US/</a></li></ul></li></ul>

<h4 id="id4ccc34">Win16 API</h4>

<p class="paragraph">
Windows 3.xになり、これまでのソフトウェア割り込みによるシステムコールに代わり、&quot;Win16 API&quot;という仕組みが広く使われるようになった。以降、WindowsアプリケーションはOSの機能を使うにはこの &quot;Win16 API&quot; (プログラミングレベルでは、Microsoftが提供するライブラリ関数として呼び出す)を使うことになる。
<br />
</p>

<h5 id="id108deb">DPMI(DOS Protected Mode Interface)について</h5>

<p class="paragraph">
Win16APIに話を進める前に、DPMIについて簡単に触れておく。
<br />
</p>

<p class="paragraph">
1984年頃からメモリ不足を解消する為に様々な技術仕様とプログラムが開発された。当初はバンク切り替え方式の専用メモリカードを使ったExpanded Memoryとそのデバイスドライバが使われていたが、1984年の時点で既に80286を搭載したIBM PC ATが発売されており、翌1985年には80386が発表されている。つまりプロテクトモードによる1MBを超えるメモリアクセスが技術的には可能となっていた。1987年、80286以降のプロテクトモードでアクセス出来るメモリを使う為の技術仕様、EMS 4.0 (Lotus, Intel, Microsoft, AST合同)が策定される。このころからプロテクトモードの機能を使ってDOSを拡張する、&quot;DOS extender&quot;と呼ばれるタイプのソフトウェアが広まっていく。
<br />
</p>

<p class="paragraph">
しかし80386以降の仮想86機能を使ったEMSでは、既存の&quot;DOS extender&quot;と共存させる上で幾つかの問題が発生した。
<br />
Wikipediaより抜粋：
<br />
</p>
<ul><li> MS-DOSが仮想86モードで動作しているために、リアルモードからプロテクトモードへの切替えを想定されて開発されたDOSエクステンダは、特権命令を使用できないためプロテクトモードへ切替える方法が無かった。</li>
<li> ソフトウェアEMSが全てのプロテクトメモリを獲得してしまうためにDOSエクステンダが利用可能なプロテクトメモリが存在しなかった。</li>
<li> プロテクトモード環境下では、割り込みコントローラーはリアルモードと異なる設定をしなくてはならないが、標準的な管理方法が無かった。</li></ul>

<p class="paragraph">
これらの問題を解決して、仮想86機能によるEMSとDOS extenderを共存させる為の技術仕様が、 Quarterdeck Office Systems と Phar Lap Software, Inc. の間で策定された。
<br />
これが1989年発表の &quot;Virtual Control Program Interface&quot;, VCPI, Version 1.0 である。EMS 4.0 規格の int 67h ファンクションコールを拡張する形でEMSマネージャーにVCPI サーバが実装された。
<br />
しかしVCPIを使ったプログラムではプロテクトモードでもリング0で動いてしまうという問題があったり、翌1990年に発表されたWindows 3.0の386 enhancedモードではVCPIがサポートされなかった事情もあり、Windows 3.0で実装されたDPMIに押される形でVCPIは廃れていってしまう。
<br />
</p>

<p class="paragraph">
&quot;DOS Protected Mode Interface&quot;(DPMI)とは、DOSプログラムがプロテクトモードで動作し、プロテクトモードで提供される機能を利用する為の技術仕様である。
<br />
1989年にドラフト(草案)が発表され、1990年にVersion 0.9が発表される。同年、DPMI 0.9を実装したWindows 3.0が発表される。
<br />
1991年に0.9で不足していた部分を解消したVersion 1.0が発表されたが、Microsoftは対応していない。そのため、多くのDPMIベースのDOS extenderもVersion 0.9に準拠した。
<br />
</p>

<p class="paragraph">
VCPIはINT 61hをベースに拡張しているが、DPMIはINT 31hを中心として拡張しており、仕様的には別系統に属する。
<br />
DPMIは基本的に仮想86機能を使ってDOSアプリケーションをプロテクトモードで動作させるが、部分的にプロテクトモードで動作させることも仕様としては可能だった。そのため「DPMI = 仮想86機能」というのは若干不正確に思われる。
<br />
</p>

<p class="paragraph">
またDPMIでは「クライアント・サーバー」という図式がより明確化された。例えば、DPMI 0.9の仕様書には次のような図が掲載されており、Client/Serverという関係を強く印象づけている。
<br />
</p>
<pre class="plugin_pre">
  Figure 1.  Application/Extender/Client/Host/OS structure

  +----------------------------------------------------------+
  |                                                          |
  |  +----------------------------------------------------+  |
  |  |                                                    |  |
  |  |                  Application Code                  |  |
  |  |                                                    |  |
  |  +----------------------------------------------------+  |
  |                                                          |
  |  +----------------------------------------------------+  |
  |  |           Extender Base (including APIs)           |  |
  |  | -------------------------------------------------- |  |
  |  |    DPMI                                            |  |
  |  |   client                                           |  |
  |  +------------+                                       |  |
  |               |    VCPI                               |  |
  |               |   client                              |  |
  |               +------------+                          |  |
  |                            |    XMS                   |  |
  |                            |   client                 |  |
  |                            +------------+             |  |
  |                                         |  Top-down   |  |
  |                                         |   client    |  |
  |                                         +-------------+  |
  |                                                          |
  +----------------------------------------------------------+

     +------------+
     |            |
     |            |
     |            |------------+
     |            |            |
     |    DPMI    |            |
     |    host    |    VCPI    |------------+
     |            |            |            |
     |            |            |            |
     |            |------------|    XMS     |-------------+
     |            |    EMS     |            |  Top-down   |
     |            |            |            |  (Int 15h)  |
     +----------------------------------------------------+

     +----------------------------------------------------+
     |                                                    |
     |             Operating System (e.g. DOS)            |
     |                                                    |
     +----------------------------------------------------+
</pre>
<p class="paragraph">
上図で&quot;OS&quot;部分が&quot;e.g. DOS&quot;とあるとおり、OSとしてDOSだけを想定していたわけではない（事実、最初の実装はWindows 3.0）。
<br />
DPMIをコールするアプリケーション(DPMI Client)側からは特にOSを意識することはなく、DPMIを実装したDOS extenderあるいはOS(Windows)がDPMI Server(host)として実際の処理を行う。そう言う意味では、DPMIはプロテクトモードのメモリ管理や機能に特化した仮想環境と呼ぶことも可能である。
<br />
</p>

<p class="paragraph">
参考資料：
<br />
</p>
<ul><li> Using VCPI Programs with Windows<ul><li> <a class="externallink" href="http://support.microsoft.com/kb/81493/EN-US/" target="_blank">http://support.microsoft.com/kb/81493/EN-US/</a></li></ul></li>
<li> INFO: The Windows Developer&#039;s Notes<ul><li> <a class="externallink" href="http://support.microsoft.com/kb/65260/EN-US/" target="_blank">http://support.microsoft.com/kb/65260/EN-US/</a></li></ul></li>
<li> FILE: Windows Int 21h and NetBIOS Support for DPMI<ul><li> <a class="externallink" href="http://support.microsoft.com/kb/65128/EN-US/" target="_blank">http://support.microsoft.com/kb/65128/EN-US/</a></li></ul></li></ul>

<p class="paragraph">
Wikipediaショートカット：
<br />
</p>
<ul><li> VCPI:<ul><li> <a class="externallink" href="http://ja.wikipedia.org/wiki/VCPI" target="_blank">http://ja.wikipedia.org/wiki/VCPI</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Virtual_Control_Program_Interface" target="_blank">http://en.wikipedia.org/wiki/Virtual_Control_Program_Interface</a></li></ul></li>
<li> DPMI:<ul><li> <a class="externallink" href="http://ja.wikipedia.org/wiki/DPMI" target="_blank">http://ja.wikipedia.org/wiki/DPMI</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/DOS_Protected_Mode_Interface" target="_blank">http://en.wikipedia.org/wiki/DOS_Protected_Mode_Interface</a></li></ul></li></ul>

<h5 id="id95d8a3">Win16 APIの登場</h5>

<p class="paragraph">
&quot;Win16 API&quot;は16bitプログラム用の実装であり、&quot;Win16&quot;という呼称も&quot;Win32&quot;が登場してから付けられたようだ。
<br />
Windows 1.0の時代から存在していたらしく、Windows 1.0の時点で &quot;GetMessage()&quot;, &quot;GlobalAlloc()&quot; 等のAPIが提供されていたようだ。
<br />
しかし、<strong>Windows 2.0までは明らかにリアルモードのOSであり、</strong>プロテクトモードのメモリ管理や特権レベル機能を活用した構造にはなっていない。
<br />
Windows 3.xになって前述のDPMIに沿った形に整理された。
<br />
</p>

<p class="paragraph">
参考資料：
<br />
</p>
<ul><li> History of the Windows API<ul><li> <a class="externallink" href="http://web.archive.org/web/20020802081510/http://www.iseran.com/Win32/FAQ/history.html" target="_blank">http://web.archive.org/web/20020802081510/http://www.iseran.com/Win32/FAQ/history.html</a></li></ul></li>
<li> Windows API - Wikipedia<ul><li> <a class="externallink" href="http://ja.wikipedia.org/wiki/Windows_API" target="_blank">http://ja.wikipedia.org/wiki/Windows_API</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Winapi" target="_blank">http://en.wikipedia.org/wiki/Winapi</a></li></ul></li></ul>

<h5 id="idb6f1cc">Windows 3.x における Win16APIの仕組み</h5>

<p class="paragraph">
MS-DOSまではCPUのソフトウェア割り込みを使ってMS-DOS.SYSの提供するOSの機能を呼び出していた（「システムコール」or「ファンクションコール」）。
<br />
一方のWin16 API、特に80286以降に対応したWindows 3.xにおいては、次のような仕組みになっている。
<br />
</p>
<ol><li> アプリケーションがWin16APIを呼び出すと、APIの種類応じてKRNL286.EXE/USER.EXE/GDI.EXEの機能が呼ばれる。ここまではCPUの特権レベルはリング３で、まだCPUのメモリ管理やハードウェアに関わる命令は使えない。</li>
<li> KRNL286.EXEなどのWin16APIの実体プログラムは、DPMIクライアントとしてDPMIシステムコールを発行する。</li>
<li> これにより特権レベル0, リング0で動作しているDOSX.EXEなどのカーネルプログラムに制御が移り、DPMI Server or Hostとしてセグメントの割り当てやハードウェア制御を行う。</li></ol>

<pre class="plugin_pre">
+--------------------------+
| Win16 API Application    |&lt;-- RING-3
+--------------------------+
             |
             V
+--------------------------+
| Win16 API (=DPMI Client) |&lt;-- RING-3
| (KRNL286.EXE, USER.EXE,  |
| GDI.EXE, その他)         |
+--------------------------+
             |
        [DPMI CALL]
             |
             V
+--------------------------+
| Windows 3.x Kernel       |&lt;-- RING-0
| (=DPMI Server/Host)      |
| (DOSX.EXE, 他)           |
+--------------------------+
             |
             V
+--------------------------+
| CPU, Hardwares           |
+--------------------------+
</pre>

<h5 id="ide84b85">KRNL286.EXE/USER.EXE/GDI.EXE の役割分担</h5>

<dl>
<dt> KRNL286.EXE </dt>
<dd>メモリ管理・ファイル入出力などOSのコア部分</dd>
<dt> USER.EXE </dt>
<dd>GUIコンポーネント管理など。グラフィック描画やファイル入出力に関わる部分はKRNL286.EXE/GDI.EXEに委譲する。</dd>
<dt> GDI.EXE </dt>
<dd>グラフィックコントローラに対する文字・図形の描画命令を担う。</dd>
</dl>

<p class="paragraph">
ファイルやネットワーク入出力(KRNL286.EXE), グラフィックコントローラへの描画命令(GDI.EXE)は、OSが直接ハードウェアとやり取りするわけではなく、デバイスドライバが間に入る格好になる。
<br />
</p>

<h5 id="id78ea3f">Win16 API とマルチタスクの仕組み</h5>

<p class="paragraph">
Windows 3.xまでは、アプリケーションがOSに制御を戻すことでマルチタスクを実現する「協調型マルチタスク」（ノンプリエンプティブ）になっていた。
<br />
アプリケーションＡ～Ｃが動いていた時、もしもアプリケーションＢがハングアップしてしまいOSに制御を戻さなかった場合は、アプリケーションＡ、Ｃには永久に制御が渡らなくなってしまう。つまりどれか一つでもハングアップしてしまうと、他のアプリはもとよりOSにも制御が渡らなくなり、システム全体がハングアップしてしまう。
<br />
</p>

<p class="paragraph">
Windows9x以降はOS側が強制的に実行権を取得し、一つのアプリケーションがハングアップしても他のアプリやOSに制御が戻せるような、「プリエンプティブマルチタスク」になっている。
<br />
</p>

<h5 id="ide26bfa">&quot;Standard Mode&quot; と &quot;386 Enhanced Mode&quot;</h5>

<p class="paragraph">
Windows 3.xでは搭載するCPUによって3種類のモードが提供されていた。
<br />
</p>
<dl>
<dt> Real Mode </dt>
<dd>8086/8088で動作する。Windows 3.1で廃止された。</dd>
<dt> Protected Mode (スタンダードモード) </dt>
<dd>
<p class="paragraph">
80286で動作する。
<br />
</p>
<ul><li> &quot;WIN.COM&quot; から &quot;DOSX.EXE&quot; が実行される。</li>
<li> &quot;KRNL286.EXE&quot;が使われる。</li>
<li> 仮想86機能による安全なMS-DOS実行環境は提供されていない。</li></ul></dd>
<dt> 386 Enhanced Mode (エンハンスモード) </dt>
<dd>
<p class="paragraph">
80386で動作する。
<br />
</p>
<ul><li> &quot;WIN.COM&quot; から &quot;WIN386.EXE&quot; が実行される。</li>
<li> &quot;KRNL386.EXE&quot;が使われる。</li>
<li> 仮想86機能による安全なMS-DOS実行環境が使える。</li></ul></dd>
</dl>

<h5 id="id3db315">64KBの壁によるリソース不足</h5>

<p class="paragraph">
80286においては、プロテクトモードによりセグメントを16MBまでの領域に配置することが出来た。しかしオフセットが16bitのままだったので、1セグメント64KBの壁は存在していた。
<br />
これにより、Win16アプリケーションにおいても64KBの壁が存在していた。
<br />
</p>

<p class="paragraph">
問題になったのはKRNL286.EXE/USER.EXE/GDI.EXEも64KBの壁に縛られていた点で、マルチタスクにより複数のWin16アプリケーションが動作する場合、その分だけのリソースがKRNL286.EXE/USER.EXE/GDI.EXEの各64KB内で埋まってしまう。
<br />
各64KBの中で複数アプリのリソースをやりくりしなければならなかったため、リソース不足が頻繁に発生した。
<br />
</p>

<h5 id="idcd9e8b">まとめ</h5>

<p class="paragraph">
このように80286のプロテクトモードを利用した Windows 3.x (Standard Mode)はDPMIを活用したユーザー空間とOS空間の分離モデルを定着させた。しかし64KBの壁により、リソース不足による不安定を招いた。
<br />
</p>

<p class="paragraph">
この後登場する80386により、64KBの壁が打破されると共に仮想86機能によるDOSプログラムの完全な分離が実現される。また、Windows9xにおいてはWindows NTから移植されたWin32APIが導入されると共に、プリエンプティブマルチタスクが実現される。これには80386で登場する仮想メモリ機能が活用されている。
<br />
</p>

<h3 id="idce7d97">メモ：&quot;A20ライン&quot;</h3>

<p class="paragraph">
80286のメモリアドレスの指定では、アドレスバスの21bit目、A0から数えると &quot;A20&quot; ラインに注意する必要がある。A20ラインについてまとめる前に、8086/8088でのアドレス指定における&quot;bug&quot;について紹介する。
<br />
</p>

<h4 id="idd23d15">8086/8088での FFFFFh 以降のアドレスについて</h4>

<p class="paragraph">
8086/8088のアドレスバスは20bit、つまり FFFFFh (1MB)がアドレスバスに出力可能な最大値である。
<br />
その指定方法は、セグメント16bit, オフセット16bit でセグメントを4bit左シフトして「加算」する方式だった。
<br />
しかし、加算した結果が FFFFFh を超える「セグメント：オフセット」の組み合わせが発生してしまった。
<br />
</p>
<pre>(A) 丁度 FFFFFh =&gt; FFFFh:000Fh → FFFF0h + Fh = FFFFFh
(B) FFFFFhを&quot;1&quot;over =&gt; FFFFFh:0010h → FFFF0h + 10h = 100000h = FFFFFh + 1h
</pre>

<p class="paragraph">
8086/8088では、繰り上がったbitを無視して20bit分だけを使う仕組みになっていた。上記 (B) のようなケースでは、繰り上がった21bit目を無視し、全体を&quot;00000h&quot;、つまり0番地アドレスとして物理メモリにアクセスしてしまう。これをbugと見なす資料もある。
<br />
</p>

<p class="paragraph">
この仕組みを利用して、一部のDOSプログラムには FFFFFh 以降のアドレス指定により、物理メモリ先頭の 0 - 64KB 空間を使うものが存在した。EMSの仕組みを使うよりも高速にKB単位のメモリ空間にアクセス出来た事が理由である。
<br />
</p>

<h4 id="id55d1c4">80286での FFFFFh 以降のアドレスについて</h4>

<p class="paragraph">
80286になりアドレスバスは24bitに拡張された。するとこれまで
<br />
</p>
<pre>FFFFh:0010h
</pre>
<p class="paragraph">
で &quot;00000h&quot; と扱われてきたアドレスが、21bit目以降も認識されて本来の &quot;100000h&quot; として物理メモリにアクセス出来るようになった。
<br />
ところが、8086/8088の動作を期待していたDOSプログラムからすればまるで見当違いのアドレスにアクセスしてしまうことになり、80286で動作しなくなるアプリケーションが出てきてしまった。
<br />
</p>

<p class="paragraph">
80286は8086/8088と互換性を重視して開発されたが、21bit目以降の扱い(&quot;bug&quot;)までは互換性が維持されていなかった。
<br />
</p>

<h4 id="idbad90f">&quot;IBM PC AT&quot; から登場した &quot;A20ゲート&quot;</h4>

<p class="paragraph">
80286を採用した&quot;IBM PC AT&quot;でも、この非互換性が問題になった。最も単純な解決方法は21bit目以降を物理的に遮断することで、物理的に20bitに丸めてしまう方法だった。これにより8086/8088と同じ挙動になり、互換性は保たれる。
<br />
もう一つの解決方法としては、21bit目の有効・無効を何らかの仕組みで切り替えられるようにすることだった。この方法であれば、8086/8088互換モードと80286本来のアドレッシングモードを、排他的ではあるが両方使うことが出来る。
<br />
</p>

<p class="paragraph">
そこでIBMのエンジニアは、キーボードコントローラ8042の未使用pinを、ANDロジックで21bit目に接続した。
<br />
</p>
<pre class="plugin_pre">
[CPU]                   [RAM]
A0  -------------------&gt; A0
(...)
A19 -------------------&gt; A19
A20 ----+
        |   +-----+
        +--&gt;|     |
            | AND |----&gt; A20
        +--&gt;|     |
        |   +---- +
        |
    +---+---------+
    | Keyboard    |
    | Controller  |
    |  (8042)     |
    +-------------+
A21 -------------------&gt; A21
(...)
</pre>
<p class="paragraph">
初期状態では8042のANDロジックに繋がっているpinは0になっているため、8086/8088互換のアドレッシングモードになっている。プログラム側でI/Oポートを操作してpinを1にすると、80286本来のアドレッシングモードになる。
<br />
</p>

<p class="paragraph">
これが、&quot;A20ゲート&quot;と呼ばれる機構の始まりである。以降、メーカーによってはBIOSのinterruptや独自のI/Oポートで切り替えられるようにしたり様々に対応する。この結果、A20ゲートの切り替えは機種依存になってしまったが、特に統一されることなく現在に続いている。
<br />
</p>

<h4 id="id96bdda">A20ラインとEMS/XMSの関係</h4>

<p class="paragraph">
EMS4.0の段階では、EMSはA20ゲートを意識していない。もともと8086/8088時代のメモリ拡張仕様であるため、仕様としてはA20ラインは考慮されていない。一方のXMSでは、当初からHMAの利用を目的としていたこともあり、少なくともXMS2.0の段階でA20の切り替えが仕様に盛りこまれている。
<br />
</p>

<p class="paragraph">
80286以降のプロテクトモードのメモリ管理を活用するDOS extender、およびDPMIでもA20の切り替え機能が取り込まれている。OS開発という見地では、x86のプロテクトモードを使う為にはA20ゲートの有効化が必須となる。
<br />
</p>

<h4 id="id912e98">参考資料</h4>

<ul><li> X86 Assembly/16 32 and 64 Bits (X86アセンブラ/16、32、64ビット)<ul><li> <a class="externallink" href="http://en.wikibooks.org/wiki/X86_Assembly/16_32_and_64_Bits" target="_blank">http://en.wikibooks.org/wiki/X86_Assembly/16_32_and_64_Bits</a></li>
<li> <a class="externallink" href="http://ja.wikibooks.org/wiki/X86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%A9/16%E3%80%8132%E3%80%8164%E3%83%93%E3%83%83%E3%83%88" target="_blank">http://ja.wikibooks.org/wiki/X86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%A9/16%E3%80%8132%E3%80%8164%E3%83%93%E3%83%83%E3%83%88</a></li></ul></li>
<li> A20関連<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/A20_line" target="_blank">http://en.wikipedia.org/wiki/A20_line</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/A20_handler" target="_blank">http://en.wikipedia.org/wiki/A20_handler</a></li>
<li> <a class="externallink" href="http://www.win.tue.nl/~aeb/linux/kbd/A20.html" target="_blank">http://www.win.tue.nl/~aeb/linux/kbd/A20.html</a></li>
<li> <a class="externallink" href="http://www.openwatcom.org/index.php/A20_Line" target="_blank">http://www.openwatcom.org/index.php/A20_Line</a></li></ul></li>
<li> A20をONにするためのアセンブラコードSample<ul><li> <a class="externallink" href="http://www.visopsys.org/osdev/sources/enableA20.html" target="_blank">http://www.visopsys.org/osdev/sources/enableA20.html</a></li></ul></li></ul>

<ul><li> LOTUS(R)/INTEL(R)/MICROSOFT(R) EXPANDED MEMORY SPECIFICATION [1] Version 4.0</li>
<li> eXtended Memory Specification (XMS), ver 2.0</li>
<li> eXtended Memory Specification (XMS), ver 3.0</li>
<li> DPMI Version 0.9 仕様書</li></ul>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-633.html" title="技術/歴史/&quot;WindowsOS内部のアーキテクチャのすべて&quot;読書メモ/1-3章">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-635.html" title="技術/歴史/&quot;WindowsOS内部のアーキテクチャのすべて&quot;読書メモ/5-6章">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-23.html" title="技術">技術</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/634<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2001 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" target="_blank" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>