<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>C言語系/C++/R0625 &quot;pure virtual function call&quot; と __purecall - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">C言語系/C++/R0625 &quot;pure virtual function call&quot; と __purecall</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2011-01-11 14:32:45 &nbsp; / &nbsp; last updated at: 2011-01-11 14:48:43<br>
カテゴリ: <a href="category-10.html">C言語</a>&nbsp;<a href="category-8.html">Windows</a>&nbsp;<a href="category-12.html">プログラミング</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-494.html" title="C言語系/00_参考資料">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-535.html" title="C言語系/NetBSD1.6における setjmp(), longjmp() の実装">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
&quot;The Old New Thing&quot; p280-282で&quot;__purecall&quot;について紹介されている。 <a href="./view-615.html" >C言語系/呼び出し規約/x86</a> をまとめたこともあり、&quot;XXYYcall&quot;とくれば呼び出し規約のことか、と思ったが違うらしい。
<br />
ということでずっと気になっていたんですが、この度ようやくもやもやが晴れました。&quot;__purecall&quot;というよりはC++の実行時エラー R6025 &quot;pure virtual function call&quot; の方で有名になっているようです。
<br />
</p>

<p class="paragraph">
「実行時エラー」というあたりから、バグとしてはかなり厄介な印象を受けます。
<br />
で、この厄介なバグを回避するための結論を先に書いてしまうと<strong>「コンストラクタやデストラクタの中で仮想関数を呼ない」</strong>というのが複数箇所で書かれています。&quot;The Old New Thing&quot;の&quot;What is __purecall?&quot;記事で書かれていますし、&quot;C++プログラミングの処方箋&quot;(翔泳社, Stephen C.Dewhurust, 初版第一刷)の「鉄則75 コンストラクタとデストラクタにおける仮想関数の呼び出し」にも書かれています。
<br />
</p>

<p class="paragraph">
本記事では「コンストラクタやデストラクタの中で仮想関数を呼ない」の理論面について簡単に紹介し、実際にR6025が発生するサンプルコードを示し、アセンブラリストや実行時の内部データ構造を追うことで&quot;__purecall&quot;との関連を調べていきます。
<br />
</p>

<p class="paragraph">
環境：
<br />
</p>
<pre>OS: Windows 7 Professional 日本語版, 32bit
CPU: Intel Core i3
RAM: 4GB

Visual C++ 2008 Express Edition SP1
cl: Microsoft(R) 32-bit C/C++ Optimizing Compiler Version 15.00.30729.01 for 80x86
link: Microsoft (R) Incremental Linker Version 9.00.30729.01
</pre>

<p class="paragraph">
参考図書：
<br />
</p>
<a href="https://www.amazon.co.jp/dp/4798119768" target="_blank">独習C++ 第4版 | ハーバート・シルト, 神林 靖, トップスタジオ |本 | 通販 | Amazon</a><br>
<a href="https://www.amazon.co.jp/dp/4798106321" target="_blank">Amazon.co.jp: C++プログラミングの処方箋 (Programmer&#039;s foundations) : スティーブン・C. デューハースト, Dewhurst,Stepehn C., エイムネクスト: 本</a><br>

<p class="paragraph">
参考URL：
<br />
</p>
<ul><li> What is __purecall? - The Old New Thing<ul><li> <a class="externallink" href="http://blogs.msdn.com/b/oldnewthing/archive/2004/04/28/122037.aspx" target="_blank">http://blogs.msdn.com/b/oldnewthing/archive/2004/04/28/122037.aspx</a></li></ul></li>
<li> Debugging walkthrough: Diagnosing a __purecall failure - The Old New Thing<ul><li> <a class="externallink" href="http://blogs.msdn.com/b/oldnewthing/archive/2010/10/29/10082550.aspx" target="_blank">http://blogs.msdn.com/b/oldnewthing/archive/2010/10/29/10082550.aspx</a></li></ul></li>
<li> GameEngineJP Blog: __purecall とは何か？<ul><li> <a class="externallink" href="http://blog.gameenginejp.com/2010/11/purecall.html" target="_blank">http://blog.gameenginejp.com/2010/11/purecall.html</a></li></ul></li>
<li> __purecall? [Archive] - CodeGuru Forums<ul><li> <a class="externallink" href="http://www.codeguru.com/forum/archive/index.php/t-268140.html" target="_blank">http://www.codeguru.com/forum/archive/index.php/t-268140.html</a></li></ul></li>
<li> Description of the R6025 run-time error in Visual C++<ul><li> <a class="externallink" href="http://support.microsoft.com/kb/125749" target="_blank">http://support.microsoft.com/kb/125749</a></li></ul></li></ul>

<p class="paragraph">
もしも内容に間違いがあったら、メールなりブクマコメントなりでご指摘ください。
<br />
</p>


<hr />
<ul><li><a href="#idbefef6">コンストラクタやデストラクタを仮想関数から呼ばない方が良い理由</a><ul><li><a href="#id1e82f4">そもそも仮想関数を使う目的は？</a></li>
<li><a href="#id8187c3">仮想関数とメモリレイアウト</a></li>
<li><a href="#ida3b5d2">基底クラスのコンストラクタから仮想関数を呼んでおくことで、派生先でコンストラクタの挙動をカスタマイズしたいんだけど・・・</a></li>
<li><a href="#id120340">純粋仮想関数が混ざってくるとどうなるか</a></li></ul></li>
<li><a href="#id8516be">R0625の発生 &quot;pure virtual function call&quot; と &quot;__purecall&quot;</a><ul><li><a href="#idd1cdbb">R6025が発生するサンプルコード</a></li>
<li><a href="#idffe1d5">純粋仮想関数とvtblと&quot;__purecall&quot;</a></li></ul></li>
<li><a href="#id999ac8">まとめ</a></li></ul>
<hr />
<h3 id="idbefef6">コンストラクタやデストラクタを仮想関数から呼ばない方が良い理由</h3>

<p class="paragraph">
最初に理論面から攻めていきます。コンストラクタやデストラクタを仮想関数から呼ばないほうが良い理由の理論的根拠です。
<br />
</p>

<p class="paragraph">
ちなみに、先に&quot;C++ コンストラクタ 仮想関数&quot;でググってあらかた「あーそーゆーこと」で理解できた人は以下のサブセクションはスキップしちゃっていいです。ってかそのレベルであれば、本記事なんてそもそも読む必要ないかも。
<br />
</p>

<h4 id="id1e82f4">そもそも仮想関数を使う目的は？</h4>

<p class="paragraph">
まず仮想関数を使う目的を復習してみます。
<br />
</p>
<ol><li> 基底クラスとその派生クラスがあり、</li>
<li> 基底クラスのメソッドを派生クラスでオーバーライドしているケースで、</li>
<li> 基底クラスのポインタを使って派生クラスでオーバーライドしたメソッドを呼ぶ</li></ol>

<p class="paragraph">
というのがよくあるパターンだと思います。つまり
<br />
</p>
<ol><li> 基底クラスに仕様とデフォルト実装を定義して、</li>
<li> 派生クラスで実装したのを実際に使う。</li>
<li> 呼ぶ方は基底クラスのポインタ経由で呼べれば、呼び先がどの派生クラスか気にしなくて良いのでラッキー。</li>
<li> ・・・って感じで、インターフェイスと実装を上手く分離したい。</li></ol>

<p class="paragraph">
というのが、仮想関数を使うおおよその目的ではないでしょーか。
<br />
</p>
<pre>class B {
public:
    virtual void foo() { cout &lt;&lt; &quot;B::foo()&quot;; };
};
class D : public B {
public:
    void foo() { cout &lt;&lt; &quot;D::foo()&quot;; };
};
...
D d;
B *bp = &amp;d;
bp-&gt;foo() // &quot;D::foo()&quot;
</pre>
<p class="paragraph">
↑こーゆー使い方ですね。ここで&quot;virtual&quot;を外してしまうと、Bクラスのポインタ経由で呼び出すときにBクラスのfoo()メソッドが呼ばれてしまうので、「仕様は基底クラスで、実装は派生クラスで」というオブジェクト指向ならではの分離テクニックが活かせなないわけです。
<br />
逆に、意図的に「いや、virtualを付けたけど、ここでだけはBクラスのfoo()を呼びたいんだ」ってーときはスコープを明示します。
<br />
</p>
<pre>D d;
B *bp = &amp;d;
bp-&gt;B::foo() // &quot;B::foo()&quot;
</pre>

<p class="paragraph">
参考： <a class="externallink" href="http://ideone.com/9lthO" target="_blank">http://ideone.com/9lthO</a>
<br />
</p>

<p class="paragraph">
JavaとかPHPとかPythonとかのメソッドは、基本的に全部virtualになってると考えられます。Javaの例だと、
<br />
</p>
<div class="hl-main"><pre><span class="hl-reserved">class</span><span class="hl-code"> </span><span class="hl-identifier">Foo</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-reserved">public</span><span class="hl-code"> </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">m1</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-identifier">System</span><span class="hl-code">.</span><span class="hl-identifier">out</span><span class="hl-code">.</span><span class="hl-identifier">println</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">Foo::m1()</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span class="hl-brackets">}</span><span class="hl-code">
</span><span class="hl-reserved">class</span><span class="hl-code"> </span><span class="hl-identifier">Bar</span><span class="hl-code"> </span><span class="hl-reserved">extends</span><span class="hl-code"> </span><span class="hl-identifier">Foo</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-reserved">public</span><span class="hl-code"> </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">m1</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-identifier">System</span><span class="hl-code">.</span><span class="hl-identifier">out</span><span class="hl-code">.</span><span class="hl-identifier">println</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">Bar::m1()</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span class="hl-brackets">}</span><span class="hl-code">
</span><span class="hl-reserved">class</span><span class="hl-code"> </span><span class="hl-identifier">Main</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-reserved">public</span><span class="hl-code"> </span><span >static</span><span class="hl-code"> </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span class="hl-identifier">String</span><span class="hl-code"> </span><span class="hl-identifier">args</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-identifier">Bar</span><span class="hl-code"> </span><span class="hl-identifier">b</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">Bar</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-identifier">Foo</span><span class="hl-code"> </span><span class="hl-identifier">o1</span><span class="hl-code"> = </span><span class="hl-identifier">b</span><span class="hl-code">;
                </span><span class="hl-identifier">o1</span><span class="hl-code">.</span><span class="hl-identifier">m1</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span class="hl-brackets">}</span></pre></div>

<p class="paragraph">
実行結果出力：
<br />
</p>
<pre>Bar::m1()
</pre>
<p class="paragraph">
として、実装クラス(Bar)のインスタンスを基底クラス(Foo)型で参照しても、自動的に実装クラス側のm1()が呼ばれます。
<br />
例： <a class="externallink" href="http://ideone.com/70RbR" target="_blank">http://ideone.com/70RbR</a>
<br />
</p>

<p class="paragraph">
ところで個人的な話ですが、どうにも「オーバーライド(over ride)」って馴染めないんですよね。「オーバーロード(over load)」と間違えそうで。上書きしてるんだから「オーバーライト(over-write)」でいいんじゃないかと思うんですが、まぁしゃーないですな。
<br />
</p>

<h4 id="id8187c3">仮想関数とメモリレイアウト</h4>

<p class="paragraph">
「C++プログラミングの処方箋」の「鉄則78 仮想関数とオーバーライド」を読んでください・・・で済ませるのもさすがに不親切です。
<br />
本記事では単独継承しか使いませんので、単独継承での仮想関数とメモリレイアウトについて簡単に紹介します。
<br />
</p>

<p class="paragraph">
概念としてざっくりまとめてしまうと、
<br />
</p>
<ol><li> 内部的に関数へのテーブルを用意してクラスに関連付けておきます。</li>
<li> この関数テーブルが&quot;vtbl&quot;とか呼ばれてます。</li>
<li> で、関数を呼びたい場合は関数のアドレスを直接呼ぶのではなくて、</li>
<li> 関数テーブルのインデックスを介してアドレスを取り出し、それを使うようにします。</li></ol>

<p class="paragraph">
次のようなクラスがあるとします。実装はどこかで定義されているとしておきます。
<br />
</p>
<pre>class B {
public:
    virtual void f1();
    virtual void f2();
    virtual void f3();
};
</pre>
<p class="paragraph">
すると、Bクラス用のvtblは
<br />
</p>
<pre>vtbl[0] = &amp;B::f1;
vtbl[1] = &amp;B::f2;
vtbl[2] = &amp;B::f3;
</pre>
<p class="paragraph">
↑こんな感じのものがグローバルで用意されます。コンパイラがデータとして生成してくれます。
<br />
vtblは各クラスに一つあればOKです。後はBクラスのインスタンスを作るときに、vtblへのポインタを含めておきます。
<br />
↓コンパイラごとの細かい実装の違いは無視して、概念的なイメージとしてはこんな感じになります。
<br />
</p>
<pre class="plugin_pre">
 [Instance of B (1)]
+-------------------+         vtbl for B
|    vtbl           |--+--&gt; +--------------+
+-------------------+  |    | [0] = &amp;B::f1 |
| other members     |  |    | [1] = &amp;B::f2 |
+-------------------+  |    | [2] = &amp;B::f3 |
                       |    +--------------+
 [Instance of B (2)]   |
+-------------------+  |
|    vtbl           |-&gt;+
+-------------------+
| other members     |
+-------------------+
</pre>
<p class="paragraph">
使うときのイメージは、
<br />
</p>
<pre>B *bp = new B;
bp-&gt;f3();
</pre>
<p class="paragraph">
↑のf3()呼び出しは
<br />
</p>
<pre>(*(bp-&gt;vtbl)[2])(bp);
</pre>
<p class="paragraph">
に変換されます(あくまでもイメージです)。引数のbpはthisポインタ用です。
<br />
</p>

<p class="paragraph">
で、例えばこのクラスBを単独継承したクラスDで、f2(), f3()をオーバーライドするとします。どうするかというと、クラスD用のvtblをクラスBのvtblからパクって、f2, f3をクラスDのf2, f3のアドレスに書き換えればOKです。コンパイラがやってくれます。
<br />
</p>
<pre>class D : public B {
public:
    virtual void f2();
    virtual void f3();
};
</pre>
<p class="paragraph">
→
<br />
</p>
<pre class="plugin_pre">
 [Instance of D]
+---------------+       vtbl for D
|    vtbl       |---&gt; +--------------+
+---------------+     | [0] = &amp;B::f1 |
| B members     |     | [1] = &amp;D::f2 |
+---------------+     | [2] = &amp;D::f3 |
| D members     |     +--------------+
+---------------+
</pre>
<p class="paragraph">
こうしておけば、基底クラス(=仕様)型のポインタで派生クラス(=実装)の実体を受けても、
<br />
</p>
<pre>B *bp = new D;
bp-&gt;f3();
</pre>
<p class="paragraph">
→
<br />
</p>
<pre>(*(bp-&gt;vtbl)[2])(bp);
</pre>
<p class="paragraph">
となり、この時のvtblはクラスDのvtblなので、D::f3()が呼ばれるというわけです。
<br />
関数の引数に渡すときも基底クラスのポインタで受けるように、
<br />
</p>
<pre>void foo(B *bp) {
    ....
    bp-&gt;f3();
    ....
}
</pre>
<p class="paragraph">
としておけば、Bクラスから派生したクラスのインスタンスならどれでも、そのf3()を呼べるようになるというわけです。まぁコールバック関数(=仕様)を介したcaller(=利用者)とcallee(=実装)の分離テクニックの発展形とも言えます。
<br />
</p>

<h4 id="ida3b5d2">基底クラスのコンストラクタから仮想関数を呼んでおくことで、派生先でコンストラクタの挙動をカスタマイズしたいんだけど・・・</h4>

<p class="paragraph">
&quot;C++ コンストラクタ 仮想関数&quot;でggrks.
<br />
</p>

<p class="paragraph">
簡単にまとめちゃうと、基底クラスのコンストラクタ実行中は派生クラスのメンバの準備が完了していない。派生クラスの仮想関数が呼べないわけです。ということで、基底クラスのコンストラクタ中で仮想関数を呼ぶと、基底クラスの実装が呼ばれてしまいます。
<br />
</p>

<pre>class B {
public:
    B() { foo(); };
    virtual void foo() { cout &lt;&lt; &quot;B::foo()&quot;; };
};
class D : public B {
public:
    void foo() { cout &lt;&lt; &quot;D::foo()&quot;; };
};
int main(...) {
    D d;
    ...
}
</pre>
<p class="paragraph">
希望としては「D::foo()が基底クラスのコンストラクタで呼ばれて欲しい」のですが、現実はB::foo()が呼ばれます。
<br />
例：<a class="externallink" href="http://ideone.com/ODIdH" target="_blank">http://ideone.com/ODIdH</a>
<br />
</p>

<h4 id="id120340">純粋仮想関数が混ざってくるとどうなるか</h4>

<p class="paragraph">
純粋仮想関数を使えば、Javaで言うところの抽象クラスやインターフェイスを作ることが出来ます。
<br />
ここで、前のサブセクションで取り上げた「基底クラスのコンストラクタ実行中は派生クラスの仮想関数は使えない」というのを知らないプログラマが、「よし、いっそのこと基底クラス側は純粋仮想関数にしてしまい、派生クラス側でのカスタマイズを強制しちゃおう」とするとどうなるでしょうか？
<br />
pure_callXX.cpp:
<br />
</p>
<div class="hl-main"><pre><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdio.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
 
</span><span >class</span><span class="hl-code"> </span><span class="hl-identifier">B</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
</span><span class="hl-reserved">public</span><span class="hl-code">:
    </span><span class="hl-identifier">B</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-identifier">foo</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">;
    </span><span >virtual</span><span class="hl-code"> </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">foo</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code">;
</span><span >class</span><span class="hl-code"> </span><span class="hl-identifier">D</span><span class="hl-code"> : </span><span class="hl-reserved">public</span><span class="hl-code"> </span><span class="hl-identifier">B</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
</span><span class="hl-reserved">public</span><span class="hl-code">:
    </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">foo</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-identifier">printf</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">D::foo()</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code">;
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span class="hl-identifier">D</span><span class="hl-code"> </span><span class="hl-identifier">d</span><span class="hl-code">;
    </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">0</span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>
<p class="paragraph">
コンパイルは成功しますが、リンクでエラーになります：
<br />
</p>
<pre>pure_callXX.obj : error LNK2019: 未解決の外部シンボル 
&quot;public: virtual void __thiscall B::foo(void)&quot; (?foo@B@@UAEXXZ) が
関数 &quot;public: __thiscall B::B(void)&quot; (??0B@@QAE@XZ) で参照されました。
pure_callXX.exe : fatal error LNK1120: 外部参照 1 が未解決です。
</pre>

<p class="paragraph">
B:foo()を定義してあげればリンカエラーは無くなるのですが、そもそも純粋仮想関数にした意味が無くなっちゃいます。
<br />
ということで、まぁ大抵のケースではこの辺りで諦め、Google先生に助けを求めると思います。
<br />
</p>

<hr />
<p class="paragraph">
以上、「コンストラクタやデストラクタから仮想関数を呼ばないほうが良い理由」でした。
<br />
</p>

<p class="paragraph">
続いて、いよいよR6025を発生させ、&quot;__purecall&quot;の正体に迫っていきます。
<br />
</p>

<h3 id="id8516be">R0625の発生 &quot;pure virtual function call&quot; と &quot;__purecall&quot;</h3>

<p class="paragraph">
最初にR6025を発生させるサンプルを紹介します。続いて、R6025の発生が純粋仮想関数と&quot;__purecall&quot;にどう関連するのか、アセンブラコードやリンカが生成したMAPファイルを見ながら調べていきます。
<br />
</p>

<p class="paragraph">
本セクションのサンプルコードのzipアーカイブは以下のURLからダウンロードできます。整形して見やすくしたアセンブラリストやMAPファイルも含まれています。
<br />
<a href="./../images/pure_call_R6025/pure_call_R6025.zip" target="_blank" >pure_call_R6025.zip</a> (71KB)
<br />
</p>

<h4 id="idd1cdbb">R6025が発生するサンプルコード</h4>

<p class="paragraph">
pure_callXX.cppでは、コンストラクタ中で純粋仮想関数を直接呼んでいたためリンカエラーとして「未実装の純粋仮想関数を基底クラスから呼んでしまっている」状況を検出できました。
<br />
逆に言えば、間接的に純粋仮想関数を呼んでしまうとリンク段階でも検出できず、未定義の挙動 = WindowsならR6025 &quot;pure virtual function call&quot; として実行時エラーとなってしまいます。
<br />
</p>

<p class="paragraph">
ということで、pure_callXX.cppをちょっと弄ればR6025が発生します。
<br />
pure_call_R6025_1.cpp:
<br />
</p>
<div class="hl-main"><pre><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdio.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
 
</span><span >class</span><span class="hl-code"> </span><span class="hl-identifier">B</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
</span><span class="hl-reserved">public</span><span class="hl-code">:
    </span><span >virtual</span><span class="hl-code"> </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">foo</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">;
 
    </span><span class="hl-comment">// 純粋仮想関数を呼ぶだけの、普通のインスタンスメソッド</span><span class="hl-comment"></span><span class="hl-code">
    </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">bar</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-reserved">this</span><span class="hl-code">-&gt;</span><span class="hl-identifier">foo</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">;
 
    </span><span class="hl-comment">// 純粋仮想関数を直接呼ぶのではなく、普通のインスタンスメソッドを介して呼ぶ</span><span class="hl-comment"></span><span class="hl-code">
    </span><span class="hl-identifier">B</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-identifier">bar</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code">;
</span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">B</span><span class="hl-code">::</span><span class="hl-identifier">foo</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-identifier">printf</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">B::foo()</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span >class</span><span class="hl-code"> </span><span class="hl-identifier">D</span><span class="hl-code"> : </span><span class="hl-reserved">public</span><span class="hl-code"> </span><span class="hl-identifier">B</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
</span><span class="hl-reserved">public</span><span class="hl-code">:
    </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">foo</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-identifier">printf</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">D::foo()</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code">;
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span class="hl-identifier">D</span><span class="hl-code"> </span><span class="hl-identifier">d</span><span class="hl-code">;
    </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">0</span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>
<p class="paragraph">
コンパイル＆実行：
<br />
</p>
<pre>&gt; cl pure_call_R6025_1.cpp
&gt; pure_call_R6025_1
R6025
- pure virtual function call
</pre>

<p class="paragraph">
他にもMicrosoftのKB125749では、コンストラクタ中でthisポインタを外部の関数に渡すことで間接的に純粋仮想関数を呼び、実行時にR6025が発生するC++のサンプルコードが紹介されています。
<br />
コンストラクタ中では自分のインスタンスの初期化が完了してないわけですから、thisを外に曝す事自体がそもそもバグの原因になりそうで、自分は怖くてやったこと無いんです。まぁそれをやってしまうと、R6025などが発生しちゃうんですね・・・。
<br />
</p>

<h4 id="idffe1d5">純粋仮想関数とvtblと&quot;__purecall&quot;</h4>

<p class="paragraph">
メモリレイアウトがどうなっているのか、まずはアセンブラリストから追って見ます。foo()ひとつだけでは寂しいので、いくつか追加した次のサンプルを使います。
<br />
pure_call_R6025_2.cpp:
<br />
</p>
<div class="hl-main"><pre><span >class</span><span class="hl-code"> </span><span class="hl-identifier">B</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
</span><span class="hl-reserved">public</span><span class="hl-code">:
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">a</span><span class="hl-code">;
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">b</span><span class="hl-code">;
    </span><span class="hl-identifier">B</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">f0</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span >virtual</span><span class="hl-code"> </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">f1</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">;
    </span><span >virtual</span><span class="hl-code"> </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">f2</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span >virtual</span><span class="hl-code"> </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">f3</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code">;
</span><span class="hl-identifier">B</span><span class="hl-code">::</span><span class="hl-identifier">B</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-identifier">a</span><span class="hl-code"> = </span><span class="hl-identifier">f0</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">B</span><span class="hl-code">::</span><span class="hl-identifier">f0</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-identifier">f1</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">B</span><span class="hl-code">::</span><span class="hl-identifier">f2</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-identifier">a</span><span class="hl-code"> + </span><span class="hl-identifier">b</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">B</span><span class="hl-code">::</span><span class="hl-identifier">f3</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-identifier">a</span><span class="hl-code"> * </span><span class="hl-identifier">b</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span >class</span><span class="hl-code"> </span><span class="hl-identifier">D</span><span class="hl-code"> : </span><span class="hl-reserved">public</span><span class="hl-code"> </span><span class="hl-identifier">B</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
</span><span class="hl-reserved">public</span><span class="hl-code">:
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">c</span><span class="hl-code">;
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">d</span><span class="hl-code">;
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">e</span><span class="hl-code">;
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">f1</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">f4</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">f5</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code">;
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">D</span><span class="hl-code">::</span><span class="hl-identifier">f1</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-identifier">c</span><span class="hl-code"> + </span><span class="hl-identifier">d</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">D</span><span class="hl-code">::</span><span class="hl-identifier">f4</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-identifier">d</span><span class="hl-code"> + </span><span class="hl-identifier">e</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">D</span><span class="hl-code">::</span><span class="hl-identifier">f5</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-identifier">e</span><span class="hl-code"> + </span><span class="hl-identifier">c</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span class="hl-identifier">D</span><span class="hl-code"> </span><span class="hl-identifier">d</span><span class="hl-code">;
    </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">0</span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>

<p class="paragraph">
これを、アセンブラリスト付き＋リンク時にMAPファイル生成でコンパイルします。
<br />
</p>
<pre>&gt; cl /FAsc pure_call_R6025_2.cpp /link /MAP:pure_call_R6025_2.map
</pre>
<p class="paragraph">
.objと.exeファイル、pure_call_R6025_2.cod(アセンブラリスト)、pure_call_R6025_2.map が生成されます。
<br />
.exeを実行してみると予想通りR6025が発生します（結果省略）。
<br />
</p>

<p class="paragraph">
では生成されたアセンブラリスト(pure_call_R6025_2.cod)を見ていきましょう・・・って、B::f0が&quot;?f0@B@@QAEHXZ&quot;という名前になってたり、クラスBのvtblが&quot;??_7B@@6B@&quot;になってたりで非常に読みづらいです。まぁ人間が読むものじゃなくてコンパイラとリンカが処理するシロモノなので当然っちゃー当然なんですが。
<br />
とゆーわけで、余分なコメントとか色々取り払って、&quot;??_7B@@6B@&quot;とかも人間寄りの文字列に置換して分かりやすくしたのを pure_call_R6025_2_s3.cod としてサンプルコードのzipアーカイブに入れてあります。
<br />
</p>

<p class="paragraph">
とりあえずざっくり眺めて、vtblとRTTI周りの関連を図にしてみました。
<br />
<a href="./../images/pure_call_R6025/vtbl_rtti_b.png" title="" target="_blank"><img src="./../images/pure_call_R6025/vtbl_rtti_b.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
<a href="./../images/pure_call_R6025/vtbl_rtti_d.png" title="" target="_blank"><img src="./../images/pure_call_R6025/vtbl_rtti_d.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
仮想関数がそれぞれの&quot;vftable&quot;にまとめられ、<strong>純粋仮想関数である B::f0 は &quot;__purecall&quot; というシンボルを指す</strong>ようになっています。
<br />
では &quot;__purecall&quot; の実体はどこにあるのか？これはリンク時に生成されるMAPファイルを見れば一目瞭然です。
<br />
</p>

<p class="paragraph">
pure_call_R6025_2.map:
<br />
</p>
<pre>...
Start         Length     Name                   Class
0001:00000000 000063c4H .text                   CODE
...
 Address         Publics by Value              Rva+Base       Lib:Object
...
0001:00000160       __purecall                 00401160 f   LIBCMT:purevirt.obj
</pre>

<p class="paragraph">
LIBCMTライブラリ内の purevirt.obj に収められており、実行時アドレスは(&quot;Rva+Base&quot;) 0x00401160になることが分かります。
<br />
</p>

<p class="paragraph">
面白そうなので、OllyDbgで読み込み、それぞれのvftableの中身を見てみます。
<br />
もともとのアセンブラリストから、B,Dそれぞれのvftableの識別名は
<br />
</p>
<pre>PUBLIC  ??_7B@@6B@  ; B::`vftable&#039;
PUBLIC  ??_7D@@6B@  ; D::`vftable&#039;
</pre>
<p class="paragraph">
です。これをMAPファイルで探してみると、セクション番号#2(=&quot;.rdata&quot;セクション)、Rva+Base = 0x40811c, 0x40812c に展開されることが分かります。
<br />
</p>
<pre>0002:0000011c       ??_7B@@6B@                 0040811c     pure_call_R6025_2.obj
0002:0000012c       ??_7D@@6B@                 0040812c     pure_call_R6025_2.obj
</pre>

<p class="paragraph">
OllyDbgで覗いてみます：
<br />
</p>
<pre>0040811C  60 11 40 00 50 10 40 00
00408124  70 10 40 00 40 9A 40 00
0040812C  90 10 40 00 50 10 40 00
00408134  70 10 40 00 62 61 64 20
</pre>
<p class="paragraph">
分かりやすく整形してみます：
<br />
</p>
<pre>[00408118]
004099F8 ; &quot;??_R4B@@6B@&quot; = B::RTTI Complete Object Locator
[0040811C] = B::vftable
00401160 ; B::f0 =&gt; __purecall
00401050 ; &quot;?f2@B@@UAEHXZ&quot; = B::f2
00401070 ; &quot;?f3@B@@UAEHXZ&quot; = B::f3
[00408128]
00409A40 ; &quot;??_R4D@@6B@&quot; = D::RTTI Complete Object Locator
[0040812C] = D::vftable
00401090 ; &quot;?f1@D@@UAEHXZ&quot; = D::f1
00401050 ; &quot;?f2@B@@UAEHXZ&quot; = B::f2
00401070 ; &quot;?f3@B@@UAEHXZ&quot; = B::f3
</pre>

<p class="paragraph">
・・・ちょーっと謎なのが、アセンブラリスト上だと
<br />
</p>
<pre class="plugin_pre">
CONST	SEGMENT
??_7B@@6B@ DD FLAT:??_R4B@@6B@ ; B::`vftable&#039;
    DD FLAT:__purecall
    DD FLAT:?f2@B@@UAEHXZ
    DD FLAT:?f3@B@@UAEHXZ
CONST ENDS
...
CONST SEGMENT
??_7D@@6B@ DD FLAT:??_R4D@@6B@ ; D::`vftable&#039;
    DD FLAT:?f1@D@@UAEHXZ
    DD FLAT:?f2@B@@UAEHXZ
    DD FLAT:?f3@B@@UAEHXZ
CONST ENDS
</pre>
<p class="paragraph">
となってて、各vftableの[0]には&quot;RTTI Complete Object Locator&quot;のアドレスが入るはずなんですよ。なんですが、実際のMAPファイルのアドレスとメモリイメージを付きあわせてみると、
<br />
</p>
<pre>B::vftable = (DWORD*)(0x0040811C);
B::vftable[-1] = B::RTTI Complete Object Locator;
B::vftable[0] = __purecall;
B::vftable[1] = B::f2;
B::vftable[2] = B::f3;
D::vftable = (DWORD*)(0x0040812C);
D::vftable[-1] = D::RTTI Complete Object Locator;
D::vftable[0] = D::f1
D::vftable[1] = B::f2;
D::vftable[2] = B::f3;
</pre>
<p class="paragraph">
となり、&quot;Complete Object Locator&quot;のアドレスが一つ分ずれてしまってるようにしか思えません。
<br />
が・・・まぁこれで動いてるんですから、正常のハズ・・・。どうなってんでしょー・・・。
<br />
まぁ本筋とは関係なさそうなので、スルーしちゃいます。
<br />
</p>

<p class="paragraph">
あとはOllyDbgなりImmunityDebuggerなりIDAなりWinDBGなり、お好みのデバッガを起動してmain関数から機械語単位でステップ実行していけば、
<br />
</p>
<pre>main() -&gt; D::D() -&gt; B::B() -&gt; B::f0() -&gt; __purecall
</pre>
<p class="paragraph">
という流れが見えてきます。
<br />
関連シンボルだけをMAPファイルから抽出してまとめなおした pure_call_R6025_2.map2 を見ながらだと分かりやすいと思います。
<br />
pure_call_R6025_2.map2:
<br />
</p>
<pre class="plugin_pre">
[.text]
Rva+Base  Publics by Value
--------------------------
00401000  ??0B@@QAE@XZ    ; B::B
00401030  ?f0@B@@QAEHXZ   ; B::f0
00401050  ?f2@B@@UAEHXZ   ; B::f2
00401070  ?f3@B@@UAEHXZ   ; B::f3
00401090  ?f1@D@@UAEHXZ   ; D::f1
004010b0  ?f4@D@@QAEHXZ   ; D::f4
004010d0  ?f5@D@@QAEHXZ   ; D::f5
004010f0  _main           
00401110  ??0D@@QAE@XZ    ; D::D
00401160  __purecall      ; LIBCMT:purevirt.obj


[.rdata]
Rva+Base  Publics by Value  
----------------------------
0040811c  ??_7B@@6B@        ; B::vftable
0040812c  ??_7D@@6B@        ; D::vftable
...
</pre>

<p class="paragraph">
__purecallの中身までは、今回の調査範囲外とさせて下さい。まぁSDK提供のライブラリということもありますし、とりあえず__purecall呼んでる箇所とそこに到るまでの流れが分かれば、本記事の内容としては十分じゃないでしょーか。
<br />
</p>

<hr />
<p class="paragraph">
以上で純粋仮想関数をコンストラクタから呼んでしまうとR6025が発生する流れが分かりました。
<br />
最後に理論面と合わせて、R6025と&quot;__purecall&quot;についてまとめます。
<br />
</p>

<h3 id="id999ac8">まとめ</h3>

<dl>
<dt> R6025 &quot;pure virtual function call&quot; って何？ </dt>
<dd>コンストラクタ中で純粋仮想関数を呼んでしまったときの未定義挙動（実行時エラー）です。&quot;pure virtual function call&quot; = 純粋仮想関数です。実装が存在しないのが純粋仮想関数なので、呼んだらエラーになるのが自然の成り行きで、それがこの実行時エラーです。</dd>
<dt> &quot;__purecall&quot; って何？ </dt>
<dd>vtblに純粋仮想関数を登録するときのダミーシンボルで、LIBCMT:purevirt.objに実体があります。間違って呼ばれたときに、R6025の実行時エラーを発生させる処理のようです。</dd>
<dt> 派生クラスでちゃんと純粋仮想関数を実装してるのに、なんでR6025が発生するの？ </dt>
<dd>基底クラスのコンストラクタが実行される時点では、基底クラスの仮想関数が呼ばれます。もしも基底クラスのコンストラクタ内から純粋仮想関数を呼んでいたら、派生クラスで実装した関数ではなく、基底クラスのvtblにダミーで登録された&quot;__purecall&quot;が呼ばれ、R6025が発生します。</dd>
<dt> R6025を起こさないようにするには？ </dt>
<dd>コンストラクタから直接・間接を問わず純粋仮想関数を呼ばないようにします。直接呼んでいる場合はリンク時に検出されますが、間接的に呼んでいるとリンク時には検出できず、実行時エラーとなってしまいます。</dd>
<dt> 他に仮想関数とコンストラクタで注意する点は？ </dt>
<dd>前述のとおり基底クラスのコンストラクタ中では基底クラスの仮想関数が呼ばれてしまいます。したがって、基底クラスのコンストラクタで仮想関数を呼び、派生クラスでの仮想関数の実装により初期化時の挙動を変化させるようなテクニックは使わない方が良いでしょう。またこの議論はデストラクタにも当てはまりますので注意が必要です。</dd>
</dl>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-494.html" title="C言語系/00_参考資料">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-535.html" title="C言語系/NetBSD1.6における setjmp(), longjmp() の実装">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/896<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2001 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" target="_blank" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>