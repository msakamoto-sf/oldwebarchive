<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>技術/UNIX/なぜnohupをバックグランドジョブとして起動するのが定番なのか？(擬似端末, Pseudo Terminal, SIGHUP他) - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">技術/UNIX/なぜnohupをバックグランドジョブとして起動するのが定番なのか？(擬似端末, Pseudo Terminal, SIGHUP他)</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-11-29 17:52:28 &nbsp; / &nbsp; last updated at: 2010-12-02 11:32:32<br>
カテゴリ: <a href="category-10.html">C言語</a>&nbsp;<a href="category-20.html">Linux</a>&nbsp;<a href="category-38.html">UNIX</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-288.html" title="技術/UNIX/「UNIX用のGeekな小技10個」メモ">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-1247.html" title="技術/UNIX/端末やターミナルの文字化け対処(clear,reset,stty sane,tput,ncurses)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-23.html" title="技術">技術</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
何をいまさら当たり前の事を・・・と思われるだろう。
<br />
</p>
<pre>$ nohup long_run_batch.sh &amp;
</pre>
<p class="paragraph">
SSHからログアウト後も実行を続けたいバッチジョブを、&quot;&amp;&quot;を付けてバックグラウンドジョブとしてnohupから起動するのは定番中の定番である。
<br />
</p>

<p class="paragraph">
しかし、「nohupを使わなくても実行を続けることが出来る」やり方があったり、さらには<strong>「nohupを付けてもログアウト時に終了してしまう」</strong>パターンがあるとしたらどうだろう？
<br />
</p>

<p class="paragraph">
そして、ある日あなたの後輩や同僚がこれらについてあなたに質問してきたら、あなたはどう答えるだろうか？
<br />
</p>
<pre>「Web上で検索したら見つかったのでそれに従ってる」
</pre>
<p class="paragraph">
と答えてお茶を濁すだろうか？
<br />
それとも、
<br />
</p>
<pre>「OK, いい質問だ。それはシェルが終了時にSIGHUPをだね・・・」
</pre>
<p class="paragraph">
のように理路整然とした華麗な語り口で受け答えるべきだろうか？
<br />
</p>

<p class="paragraph">
「お茶を濁せればそれでよい」と答えた方、あるいは「よし、じゃぁ一緒にBashのソースコードやプロセス終了時のカーネルのソースを追ってみようか。おっとその前にSUSv3をベースに端末制御とSIGHUPについて復習だ・・・」と颯爽とリードできる人はこの先読む必要は無い。
<br />
</p>
<hr />


<p class="paragraph">
ここから先はそれなりに長丁場になる。しかし、舞台裏を解き明かすことで「nohupのNGパターン」や「nohupを使わなくてもOKなパターン」のWHYについて説明できるようになるだろう。・・・なってくれると、いいなぁ。いや、なってほしいです。・・・なれなかったとしたら、説明が下手だったということでmsakamoot-sfに責任転嫁してください。
<br />
</p>

<p class="paragraph">
内容的に分量や密度は高めとなる。NetBSD1.6やCentOS5.xでの検証でサンプルコードや動作結果などの分量が多いので、そこは読み飛ばしていただいてもかまわない。
<br />
</p>

<p class="paragraph">
では、しばしお付き合い願います。
<br />
</p>
<hr />
<ul><li><a href="#id8d4dfc">WHY?の発端</a><ul><li><a href="#idf2f03a">nohupを使わなくても実行を続けることが出来るパターン</a></li>
<li><a href="#id801827">nohupを付けてもログアウト時に終了してしまうパターン</a></li>
<li><a href="#ida37604">nohupの仕組みだけでは説明しきれない</a></li>
<li><a href="#id3d4712">「誰がSIGHUP送ったの？」（「誰がこまどり殺したの？」）</a></li>
<li><a href="#id0f196a">本記事を読むときの前提知識、実験・検証環境について</a><ul><li><a href="#idb162af">前提知識</a></li>
<li><a href="#id678523">環境</a></li>
<li><a href="#id143046">参考資料の表記について</a></li></ul></li></ul></li>
<li><a href="#idad3130">退屈な復習から生まれたWHY?の発端</a><ul><li><a href="#idc679b7">セッション・プロセスグループの全体像</a></li>
<li><a href="#id3e08da">セッションと制御端末(Controlling Terminal)</a></li>
<li><a href="#id231dbe">セッションの新規作成</a></li>
<li><a href="#id63ab1d">プロセスグループの新規作成</a></li>
<li><a href="#id841df1">コンソールログインの舞台裏</a><ul><li><a href="#id0195cf">NetBSD1.6でのコンソールログイン例</a></li>
<li><a href="#idf83282">CentOS5.xでのコンソールログイン例</a></li></ul></li>
<li><a href="#id17ca2b">擬似端末(Pseudo Terminal)を使ったリモートログインの舞台裏</a></li>
<li><a href="#id7571e1">端末入出力とジョブコントロール</a></li>
<li><a href="#iddf8abd">端末とSIGHUP</a></li></ul></li>
<li><a href="#id71d8f3">WHY?</a><ul><li><a href="#id68fa75">BECAUSE : ログインシェル(今回はBash)が、終了時にSIGHUP/SIGTERM/SIGCONTをバックグランドジョブに送信する「場合がある」から。</a><ul><li><a href="#id712f63">「nohupを使わなくても実行を続けることが出来るパターン」の解説</a></li>
<li><a href="#id4e15df">「nohupを付けてもログアウト時に終了してしまうパターン」の解説</a></li>
<li><a href="#id898e9c">「nohupをバックグラウンドジョブとして起動する必要があるパターン」 = SIGHUPが送信されるパターン</a></li></ul></li>
<li><a href="#ida1b382">小休憩</a></li></ul></li>
<li><a href="#idc65799">NetBSD 1.6 における擬似端末, Bash, nohupの確認</a><ul><li><a href="#id9c8517">擬似端末を使ったサンプル</a><ul><li><a href="#ida94c54">NetBSD版 擬似端末実験用サンプルコード mypty.c</a></li>
<li><a href="#id5c3c42">NetBSD版 slave側擬似端末の制御プロセス用サンプルコード mycat_detectHUP.c</a></li>
<li><a href="#ida5092f">サンプルコードによるSIGHUPの確認</a></li></ul></li>
<li><a href="#id009c2a">終了時にBashがジョブに送信するシグナル</a><ul><li><a href="#id1a70ad">&quot;exit&quot; or &quot;logout&quot; シェルコマンドを実行して終了するときにBashが送信するシグナル</a></li>
<li><a href="#idff2cfe">SIGHUPを受信して終了するときにBashが送信するシグナル</a></li>
<li><a href="#id175d87">実際のソースコード（参考）</a></li>
<li><a href="#idb0881c">実験用ソース : detectHUPCONTTERM.c</a></li>
<li><a href="#idc78763">実験1：&quot;exit&quot;でBash終了時のRUNNNING状態バックグラウンドジョブ(J_NOHUP無, huponexit未設定)</a></li>
<li><a href="#idfa0cc2">実験2：&quot;exit&quot;でBash終了時のSTOP状態バックグラウンドジョブ(J_NOHUP無, huponexit未設定)</a></li>
<li><a href="#iddddfd2">実験3：SIGHUPでBash終了時のRUNNNING状態フォアグラウンドジョブ(J_NOHUP無, huponexit未設定)</a></li>
<li><a href="#id5a62ec">実験4：SIGHUPでBash終了時のRUNNNING状態バックグラウンドジョブ(J_NOHUP無, huponexit未設定)</a></li>
<li><a href="#id4129f2">実験5：SIGHUPでBash終了時のSTOP状態バックグラウンドジョブ(J_NOHUP無, huponexit未設定)</a></li></ul></li>
<li><a href="#idd5056c">nohupの確認</a><ul><li><a href="#id987bea">nohupの一般的な使い方：RUNNING状態でバックグランドジョブ続行</a></li>
<li><a href="#idfc22e8">nohupで起動しても終了するパターン１：ジョブをCtrl+Z(SIGTSTP)でSTOP状態にしてlogout</a></li>
<li><a href="#idf4ef35">nohupで起動しても終了するパターン２：バックグランドジョブで標準入力(=擬似端末のslave側)をread()</a></li>
<li><a href="#idf20db2">nohupで起動した時点ではRUNNNINGだが、端末が閉じられた後、標準入力に対してread()するとどうなるか</a></li></ul></li></ul></li>
<li><a href="#id88cc84">Linux(CentOS5.x) における擬似端末, Bash, nohupの確認</a><ul><li><a href="#id9c8517">擬似端末を使ったサンプル</a></li>
<li><a href="#id009c2a">終了時にBashがジョブに送信するシグナル</a><ul><li><a href="#id1a70ad">&quot;exit&quot; or &quot;logout&quot; シェルコマンドを実行して終了するときにBashが送信するシグナル</a></li>
<li><a href="#idff2cfe">SIGHUPを受信して終了するときにBashが送信するシグナル</a></li>
<li><a href="#id175d87">実際のソースコード（参考）</a></li>
<li><a href="#idc1829f">実験用ソース : detectHUPCONTTERM.c, 実験1 - 5</a></li></ul></li>
<li><a href="#idd5056c">nohupの確認</a></li>
<li><a href="#idd31eb1">実験・検証のまとめと反省</a></li></ul></li>
<li><a href="#id278e84">まとめ：「いともたやすく行われるえげつないnohup」</a></li>
<li><a href="#id61c6f5">参考資料</a></li></ul>
<hr />
<h3 id="id8d4dfc">WHY?の発端</h3>

<p class="paragraph">
改めてタイトルを確認すると、
<br />
</p>
<pre>なぜnohupをバックグランドジョブとして起動するのが定番なのか？
</pre>
<p class="paragraph">
というWHY?になっている。バックグラウンドではなくフォアグラウンドジョブとして起動し、
<br />
</p>
<pre>$ nohup long_run_batch.sh
(フォアグラウンド)
</pre>
<p class="paragraph">
この状態でputtyなどの端末エミュレータを終了させてしまってもバッチジョブは残り、実行を続ける。
<br />
なのになぜ、わざわざnohupをバックグランドジョブとして起動するのが定番になっているのか？あるいはそうした方がよい理由はあるのか？
<br />
</p>

<p class="paragraph">
まずはnohupの中身を確認すべきだが、それについては既に以下の記事で確認している。
<br />
</p>
<ul><li> <a href="./view-847.html" >C言語系/「デーモン君のソース探検」読書メモ/A07, nohup(1)</a></li></ul>

<p class="paragraph">
実は今回のWHY?の発端は、nohupが直接の原因ではない。上の記事でnohup単体の謎解きは終えている。
<br />
その後、「念のためセッションやプロセスグループ、擬似端末についてAPUEを確認しておこう」と思いAPUEをぱらぱらめくっていくうちに、「あれ？バックグラウンドジョブってSIGHUPを受信することは有り得ないんじゃない？」という疑念が立ち上がり、そこで初めて「じゃぁなんでnohupをバックグランドジョブとして起動するのが定番なんだ？」という疑問が表れた。それが今回のWHY?の発端である。
<br />
</p>

<p class="paragraph">
詳細は後ほど解説するとして、まずは冒頭で述べた
<br />
</p>
<ul><li> nohupを使わなくても実行を続けることが出来るパターン</li>
<li> nohupを付けてもログアウト時に終了してしまうパターン</li></ul>

<p class="paragraph">
この２パターンを紹介する。本記事を最後まで読んでいただければ、この２パターンの挙動を完璧に説明できるように・・・なってくれると嬉しいです。
<br />
</p>

<h4 id="idf2f03a">nohupを使わなくても実行を続けることが出来るパターン</h4>

<p class="paragraph">
実験用のサンプル, hello.sh:
<br />
</p>
<pre class="plugin_pre">
#!/bin/sh
i=1
while :
do
    echo &quot;Hello : $i&quot;
    sleep 1
    i=`expr $i + 1`
done
</pre>
<p class="paragraph">
何の変哲も無いシェルスクリプトだが、これだけでもnohup無しで、バックグランドでジョブを続けられる。
<br />
</p>

<p class="paragraph">
手順:
<br />
</p>
<pre>$ ./hello.sh &gt; out.txt &amp;
[1] 219
$ jobs
[1]+  Running                 ./hello.sh &gt;out.txt &amp;
$ exit
→端末終了
</pre>

<p class="paragraph">
別の端末エミュレータを立ち上げてpsコマンドを実行すれば、&quot;./hello.sh&quot;とそのwhileループで起動されたsleepプロセスが残っている事を確認できる。また out.txt を見てみると処理は続行し更新が続けられていることも確認できる。
<br />
</p>

<p class="paragraph">
プラットフォームや端末エミュレータの組み合わせによっては、&quot;exit&quot;後、端末エミュレータ側の画面が真っ白のまま終了しない場合がある。その場合は、端末エミュレータ側を強制終了させる。Linux(CentOS5.x)とputtyの組み合わせでこの現象に遭遇した。NetBSD1.6の場合はputty側も&quot;exit&quot;後にすぐ終了した。
<br />
</p>

<h4 id="id801827">nohupを付けてもログアウト時に終了してしまうパターン</h4>

<p class="paragraph">
「うっかり&quot;&amp;&quot;をつけずにフォアグラウンドで起動してしまったジョブを、&quot;^Z&quot;でバックグラウンドにしてからログアウトする」手順を踏むと、たとえnohupを付けていても終了してしまう。うっかりやってしまい、「アレ？」となった人もいるだろう。自分もしょっちゅうやってました。
<br />
</p>

<pre>$ nohup ./hello.sh
sending output to nohup.out
^Z
[1]+  Stopped                 nohup ./hello.sh
$ jobs
[1]+  Stopped                 nohup ./hello.sh
$ exit
</pre>

<p class="paragraph">
別の端末エミュレータを立ち上げてpsコマンドを実行すれば、&quot;./hello.sh&quot;やsleepプロセスともに終了したためプロセス一覧に表示されない。また out.txt の更新も止まっている。
<br />
</p>

<h4 id="ida37604">nohupの仕組みだけでは説明しきれない</h4>

<p class="paragraph">
上記２パターンのように、バックグランドジョブの継続にはnohupが必須というわけではなく、nohupを使えば全く問題が無いわけでもない。したがってこれらの挙動を正確に把握するにはnohup単体の仕組みだけではなく、端末制御やセッション、プロセスグループ、SIGHUPなど周辺要素について調査する必要がある。
<br />
</p>

<p class="paragraph">
nohupはSIGHUPのシグナルハンドラをSIG_IGNに設定、つまり「受信しても無視」する設定にして、コマンドラインで指定されたジョブを実行する。逆に言えばnohupはSIGTERM, SIGQUITなど他のシグナルハンドラをデフォルト設定のままにしている。たとえnohupで起動していたとしても、それらデフォルトでプロセス終了となるシグナルを受信すれば当然、プロセスは終了する。
<br />
つまりnohupでも終了してしまうパターンでは、それらSIGHUP以外のプロセス終了シグナルを受信したために終了した可能性が考えられる。ではそのシグナルは何なのか？誰が、いつ送信したのか？SIGHUPとそれ以外のシグナル、どちらを送信するのか判断する基準は？
<br />
本記事では、それらの疑問についても回答する予定である。
<br />
</p>

<h4 id="id3d4712">「誰がSIGHUP送ったの？」（「誰がこまどり殺したの？」）</h4>

<p class="paragraph">
と問われれば、
<br />
</p>
<pre>「ログインシェルがSIGHUP送ってるんじゃないの？」
</pre>
<p class="paragraph">
と思われる方もいるだろう。実は自分も、この記事を書くまではそう思ってました。
<br />
</p>

<p class="paragraph">
半分正解で、半分不正解。
<br />
ログインシェルがSIGHUPを送る場合・送らない場合の両方が有り、さらに端末のデバイスドライバやカーネルが送る場合もある。
<br />
それらの詳細については以降の記事で解説するが、実際、ややこしい。実験・検証しているときも、しょっちゅう間違えて時間をとられてしまった。
<br />
</p>
<pre>「誰がSIGHUPを送ったの？」
</pre>
<p class="paragraph">
記事のネタとしてはそれなりだが、実際のお仕事や運用中に一々考えるのは面倒である。
<br />
</p>

<p class="paragraph">
身も蓋も無い言い方だが、<strong>使う側が何も知らず、考えなくてもバックグラウンドジョブを継続できるnohupは、やはりスゴイ</strong>のだ。
<br />
</p>

<h4 id="id0f196a">本記事を読むときの前提知識、実験・検証環境について</h4>

<p class="paragraph">
本格的な調査に進む前に、前提知識、実験・検証環境について説明する。
<br />
</p>

<h5 id="idb162af">前提知識</h5>

<p class="paragraph">
最低限、以下の前提知識や技能があることを前提とする。
<br />
</p>
<ul><li> UnixでのC言語と標準Cライブラリを使ったプログラミング・コンパイル経験</li>
<li> Unixのシステムコール：分野としては File I/O, Signal, Process, Error Handlingの４つ</li>
<li> Bashシェルの使い方、ジョブ制御</li></ul>

<p class="paragraph">
サンプルコードで主に使うのは次のシステムコールとCライブラリ関数になる。必要に応じてmanpageを参照のこと。
<br />
</p>
<pre>open(), read(), write(), close()
signal(), sigaction()
fork(), exec()シリーズ
perror()
printf(), fprintf(), fflush(), 
</pre>

<p class="paragraph">
セッション・プロセスグループ・端末制御系はサンプルコードではほとんど使わない。解説はするので、必要であればmanpageを参照のこと。
<br />
</p>

<p class="paragraph">
サンプルコードは掲載しているが、そのコンパイル方法についてはSUIDが必要な場合を除き、省略している。基本的にはmakeコマンドのデフォルトルールに基づき
<br />
</p>
<pre>$ make (ソースファイル名から&quot;.c&quot;を除去した実行ファイル名)
</pre>
<p class="paragraph">
または
<br />
</p>
<pre>$ cc -o 実行ファイル名 ソースファイル名
$ gcc -o 実行ファイル名 ソースファイル名
</pre>
<p class="paragraph">
でコンパイルしている。
<br />
</p>

<h5 id="id678523">環境</h5>

<p class="paragraph">
NetBSD 1.6 および CentOS 5.x を使っている。古いNetBSD 1.6 を使っている理由は、 <a href="./view-546.html" >C言語系/「デーモン君のソース探検」読書メモ</a> で使った環境を引き続き使用しているためである。いずれもVMware仮想マシンとして実行している。
<br />
</p>

<p class="paragraph">
VMwareホスト:
<br />
</p>
<pre>CPU : Intel CORE i3 (2 core)
RAM : 4GB
OS : Windows7 (32bit), Japanese
VMware : 7.1.2 build-301548
</pre>

<p class="paragraph">
今回使用したクライアント側の端末エミュレータ：「PuTTY 0.60 ごった煮版 2007年8月6日版」
<br />
</p>
<ul><li> putty<ul><li> <a class="externallink" href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" target="_blank">http://www.chiark.greenend.org.uk/~sgtatham/putty/</a></li></ul></li>
<li> PuTTY ごった煮版<ul><li> <a class="externallink" href="http://yebisuya.dip.jp/Software/PuTTY/" target="_blank">http://yebisuya.dip.jp/Software/PuTTY/</a></li></ul></li></ul>

<p class="paragraph">
NetBSD 1.6:
<br />
</p>
<pre>NetBSD 1.6 i386 GENERIC kernel (32bit)

$ bash --version
GNU bash, version 2.05.0(1)-release (i386--netbsdelf)
Copyright 2000 Free Software Foundation, Inc.

$ cc --version
2.95.3
</pre>

<p class="paragraph">
CentOS 5.x:
<br />
</p>
<pre>Linux kernel : 2.6.18-92.1.22.el5 (SMP, i686) (32bit)

$ bash --version
GNU bash, version 3.2.25(1)-release (i686-redhat-linux-gnu)
Copyright (C) 2005 Free Software Foundation, Inc.

$ gcc --version
gcc (GCC) 4.1.2 20080704 (Red Hat 4.1.2-48)
Copyright (C) 2006 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</pre>

<h5 id="id143046">参考資料の表記について</h5>

<dl>
<dt> &quot;APUE&quot; </dt>
<dd>&quot;Advanced Programming in the UNIX Environment Second Edition&quot;</dd>
<dt> &quot;AUP&quot; </dt>
<dd>&quot;Advanced UNIX Programming Second Edition&quot;</dd>
<dt> &quot;SUSv3&quot; </dt>
<dd>Single UNIX &reg;  Specification, Version 3</dd>
</dl>

<p class="paragraph">
参考資料の詳細については記事の最後に一覧を載せている。
<br />
</p>

<h3 id="idad3130">退屈な復習から生まれたWHY?の発端</h3>

<p class="paragraph">
セッションやプロセスグループ、擬似端末についてAPUEを確認したことが今回のWHY?の発端である。
<br />
前提知識の再確認も兼ねて、本記事に特に関連するトピックに絞って、ごく簡単に要点をまとめていく。
<br />
単調で退屈な文章が続くが、暫くご辛抱願いたい。
<br />
</p>

<h4 id="idc679b7">セッション・プロセスグループの全体像</h4>

<ul><li> 1つのプロセスは1つのプロセスグループに所属する。</li>
<li> 1つのプロセスグループには1つまたはそれ以上のプロセスが所属する。</li>
<li> 1つのプロセスグループにはグループリーダーとなるプロセスが0 or 1つ存在する。</li>
<li> 1つのプロセスグループは1つのセッションに所属する。</li>
<li> 1つのセッションには1つまたはそれ以上のプロセスグループが所属する。</li>
<li> 1つのセッションにはセッションリーダーとなるプロセスが1つ存在する。</li></ul>

<p class="paragraph">
<a href="./../images/jobcontrols_pty_nohups/01_overview.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/01_overview.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> APUE : p269, &quot;9.4 Process Groups&quot;</li>
<li> APUE : p270, &quot;9.5 Sessions&quot;</li></ul>

<h4 id="id3e08da">セッションと制御端末(Controlling Terminal)</h4>

<p class="paragraph">
セッションは制御端末の有無で二種類に分けることができる。
<br />
</p>
<ul><li> 制御端末を持たないセッション(initやinitから起動されたデーモンプロセスなど)</li>
<li> 制御端末を持つセッション(ログインシェルやログインシェルから起動されたプロセスなど)<ul><li> 端末からの入出力を受け付けるプログラムはこちらのセッションに所属することになる。</li></ul></li></ul>

<p class="paragraph">
<a href="./../images/jobcontrols_pty_nohups/02_session_types.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/02_session_types.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> APUE : p272, &quot;9.6 Controlling Terminal&quot;</li></ul>

<h4 id="id231dbe">セッションの新規作成</h4>

<p class="paragraph">
セッションの新規作成でポイントとなる箇所を示す。
<br />
</p>

<p class="paragraph">
初期状態：
<br />
<a href="./../images/jobcontrols_pty_nohups/03_new_sess_1.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/03_new_sess_1.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
まずfork()で子プロセスを作成する。
<br />
<a href="./../images/jobcontrols_pty_nohups/03_new_sess_2.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/03_new_sess_2.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
fork()した子プロセス側でsetsid()を呼ぶ。これにより新しいセッションが開始される。
<br />
</p>
<ol><li> setsid()を呼んだプロセスは新しいセッションのセッションリーダーとなる。</li>
<li> 同プロセスは新しいプロセスグループのグループリーダーとなる。新しいプロセスグループのIDは同プロセスのIDと等しくなる。</li>
<li> 新しいセッションはまだ制御端末を持っていない。親プロセスの所属するセッションが制御端末を持っていたとしても、引き継がれない。(ログインシェル上からデーモンを起動したときのイメージ)</li></ol>

<p class="paragraph">
<a href="./../images/jobcontrols_pty_nohups/03_new_sess_3.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/03_new_sess_3.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> APUE : p270, &quot;9.5 Sessions&quot;</li></ul>

<h4 id="id63ab1d">プロセスグループの新規作成</h4>

<p class="paragraph">
プロセスグループの新規作成でポイントとなる箇所を示す。
<br />
</p>

<p class="paragraph">
初期状態：
<br />
<a href="./../images/jobcontrols_pty_nohups/04_new_grp_1.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/04_new_grp_1.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
まずfork()で子プロセスを作成する。
<br />
<a href="./../images/jobcontrols_pty_nohups/04_new_grp_2.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/04_new_grp_2.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
子プロセスと親プロセスの両方でsetpgid()を呼ぶ。なぜ両方で呼ぶ必要があるのかは、APUE参照。
<br />
これにより、プロセスグループが(まだ存在していなければ)新規作成され、子プロセスがそのプロセスグループの最初のプロセスであれば子プロセスはグループリーダーになる。
<br />
もしパイプなどで複数のプロセスがひとつのプロセスグループとして起動した場合は、シェルの実装にも依存するが、新しいプロセスグループを作成した後、そのプロセスグループに所属するようにfork()を繰り返していく。以下の図ではシェルからfork()したプロセスがさらにfork()していく例を示している。シェル側でfork()とsetpgid()を繰り返す場合もあるだろう。
<br />
<a href="./../images/jobcontrols_pty_nohups/04_new_grp_3.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/04_new_grp_3.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> APUE : p269, &quot;9.4 Process Groups&quot;</li>
<li> APUE : p278, &quot;9.9 Shell Execution of Programs&quot;</li></ul>

<h4 id="id841df1">コンソールログインの舞台裏</h4>

<p class="paragraph">
昔は&quot;ダム端末&quot;(dumb-terminal)と呼ばれるディスプレイ・キーボードのセットがあり、複数のダム端末が１つのマシンに接続される事で複数人による並行作業が行われていたらしい。
<br />
時代が少し進むと、ダイアルアップ回線で通信するモデム経由でログインできるようになったらしい。
<br />
2010年現在でも1つのマシンに0または複数のディスプレイ・キーボードが接続される場合があるが、複数人による同時ログインを提供するためのものではなく、マルチディスプレイ環境や、キーボード・モニタ切り替え器を間に挟んで複数マシンで共有する目的が殆どである。リモート接続する場合はtelnetやSSHなどを使う。
<br />
</p>

<p class="paragraph">
マシンに接続されたディスプレイ・キーボードのセットを「コンソール」と呼んでみる。
<br />
コンソールからのログインの舞台裏をまとめる。
<br />
</p>

<ol><li> システム起動時にinitプロセスがコンソール入力を受け付けるプロセスを起動する。<ol><li> NetBSD1.6の場合は &quot;/usr/libexec/getty&quot;, CentOS5.x の場合は &quot;/sbin/mingetty&quot; がコンソール入力を受け付けるプログラム。以降、まとめて &quot;getty&quot; と表記する。</li></ol></li>
<li> どの端末デバイスをopen()し、いくつ起動するのかはinitプロセス用の設定ファイルに書かれている。<ol><li> NetBSD1.6の場合は &quot;/etc/ttys&quot;, CentOS5.x の場合は &quot;/etc/inittab&quot; に書かれている。</li></ol></li>
<li> gettyはinitとは別にそれぞれ独立したセッションを持ち、セッションリーダーとして起動する。</li>
<li> gettyはログインプロンプトをそれぞれの端末に出力し、ログインユーザー名の入力を待つ。</li></ol>

<p class="paragraph">
<a href="./../images/jobcontrols_pty_nohups/05_tty_login_1.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/05_tty_login_1.png" alt="" title=""  /></a>
<br />
</p>

<ol><li> 端末からログインユーザー名が入力されると、gettyは&quot;login&quot;プログラムをexec()する。</li>
<li> &quot;login&quot;プログラムはパスワード入力プロンプトを表示し、端末へのechoをOFFにし、パスワードの入力を待つ。</li>
<li> パスワードが入力されると&quot;login&quot;プログラムは認証処理を行い、有効なユーザー名とパスワードであればログイン処理に進む。ログイン処理の概要は以下の通り。<ol><li> カレントディレクトリをユーザーのホームディレクトリに変更</li>
<li> 端末デバイスのデバイスファイルをchown()</li>
<li> 同デバイスファイルのアクセス権限をユーザーがread/writeできるよう変更</li>
<li> プロセスのグループIDを変更</li>
<li> 環境変数を調整する。&quot;HOME&quot;, &quot;SHELL&quot;, &quot;USER&quot;, &quot;PATH&quot;など</li>
<li> プロセスのユーザーIDを変更</li>
<li> 最後にユーザーのログインシェルをexec()で実行</li></ol></li></ol>

<p class="paragraph">
プラットフォームにより多少の差異はあるかもしれないが、大筋としては上記の流れになる。
<br />
<a href="./../images/jobcontrols_pty_nohups/05_tty_login_2.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/05_tty_login_2.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> APUE : p261, &quot;9.2 Terminal Logins&quot;</li></ul>

<h5 id="id0195cf">NetBSD1.6でのコンソールログイン例</h5>

<p class="paragraph">
&quot;login&quot;プロンプト表示時点：
<br />
</p>
<pre>$ ps ax -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
  0    0    0 67ae00 30001 ??    DKs  [swapper]
  1    0    1 bf9880 30001 ??    Is   init
...
190    1  190 c8cd40   190 ttyE0 Is+  /usr/libexec/getty Pc console
191    1  191 c8cc80   191 ttyE1 Is+  /usr/libexec/getty Pc ttyE1
192    1  192 c8cd00   192 ttyE2 Is+  /usr/libexec/getty Pc ttyE2
193    1  193 c8ccc0   193 ttyE3 Is+  /usr/libexec/getty Pc ttyE3
</pre>
<p class="paragraph">
四つのgettyが起動している。
<br />
</p>

<p class="paragraph">
ユーザー名入力→&quot;Password:&quot; プロンプト表示の時点：
<br />
</p>
<pre>$ ps ax -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
  0    0    0 67ae00 30001 ??    DKs  [swapper]
  1    0    1 bf9880 30001 ??    Is   init
...
190    1  190 c8cd40   190 ttyE0 S&lt;s+ login -p -- msakamoto
191    1  191 c8cc80   191 ttyE1 Is+  /usr/libexec/getty Pc ttyE1
192    1  192 c8cd00   192 ttyE2 Is+  /usr/libexec/getty Pc ttyE2
193    1  193 c8ccc0   193 ttyE3 Is+  /usr/libexec/getty Pc ttyE3
</pre>
<p class="paragraph">
PID:190が &quot;getty&quot; から &quot;login&quot; に変化している。exec()されたことが確認できる。
<br />
</p>

<p class="paragraph">
パスワード入力→ログインシェル起動後：
<br />
</p>
<pre>$ ps ax -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
  0    0    0 67ae00 30001 ??    DKs  [swapper]
  1    0    1 bf9880 30001 ??    Ss   init
...
365    1  365 c6a740   365 ttyE0 Ss+  -bash
191    1  191 c8cc80   191 ttyE1 Is+  /usr/libexec/getty Pc ttyE1
192    1  192 c8cd00   192 ttyE2 Is+  /usr/libexec/getty Pc ttyE2
193    1  193 c8ccc0   193 ttyE3 Is+  /usr/libexec/getty Pc ttyE3
</pre>
<p class="paragraph">
&quot;ttyE0&quot;で&quot;bash&quot;が起動されたことが確認できる。ただしPIDが変化しているため、fork()後にexec()された可能性がある。またPID:190が消えてしまっており、fork()後の親プロセスは終了している可能性が高い。
<br />
</p>

<p class="paragraph">
ログアウト後：
<br />
</p>
<pre>$ ps ax -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
  0    0    0 67ae00 30001 ??    DKs  [swapper]
  1    0    1 bf9880 30001 ??    Ss   init
...
491    1  491 c97240   491 ttyE0 Ss+  /usr/libexec/getty Pc console
191    1  191 c8cc80   191 ttyE1 Is+  /usr/libexec/getty Pc ttyE1
192    1  192 c8cd00   192 ttyE2 Is+  /usr/libexec/getty Pc ttyE2
193    1  193 c8ccc0   193 ttyE3 Is+  /usr/libexec/getty Pc ttyE3
</pre>
<p class="paragraph">
新しいPIDでgettyが起動されている。おそらくinit側でログインシェルの終了を検出し、自動的にgettyを再起動しているのだろう。
<br />
</p>

<h5 id="idf83282">CentOS5.xでのコンソールログイン例</h5>

<p class="paragraph">
&quot;login&quot;プロンプト表示時点：
<br />
</p>
<pre>$ ps ax -o pid,ppid,pgid,sess,tpgid,tty,stat,command
 PID  PPID  PGID  SESS TPGID TT       STAT COMMAND
   1     0     1     1    -1 ?        Ss   init [3]
...
2612     1  2612  2612  2612 tty1     Ss+  /sbin/mingetty tty1
2613     1  2613  2613  2613 tty2     Ss+  /sbin/mingetty tty2
2616     1  2616  2616  2616 tty3     Ss+  /sbin/mingetty tty3
2625     1  2625  2625  2625 tty4     Ss+  /sbin/mingetty tty4
2626     1  2626  2626  2626 tty5     Ss+  /sbin/mingetty tty5
2627     1  2627  2627  2627 tty6     Ss+  /sbin/mingetty tty6
</pre>
<p class="paragraph">
mingettyが6つ起動している。
<br />
</p>

<p class="paragraph">
ユーザー名入力→&quot;Password:&quot; プロンプト表示の時点：
<br />
</p>
<pre>$ ps ax -o pid,ppid,pgid,sess,tpgid,tty,stat,command
 PID  PPID  PGID  SESS TPGID TT       STAT COMMAND
   1     0     1     1    -1 ?        Ss   init [3]
...
2612     1  2612  2612  2612 tty1     Ss+  /bin/login --
2613     1  2613  2613  2613 tty2     Ss+  /sbin/mingetty tty2
2616     1  2616  2616  2616 tty3     Ss+  /sbin/mingetty tty3
2625     1  2625  2625  2625 tty4     Ss+  /sbin/mingetty tty4
2626     1  2626  2626  2626 tty5     Ss+  /sbin/mingetty tty5
2627     1  2627  2627  2627 tty6     Ss+  /sbin/mingetty tty6
</pre>
<p class="paragraph">
PID:2612が &quot;mingetty&quot; から &quot;login&quot; に変化している。exec()されたことが確認できる。
<br />
</p>

<p class="paragraph">
パスワード入力→ログインシェル起動後：
<br />
</p>
<pre>$ ps ax -o pid,ppid,pgid,sess,tpgid,tty,stat,command
 PID  PPID  PGID  SESS TPGID TT       STAT COMMAND
   1     0     1     1    -1 ?        Ss   init [3]
...
2612     1  2612  2612    -1 ?        Ss   login -- msakamoto
15179  2612 15179 15179 15179 tty1     Ss+  -bash
2613     1  2613  2613  2613 tty2     Ss+  /sbin/mingetty tty2
2616     1  2616  2616  2616 tty3     Ss+  /sbin/mingetty tty3
2625     1  2625  2625  2625 tty4     Ss+  /sbin/mingetty tty4
2626     1  2626  2626  2626 tty5     Ss+  /sbin/mingetty tty5
2627     1  2627  2627  2627 tty6     Ss+  /sbin/mingetty tty6
</pre>
<p class="paragraph">
ログインシェルが別プロセスとして起動されている。起動した&quot;login&quot;プロセス自体は残っている。
<br />
</p>

<p class="paragraph">
ログアウト後：
<br />
</p>
<pre>$ ps ax -o pid,ppid,pgid,sess,tpgid,tty,stat,command
 PID  PPID  PGID  SESS TPGID TT       STAT COMMAND
   1     0     1     1    -1 ?        Ss   init [3]
...
15332     1 15332 15332 15332 tty1     Ss+  /sbin/mingetty tty1
2613     1  2613  2613  2613 tty2     Ss+  /sbin/mingetty tty2
2616     1  2616  2616  2616 tty3     Ss+  /sbin/mingetty tty3
2625     1  2625  2625  2625 tty4     Ss+  /sbin/mingetty tty4
2626     1  2626  2626  2626 tty5     Ss+  /sbin/mingetty tty5
2627     1  2627  2627  2627 tty6     Ss+  /sbin/mingetty tty6
</pre>
<p class="paragraph">
ログインシェル・&quot;login&quot;両方とも終了し、&quot;mingetty&quot;が新しいプロセスで起動された。
<br />
</p>

<h4 id="id17ca2b">擬似端末(Pseudo Terminal)を使ったリモートログインの舞台裏</h4>

<p class="paragraph">
telnetやSSHなどのリモートログインでは、最終的に起動されるログインシェルに対して仮想的な端末を提供するため、「擬似端末」(Pseudo Terminal)という機能を使用している。リモートログイン以外でも、scriptコマンドで擬似端末が活用されている。
<br />
</p>

<ul><li> 参考： <a href="./view-563.html" >C言語系/「デーモン君のソース探検」読書メモ/12, script(1)</a></li></ul>

<p class="paragraph">
擬似端末は&quot;master&quot;側と&quot;slave&quot;側の二つのデバイスを提供する。最初は&quot;slave&quot;側のデバイスは利用できない。&quot;master&quot;側のデバイスをopen()すると、対応する&quot;slave&quot;側のデバイスが利用可能となる。&quot;master&quot;側と&quot;slave&quot;側は双方向パイプのようにread/writeを中継する。双方向パイプと異なるのは、端末ならではの機能を利用できる点にある。これにより、単なるread/writeだけでなく、CANONICALモードやECHOモードを初めとする各種端末設定、バッファリングが可能となり、&quot;slave&quot;側を使うプロセスはあたかも実際の端末が接続されたかのように利用することができる。
<br />
</p>

<p class="paragraph">
リモート端末からの入出力がsocket/pipe/fileなどのファイル記述子として利用できる段階をスタート地点として、擬似端末を使ってログインシェルに対して仮想的な端末を提供し、リモート端末からの入出力を接続する流れを紹介する。
<br />
これらの処理はデバイスファイルの操作を含むため、実効(Effective)ユーザーIDがrootになっている必要がある。
<br />
</p>

<ol><li> まず擬似端末の&quot;master&quot;側デバイスをopen()する。</li>
<li> 擬似端末のデバイスドライバが&quot;slave&quot;側デバイスを用意する。<ol><li> あらかじめ用意されていたデバイスファイルをリネームする場合もあれば、実行時に動的にデバイスファイルを作成する場合もある。</li>
<li> 下の図では実行時に動的にデバイスファイルを作成する例を示している。</li></ol></li>
<li> &quot;slave&quot;側デバイスの所有者やパーミッションを適切に設定する。(このため、親プロセスではroot権限が必要)</li>
<li> fork()して子プロセスを生成する。</li></ol>

<p class="paragraph">
<a href="./../images/jobcontrols_pty_nohups/06_create_pty_1.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/06_create_pty_1.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
次は子プロセス側の処理が中心となる。
<br />
</p>
<ol><li> 子プロセス側でsetsid()を呼び、新しいセッションを作成する。</li>
<li> 子プロセス側では不要となる&quot;master&quot;側ファイル記述子や、リモート端末と接続されたsocket/pipe/fileのファイル記述子をclose()する。</li>
<li> &quot;slave&quot;側デバイスをopen()する。<ol><li> SysV系(Solaris, Linux)：セッションリーダーが擬似端末の&quot;slave&quot;側デバイスを最初にopen()することで、自動的にその端末がセッションの「制御端末」(Controlling Terminal)になる。なお非セッションリーダーのプロセスが最初にopen()しても制御端末にはならない。SysV系ではsetsid()でセッション作成後にさらにfork()を一つ挟んだ子プロセス側でDaemon処理を行う場合がある。このとき、親プロセス(=セッションリーダー)はexit()し、非セッションリーダーである子プロセスがDaemon処理を続行することになる。これにより、もしもDaemonが端末デバイスをopen()しても制御端末となることを回避できる。</li>
<li> BSD：open()しただけではControlling Terminalにならない。TIOCSCTTYを引数にioctl()を呼ぶことで、その端末がセッションのControlling Terminalになる。</li></ol></li>
<li> &quot;slave&quot;側をopenしたファイル記述子を、dup2()で標準入力・標準出力・標準エラー出力のファイル記述子にコピーする。</li></ol>

<p class="paragraph">
<a href="./../images/jobcontrols_pty_nohups/06_create_pty_2.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/06_create_pty_2.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
この段階で、擬似端末を使った入出力の基本が整った。リモートログインの場合なら、続けて子プロセス側のユーザーIDやグループID、環境変数やカレントディレクトリを調整後、ログインシェルをexec()する。
<br />
</p>

<p class="paragraph">
<a href="./../images/jobcontrols_pty_nohups/06_create_pty_3.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/06_create_pty_3.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> APUE : p675 - 707, &quot;19 Pseudo Terminals&quot;</li></ul>

<p class="paragraph">
SysVにおけるDaemon作成時の制御端末の注意点：
<br />
</p>
<ul><li> APUE : P272, &quot;9.6 Controlling Terminal&quot;</li>
<li> APUE : P425, &quot;13.3 Coding Rules&quot;</li></ul>

<h4 id="id7571e1">端末入出力とジョブコントロール</h4>

<p class="paragraph">
端末の入出力は、その端末を制御端末とするセッションのフォアグラウンドプロセスグループに接続される。
<br />
</p>

<p class="paragraph">
<a href="./../images/jobcontrols_pty_nohups/07_terminal_io.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/07_terminal_io.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
端末からSIGTSTP(^Z)が送信された場合、シェルのジョブコントロール機能によりフォアグラウンド・バックグラウンドが切り替わる。
<br />
</p>

<p class="paragraph">
ログインシェルがバックグラウンドで、他にバックグラウンドのプロセスグループが存在しない場合：
<br />
<a href="./../images/jobcontrols_pty_nohups/08_switch_terminal_io_1.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/08_switch_terminal_io_1.png" alt="" title=""  /></a>
<br />
シェルがtcsetpgrp()を呼び、端末に新しいフォアグラウンドプロセスグループを通知する。
<br />
以降はシェルがフォアグラウンドプロセスグループに切り替わり、端末の入出力を引き受ける：
<br />
<a href="./../images/jobcontrols_pty_nohups/08_switch_terminal_io_2.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/08_switch_terminal_io_2.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
一旦シェルがフォアグラウンドに切り替わった後、別のバックグラウンドジョブをフォアグラウンドジョブに切り替える場合：
<br />
<a href="./../images/jobcontrols_pty_nohups/08_switch_terminal_io_3.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/08_switch_terminal_io_3.png" alt="" title=""  /></a>
<br />
対象のバックグラウンドジョブがSTOP状態になっていれば、SIGCONTを送信し再開させる。また、tcsetpgrp()を呼び出し新しいフォアグラウンドプロセスを通知する。
<br />
以降は切り替わったフォアグラウンドジョブが端末の入出力を引き受ける：
<br />
<a href="./../images/jobcontrols_pty_nohups/08_switch_terminal_io_4.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/08_switch_terminal_io_4.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> APUE : p272, &quot;9.6 Controlling Terminal&quot;</li>
<li> APUE : p274, &quot;9.8 Job Control&quot;</li></ul>

<h4 id="iddf8abd">端末とSIGHUP</h4>

<p class="paragraph">
ダム端末やモデム経由でのログインでは、モデムの回線またはダム端末の物理的な切断が&quot;hangup&quot;の合図だったらしい。
<br />
擬似端末の場合、&quot;master&quot;側デバイスのファイル記述子が全てclose()されたのを&quot;hangup&quot;の合図として、端末のデバイスドライバがセッションリーダーのプロセスにSIGHUPを送信する。
<br />
<a href="./../images/jobcontrols_pty_nohups/09_sighup_1.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/09_sighup_1.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
フォアグラウンド・バックグラウンドの区別ではなく、「セッションリーダー」に対して送信される点に注意する。
<br />
したがって、ログインシェルから起動されたフォアグラウンドプロセスが実行中であったとしても、バックグラウンドに切り替わっているログインシェルのプロセスにSIGHUPが送信される。
<br />
<a href="./../images/jobcontrols_pty_nohups/09_sighup_2.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/09_sighup_2.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
ログインシェルに限らず、対話的に動作するプログラムのほとんどはSIGHUPを受信したら終了処理を開始する。またSIGHUPのデフォルト処理はプロセス終了となっている。デーモンプロセスの場合は終了処理ではなく、設定ファイルやログファイルの再読み込みといった処理が慣例となっている。
<br />
</p>

<p class="paragraph">
SIGHUPの受信にかかわらず、プロセスが終了するとき、そのプロセスがセッションリーダーだった場合、カーネルからそのセッションのフォアグラウンドプロセスグループに対してSIGHUPが送信される。
<br />
<a href="./../images/jobcontrols_pty_nohups/09_sighup_3.png" title="" target="_blank"><img src="./../images/jobcontrols_pty_nohups/09_sighup_3.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
セッションリーダ終了時のSIGHUPについて、NetBSD1.6のカーネルを追ったときのメモがあるので、参考にどうぞ：
<br />
</p>
<ul><li> <a href="./view-851.html" >C言語系/「デーモン君のソース探検」読書メモ/A11(Intermission), exit(2) → wait4(2)</a><ul><li> &quot;「へ～」その１：セッションリーダーのプロセスが終了するとき、同じ制御端末のプロセス群にSIGHUP送信してる箇所&quot;</li></ul></li></ul>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> APUE : p272, &quot;9.6 Controlling Terminal&quot;, Figure 9.7</li>
<li> APUE : p294, &quot;10.2 Signal Concepts&quot;, SIGHUP</li></ul>

<h3 id="id71d8f3">WHY?</h3>

<p class="paragraph">
単調で退屈な復習だったが、ここまでまとめなおした段階で、自分は以下の疑問を抱いた。
<br />
</p>
<dl>
<dt> バックグラウンドジョブはそもそもSIGHUPを受信しない？ </dt>
<dd>
<p class="paragraph">
セッションリーダーであるプロセスが終了するとき、カーネルがSIGHUPを送信する対象はそのセッションのフォアグラウンドジョブであり、バックグラウンドジョブは放置されている。つまりバックグラウンドジョブは基本的にはSIGHUPを受信することは無いのではないか？
<br />
さらに、そもそもSIGHUPを受信しないのであればnohupをわざわざバックグラウンドで起動する意味は無い。
<br />
</p>

<p class="paragraph">
ここでようやく、タイトルにも掲げた<strong>「なぜnohupをバックグランドジョブとして起動するのが定番なのか？」</strong>という疑問が生じる。
<br />
</p></dd>
</dl>

<p class="paragraph">
端末デバイスやカーネルは、おそらくAPUEの通りに動いているととりあえず信用してみる。となると、残る構成要素であるログインシェルが怪しい。
<br />
</p>

<p class="paragraph">
・・・と、記事を書いている今だからすんなりと目星をつけてますが、調査の段階ではそこまで分析できていない状態でいろいろサンプルコードを作ってはputtyを強制終了したり、ログアウトしたりと組み合わせを弄ってました。それでもなかなかシグナルの発生パターンの切り分けができず、そこでようやく「あ、もしかしてログインシェルが何かしてる？」と気づいた次第。
<br />
最初はCentOS5.x上で弄ってたのですが、これに気づいたあとはカーネルを含めてソースを読める環境を整えていたNetBSD1.6に移り、次の順序で徐々に標的を追い詰めていきました。
<br />
</p>
<ol><li> 簡単なサンプルコードで擬似端末の動作確認</li>
<li> 端末デバイスドライバがSIGHUPをセッションリーダーに送信する挙動の確認</li>
<li> Bashのソースを読んで、<strong>SIGTERMとSIGCONTを送信するケースを確認</strong></li>
<li> ここまでの確認に基づいた「ログインシェル終了時のシグナル送信パターン」をnohupで確認</li></ol>

<p class="paragraph">
これらの確認作業の詳細や、それに使用したサンプルコードの解説は長くなるので後回しにし、&quot;WHY?&quot;に対する&quot;BECAUSE&quot;を先にまとめる。
<br />
なお、<strong>以降の記事ではログインシェル = Bashとして話を進めていく。</strong>
<br />
他のシェルでも同じ動作が成立するかは確認していない。使用するシェルのmanページを調べるか、&quot;nohup シェル名&quot;でWeb検索してみてほしい。
<br />
</p>

<h4 id="id68fa75">BECAUSE : ログインシェル(今回はBash)が、終了時にSIGHUP/SIGTERM/SIGCONTをバックグランドジョブに送信する「場合がある」から。</h4>
<p class="paragraph">
まずセッションリーダであるbash終了時、カーネルが放置するバックグランドジョブはbash側でSIGHUP/SIGTERM/SIGCONTを適宜組み合わせて送信し、終了させている。もちろん後述するようにシグナルを送信せず放置し、結果としてジョブを継続させる場合もある。
<br />
</p>

<p class="paragraph">
bashが終了する流れは、大きく次の二通りがある。
<br />
</p>
<ol><li> コマンドラインで&quot;exit&quot;や&quot;logout&quot;コマンドを入力されて終了する流れ</li>
<li> 端末デバイスドライバがセッションリーダでもあるbashにSIGHUPを送信し、終了する流れ<ol><li> 原因１：モデム回線のhangup</li>
<li> 原因２：端末エミュレータの終了などで擬似端末の&quot;master&quot;側のファイル記述子が全てcloseされる</li></ol></li></ol>

<p class="paragraph">
また&quot;exit&quot;や&quot;logout&quot;による終了時にSIGHUPの送信有無を設定することもできる。huponexitオプションがbashでは提供されている。
<br />
</p>
<pre># 現在設定の確認
$ shopt huponexit
huponexit       off

# ONに設定
$ shopt -s huponexit

# OFFに設定
$ shopt -u huponexit
</pre>

<p class="paragraph">
さらに&quot;disown&quot;シェルコマンドを使うことで、SIGHUPの送信対象から除外するための内部的な印を、ジョブに対して設定することもできる。以降、この印の有無を実際のbashソースコード上でのフラグ名である「&quot;J_NOHUP&quot;の有無」として表記する。
<br />
</p>

<p class="paragraph">
実際の調査ではbashのソースコードをgrepして流れを掴んでいった。ポイントとなるソースコードは後ほど紹介する。
<br />
ここでは、調査結果をまとめたシグナル送信のパターン表を先に解説する。
<br />
</p>

<dl>
<dt> シグナル送信パターン１：&quot;exit&quot; or &quot;logout&quot; による終了時 </dt>
<dd>
<p class="paragraph">
&quot;huponexit&quot; ON:
<br />
</p>
<table>
	<tr>
		<td>                         </td>
		<td> SIGHUP </td>
		<td> SIGCONT </td>
		<td> SIGTERM </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP有 </td>
		<td> -      </td>
		<td> -       </td>
		<td> -       </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP無 </td>
		<td> o      </td>
		<td> -       </td>
		<td> -       </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP有    </td>
		<td> -      </td>
		<td> o       </td>
		<td> o       </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP無    </td>
		<td> o      </td>
		<td> o       </td>
		<td> o       </td>
	</tr>
</table>

<p class="paragraph">
&quot;huponexit&quot; OFF:
<br />
</p>
<table>
	<tr>
		<td>                         </td>
		<td> SIGHUP </td>
		<td> SIGCONT </td>
		<td> SIGTERM </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP有 </td>
		<td> -      </td>
		<td> -       </td>
		<td> -       </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP無 </td>
		<td> -      </td>
		<td> -       </td>
		<td> -       </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP有    </td>
		<td> -      </td>
		<td> o       </td>
		<td> o       </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP無    </td>
		<td> -      </td>
		<td> o       </td>
		<td> o       </td>
	</tr>
</table></dd>
<dt> シグナル送信パターン２：SIGHUP受信による終了時 </dt>
<dd>
<table>
	<tr>
		<td>                         </td>
		<td> SIGHUP </td>
		<td> SIGCONT </td>
		<td> SIGTERM </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP有 </td>
		<td> -      </td>
		<td> -       </td>
		<td> -       </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP無 </td>
		<td> o      </td>
		<td> -       </td>
		<td> -       </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP有    </td>
		<td> -      </td>
		<td> o       </td>
		<td> o       </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP無    </td>
		<td> o      </td>
		<td> o       </td>
		<td> o       </td>
	</tr>
</table></dd>
</dl>

<p class="paragraph">
複数回送信される可能性があっても一つの&quot;o&quot;にまとめている。
<br />
</p>

<p class="paragraph">
よく見ると、シグナル送信パターン１の&quot;huponexit&quot; ONのケースはシグナル送信パターン２と同じである。
<br />
</p>

<p class="paragraph">
この表を使うことで、本記事の冒頭で紹介した２つのパターンを説明できるようになる。
<br />
</p>

<h5 id="id712f63">「nohupを使わなくても実行を続けることが出来るパターン」の解説</h5>

<p class="paragraph">
このパターンはnohup無しでバックグランド実行し、&quot;exit&quot;でbashを終了している。また&quot;huponexit&quot;はデフォルト=OFFの状態となっている。jobsコマンドの結果ではバックグランドジョブは&quot;Running&quot;となっている。disownは呼んでいないのでJ_NOHUPは無し。
<br />
</p>

<p class="paragraph">
以上より、「シグナル送信パターン１」の&quot;huponexit&quot; OFF, 「RUNNING状態 + J_NOHUP無」の行を見ればよい:
<br />
</p>
<table>
	<tr>
		<td>                         </td>
		<td> SIGHUP </td>
		<td> SIGCONT </td>
		<td> SIGTERM </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP無 </td>
		<td> -      </td>
		<td> -       </td>
		<td> -       </td>
	</tr>
</table>

<p class="paragraph">
このように、SIGHUP/SIGCONT/SIGTERMのいずれも送信されない。またバックグラウンドジョブなので、カーネルからSIGHUPが送信されることも無い。これがnohupを使わなくても実行を続けられる理由である。
<br />
</p>

<h5 id="id4e15df">「nohupを付けてもログアウト時に終了してしまうパターン」の解説</h5>

<p class="paragraph">
このパターンでは、&quot;exit&quot;によるbash終了時、nohupで起動したジョブはバックグラウンドで&quot;Stopped&quot;になっている。その他の条件は上記と同じなので、「シグナル送信パターン１」の&quot;huponexit&quot; OFF, 「STOP状態 + J_NOHUP無」の行を見ればよい：
<br />
</p>
<table>
	<tr>
		<td>                         </td>
		<td> SIGHUP </td>
		<td> SIGCONT </td>
		<td> SIGTERM </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP無    </td>
		<td> -      </td>
		<td> o       </td>
		<td> o       </td>
	</tr>
</table>

<p class="paragraph">
SIGCONTとSIGTERMが送信される。前述の通りnohupではSIGHUP以外のシグナルハンドラはデフォルトのままジョブを起動するため、SIGTERMによるデフォルト動作、すなわちプロセス終了となる。これがnohupを使ったとしても、ログアウト時にジョブも一緒に終了してしまった理由である。
<br />
</p>

<h5 id="id898e9c">「nohupをバックグラウンドジョブとして起動する必要があるパターン」 = SIGHUPが送信されるパターン</h5>

<p class="paragraph">
前半のまとめとして、nohupをバックグランドジョブとして起動する必要があるパターン = SIGHUPが送信されるパターンを解説する。
<br />
</p>

<p class="paragraph">
&quot;huponexit&quot;がデフォルトのOFFのままだとすれば、このパターンは二つに絞られる。「シグナル送信パターン２」、つまりモデムhangupや端末エミュレータの終了などによりセッションリーダであるbashがSIGHUPを受信したときの、J_NOHUP無の行である：
<br />
</p>
<table>
	<tr>
		<td>                         </td>
		<td> SIGHUP </td>
		<td> SIGCONT </td>
		<td> SIGTERM </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP無 </td>
		<td> o      </td>
		<td> -       </td>
		<td> -       </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP無    </td>
		<td> o      </td>
		<td> o       </td>
		<td> o       </td>
	</tr>
</table>

<p class="paragraph">
nohupではSIGTERMを防げないので &quot;STOP状態&quot; を除外すれば、残るは「RUNNING状態 + J_NOHUP無」の行となる。
<br />
</p>

<p class="paragraph">
hello.shを使って確認してみる。まずnohupを使わない場合：
<br />
</p>
<pre>$ ./hello.sh &gt; out.txt &amp;
[1] 465
$ jobs
[1]+  Running                 ./hello.sh &gt;out.txt &amp;
$
</pre>
<p class="paragraph">
ここで端末エミュレータ側を終了させてみる。puttyウインドウの「x」ボタンをクリックして終了させてみた。
<br />
別端末で確認してみると、終了すると同時にout.txtの更新も止まり、psコマンドからもhello.shやsleepプロセスが消えたことを確認できた。SIGHUP受信により終了したものと思われる。
<br />
</p>

<p class="paragraph">
次にnohupを使う場合、こちらはジョブが残り、実行継続されると予想される：
<br />
</p>
<pre>$ nohup ./hello.sh &amp;
[1] 512
$ sending output to nohup.out   # nohupからの出力

$ jobs
[1]+  Running                 nohup ./hello.sh &amp;
$
</pre>
<p class="paragraph">
ここで上と同様、端末エミュレータ側を終了させる。別端末で確認してみると、hello.shの実行は継続しておりnohup.outの出力も更新されている。SIGHUPを受信しても、nohupにより無視され、ジョブの実行が継続されることを確認できた。
<br />
</p>

<h4 id="ida1b382">小休憩</h4>

<p class="paragraph">
以上で本記事の前半が終わる。後半はNetBSD1.6およびCentOS5.x上で、サンプルコードを使った擬似端末のSIGHUP確認やBashのソースコードの確認、nohupの動作パターンの追加確認などを詳しく紹介していく。
<br />
最後に「いともたやすく行われるえげつないnohup」と題しnohupを使うときの注意点をまとめ、そして参考資料の一覧を載せて本記事は終わる。
<br />
</p>

<p class="paragraph">
NetBSD1.6とCentOS5.xの二種類のプラットフォーム上で、それぞれで同じようなサンプルコードと動作確認を行う過程を紹介していくため、また長丁場となる。時間が惜しい方やサンプルコードと実験結果などの詳細までは興味が無い方などは、「いともたやすく行われるえげつないnohup」まで読み飛ばしてもらっても構わない。
<br />
</p>

<hr />

<p class="paragraph">
それでは小休憩の後、サンプルコードと実験・動作確認の詳細を解説する。
<br />
</p>

<h3 id="idc65799">NetBSD 1.6 における擬似端末, Bash, nohupの確認</h3>

<p class="paragraph">
NetBSD1.6上で以下の実験をしていく。
<br />
</p>
<ol><li> 擬似端末の使い方を簡単なサンプルで確認</li>
<li> Bash終了時のシグナル送信の組み合わせを実際のソースコードを読んで確認</li>
<li> Bash終了時のシグナル送信とnohupの組み合わせを再確認</li></ol>

<h4 id="id9c8517">擬似端末を使ったサンプル</h4>

<p class="paragraph">
擬似端末を使ってみる。特に、擬似端末のmaster側のファイル記述子を全てcloseすると、slave側擬似端末の制御プロセスにSIGHUPが送信される動作に注目する。NetBSD側の close(2) manpageには記載されていないが、SUSv3のclose(2)の解説ではこの挙動が載っている。
<br />
</p>

<h5 id="ida94c54">NetBSD版 擬似端末実験用サンプルコード mypty.c</h5>

<ul><li> 参考：APUE 19.3 Opening Pseudo-Terminal Devices</li>
<li> NetBSD1.6提供のoptnpty()(libutil)を使用</li>
<li> プログラム簡素化のため端末属性は変更しない。</li>
<li> EOF(^D)入力後 master 側のファイル記述子を全てclose()し、10秒間sleep()する。この間にslave側擬似端末の制御プロセスがSIGHUPを受信したか確認できるようにしている。</li></ul>

<p class="paragraph">
mypty.c:
<br />
</p>
<div class="hl-main"><pre><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdio.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdlib.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">unistd.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">errno.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">fcntl.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">signal.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">termios.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">sys/ioctl.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> for CentOS5.x </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> #include &lt;pty.h&gt; </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> for NetBSD1.6 </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">util.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span class="hl-identifier">pid_t</span><span class="hl-code">
</span><span class="hl-identifier">pty_fork</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> *</span><span class="hl-identifier">ptrfdm</span><span class="hl-code">, </span><span >char</span><span class="hl-code"> *</span><span class="hl-identifier">slave_name</span><span class="hl-code">,
    </span><span >struct</span><span class="hl-code"> </span><span class="hl-identifier">termios</span><span class="hl-code"> *</span><span class="hl-identifier">slave_termios</span><span class="hl-code">,
    </span><span >struct</span><span class="hl-code"> </span><span class="hl-identifier">winsize</span><span class="hl-code"> *</span><span class="hl-identifier">slave_winsize</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">fdm</span><span class="hl-code">, </span><span class="hl-identifier">fds</span><span class="hl-code">;
    </span><span class="hl-identifier">pid_t</span><span class="hl-code"> </span><span class="hl-identifier">pid</span><span class="hl-code">;
    </span><span >char</span><span class="hl-code"> </span><span class="hl-identifier">pts_name</span><span class="hl-brackets">[</span><span class="hl-number">20</span><span class="hl-brackets">]</span><span class="hl-code">;
    </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-identifier">openpty</span><span class="hl-brackets">(</span><span class="hl-code">&amp;</span><span class="hl-identifier">fdm</span><span class="hl-code">, &amp;</span><span class="hl-identifier">fds</span><span class="hl-code">, </span><span class="hl-identifier">slave_name</span><span class="hl-code">, </span><span class="hl-identifier">slave_termios</span><span class="hl-code">, </span><span class="hl-identifier">slave_winsize</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">openpty()</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-brackets">(</span><span class="hl-identifier">pid</span><span class="hl-code"> = </span><span class="hl-identifier">fork</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">fork()</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">else</span><span class="hl-code"> </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-number">0</span><span class="hl-code"> == </span><span class="hl-identifier">pid</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> child </span><span class="hl-mlcomment">*/</span><span class="hl-code">
 
        </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> create new session, child becomes session leader,
         * new process group leader, has no control terminal yet.
         </span><span class="hl-mlcomment">*/</span><span class="hl-code">
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-identifier">setsid</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">setsid()</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> open pty slave device 1st, then child becomes
         * control process.
         </span><span class="hl-mlcomment">*/</span><span class="hl-code">
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-identifier">open</span><span class="hl-brackets">(</span><span class="hl-identifier">slave_name</span><span class="hl-code">, </span><span class="hl-identifier">O_RDWR</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">open(slave_name)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> close unused pty master device </span><span class="hl-mlcomment">*/</span><span class="hl-code">
        </span><span class="hl-identifier">close</span><span class="hl-brackets">(</span><span class="hl-identifier">fdm</span><span class="hl-brackets">)</span><span class="hl-code">;
 
        </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> set control terminal </span><span class="hl-mlcomment">*/</span><span class="hl-code">
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-identifier">ioctl</span><span class="hl-brackets">(</span><span class="hl-identifier">fds</span><span class="hl-code">, </span><span class="hl-identifier">TIOCSCTTY</span><span class="hl-code">, </span><span class="hl-brackets">(</span><span >char</span><span class="hl-code">*</span><span class="hl-brackets">)</span><span class="hl-number">0</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">ioctl(fds, TIOCSCTTY)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
 
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span >NULL</span><span class="hl-code"> != </span><span class="hl-identifier">slave_termios</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-identifier">tcsetattr</span><span class="hl-brackets">(</span><span class="hl-identifier">fds</span><span class="hl-code">, </span><span class="hl-identifier">TCSANOW</span><span class="hl-code">, </span><span class="hl-identifier">slave_termios</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                 </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">tcsetattr(slave_termios)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span >NULL</span><span class="hl-code"> != </span><span class="hl-identifier">slave_winsize</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-identifier">ioctl</span><span class="hl-brackets">(</span><span class="hl-identifier">fds</span><span class="hl-code">, </span><span class="hl-identifier">TIOCSWINSZ</span><span class="hl-code">, </span><span class="hl-identifier">slave_winsize</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                 </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">ioctl(TIOCSWINSZ)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> stdin/out/err fileno duplication </span><span class="hl-mlcomment">*/</span><span class="hl-code">
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">STDIN_FILENO</span><span class="hl-code"> != </span><span class="hl-identifier">dup2</span><span class="hl-brackets">(</span><span class="hl-identifier">fds</span><span class="hl-code">, </span><span class="hl-identifier">STDIN_FILENO</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">dup2(STDIN_FILENO)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">STDOUT_FILENO</span><span class="hl-code"> != </span><span class="hl-identifier">dup2</span><span class="hl-brackets">(</span><span class="hl-identifier">fds</span><span class="hl-code">, </span><span class="hl-identifier">STDOUT_FILENO</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">dup2(STDOUT_FILENO)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">STDERR_FILENO</span><span class="hl-code"> != </span><span class="hl-identifier">dup2</span><span class="hl-brackets">(</span><span class="hl-identifier">fds</span><span class="hl-code">, </span><span class="hl-identifier">STDERR_FILENO</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">dup2(STDERR_FILENO)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-identifier">close</span><span class="hl-brackets">(</span><span class="hl-identifier">fds</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">0</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">else</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> parent </span><span class="hl-mlcomment">*/</span><span class="hl-code">
        *</span><span class="hl-identifier">ptrfdm</span><span class="hl-code"> = </span><span class="hl-identifier">fdm</span><span class="hl-code">;
        </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-identifier">pid</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span >#define</span><span class="hl-code"> </span><span class="hl-identifier">BUFSIZE</span><span class="hl-code"> </span><span class="hl-number">512</span><span ></span><span class="hl-code">
</span><span >static</span><span class="hl-code"> </span><span >volatile</span><span class="hl-code"> </span><span class="hl-identifier">sig_atomic_t</span><span class="hl-code"> </span><span class="hl-identifier">sigcaught</span><span class="hl-code">;
</span><span >static</span><span class="hl-code"> </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">sig_term</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">signo</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-identifier">sigcaught</span><span class="hl-code"> = </span><span class="hl-number">1</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">loop</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">ptym</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span class="hl-identifier">pid_t</span><span class="hl-code"> </span><span class="hl-identifier">child</span><span class="hl-code">;
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">nread</span><span class="hl-code">;
    </span><span >char</span><span class="hl-code"> </span><span class="hl-identifier">buf</span><span class="hl-brackets">[</span><span class="hl-identifier">BUFSIZE</span><span class="hl-brackets">]</span><span class="hl-code">;
    </span><span >struct</span><span class="hl-code"> </span><span class="hl-identifier">sigaction</span><span class="hl-code"> </span><span class="hl-identifier">sa</span><span class="hl-code">;
    </span><span class="hl-identifier">sa</span><span class="hl-code">.</span><span class="hl-identifier">sa_handler</span><span class="hl-code"> = </span><span class="hl-identifier">sig_term</span><span class="hl-code">;
    </span><span class="hl-identifier">sigemptyset</span><span class="hl-brackets">(</span><span class="hl-code">&amp;</span><span class="hl-identifier">sa</span><span class="hl-code">.</span><span class="hl-identifier">sa_mask</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-identifier">sa</span><span class="hl-code">.</span><span class="hl-identifier">sa_flags</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">;
</span><span >#ifdef</span><span class="hl-code"> </span><span class="hl-identifier">SA_INTERRUPT</span><span ></span><span class="hl-code">
    </span><span class="hl-identifier">sa</span><span class="hl-code">.</span><span class="hl-identifier">sa_flags</span><span class="hl-code"> |= </span><span class="hl-identifier">SA_INTERRUPT</span><span class="hl-code">;
</span><span >#endif</span><span ></span><span class="hl-code">
    </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-brackets">(</span><span class="hl-identifier">child</span><span class="hl-code"> = </span><span class="hl-identifier">fork</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">fork() for loop</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">else</span><span class="hl-code"> </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-number">0</span><span class="hl-code"> == </span><span class="hl-identifier">child</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> child copies stdin to ptym </span><span class="hl-mlcomment">*/</span><span class="hl-code">
        </span><span class="hl-reserved">for</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">;;</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-brackets">(</span><span class="hl-identifier">nread</span><span class="hl-code"> = </span><span class="hl-identifier">read</span><span class="hl-brackets">(</span><span class="hl-identifier">STDIN_FILENO</span><span class="hl-code">, </span><span class="hl-identifier">buf</span><span class="hl-code">, </span><span class="hl-reserved">sizeof</span><span class="hl-brackets">(</span><span class="hl-identifier">buf</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">read(stdin)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">else</span><span class="hl-code"> </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-number">0</span><span class="hl-code"> == </span><span class="hl-identifier">nread</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">child(read stdin, write ptym) detect EOF from stdin.</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-reserved">break</span><span class="hl-code">; </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> EOF </span><span class="hl-mlcomment">*/</span><span class="hl-code">
            </span><span class="hl-brackets">}</span><span class="hl-code">
            </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">nread</span><span class="hl-code"> != </span><span class="hl-identifier">write</span><span class="hl-brackets">(</span><span class="hl-identifier">ptym</span><span class="hl-code">, </span><span class="hl-identifier">buf</span><span class="hl-code">, </span><span class="hl-identifier">nread</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">write(ptym)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">send SIGTERM to parent...</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">kill</span><span class="hl-brackets">(</span><span class="hl-identifier">getppid</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">, </span><span class="hl-identifier">SIGTERM</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">close</span><span class="hl-brackets">(</span><span class="hl-identifier">ptym</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">PID[%d] closed ptym, sleeping(10)...</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">getpid</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">sleep</span><span class="hl-brackets">(</span><span class="hl-number">10</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">PID[%d] awaken, terminates.</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">getpid</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">0</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-identifier">sigaction</span><span class="hl-brackets">(</span><span class="hl-identifier">SIGTERM</span><span class="hl-code">, &amp;</span><span class="hl-identifier">sa</span><span class="hl-code">, </span><span >NULL</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">sigaction(SIGTERM)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-reserved">for</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">;;</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">errno</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">;
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-number">0</span><span class="hl-code"> &gt;= </span><span class="hl-brackets">(</span><span class="hl-identifier">nread</span><span class="hl-code"> = </span><span class="hl-identifier">read</span><span class="hl-brackets">(</span><span class="hl-identifier">ptym</span><span class="hl-code">, </span><span class="hl-identifier">buf</span><span class="hl-code">, </span><span class="hl-reserved">sizeof</span><span class="hl-brackets">(</span><span class="hl-identifier">buf</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> error or signal or EOF </span><span class="hl-mlcomment">*/</span><span class="hl-code">
            </span><span class="hl-reserved">break</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">nread</span><span class="hl-code"> != </span><span class="hl-identifier">write</span><span class="hl-brackets">(</span><span class="hl-identifier">STDOUT_FILENO</span><span class="hl-code">, </span><span class="hl-identifier">buf</span><span class="hl-code">, </span><span class="hl-identifier">nread</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">write(stdout)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-number">0</span><span class="hl-code"> == </span><span class="hl-identifier">nread</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">parent(read ptym, write stdin) detect EOF from ptym.</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">errno</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">read(ptym)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-number">0</span><span class="hl-code"> == </span><span class="hl-identifier">sigcaught</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">send SIGTERM to child(%d)...</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">child</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> error or EOF, tell child termination </span><span class="hl-mlcomment">*/</span><span class="hl-code">
        </span><span class="hl-identifier">kill</span><span class="hl-brackets">(</span><span class="hl-identifier">child</span><span class="hl-code">, </span><span class="hl-identifier">SIGTERM</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">else</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">child sent SIGTERM, maybe terminated.</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-identifier">close</span><span class="hl-brackets">(</span><span class="hl-identifier">ptym</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">PID[%d] closed ptym, sleeping(10)...</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">getpid</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-identifier">sleep</span><span class="hl-brackets">(</span><span class="hl-number">10</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">PID[%d] awaken, terminates.</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">getpid</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">argc</span><span class="hl-code">, </span><span >char</span><span class="hl-code"> *</span><span class="hl-identifier">argv</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">fdm</span><span class="hl-code">;
    </span><span class="hl-identifier">pid_t</span><span class="hl-code"> </span><span class="hl-identifier">pid</span><span class="hl-code">;
    </span><span >char</span><span class="hl-code"> </span><span class="hl-identifier">slave_name</span><span class="hl-brackets">[</span><span class="hl-number">20</span><span class="hl-brackets">]</span><span class="hl-code">;
    </span><span >struct</span><span class="hl-code"> </span><span class="hl-identifier">termios</span><span class="hl-code"> </span><span class="hl-identifier">orig_termios</span><span class="hl-code">;
    </span><span >struct</span><span class="hl-code"> </span><span class="hl-identifier">winsize</span><span class="hl-code"> </span><span class="hl-identifier">size</span><span class="hl-code">;
 
    </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-number">2</span><span class="hl-code"> &gt; </span><span class="hl-identifier">argc</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">usage: %s commands...</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">argv</span><span class="hl-brackets">[</span><span class="hl-number">0</span><span class="hl-brackets">]</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">1</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
 
    </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-identifier">tcgetattr</span><span class="hl-brackets">(</span><span class="hl-identifier">STDIN_FILENO</span><span class="hl-code">, &amp;</span><span class="hl-identifier">orig_termios</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">tcgetattr()</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-identifier">ioctl</span><span class="hl-brackets">(</span><span class="hl-identifier">STDIN_FILENO</span><span class="hl-code">, </span><span class="hl-identifier">TIOCGWINSZ</span><span class="hl-code">, &amp;</span><span class="hl-identifier">size</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">ioctl(TIOCGWINSZ)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-identifier">pid</span><span class="hl-code"> = </span><span class="hl-identifier">pty_fork</span><span class="hl-brackets">(</span><span class="hl-code">&amp;</span><span class="hl-identifier">fdm</span><span class="hl-code">, </span><span class="hl-identifier">slave_name</span><span class="hl-code">, &amp;</span><span class="hl-identifier">orig_termios</span><span class="hl-code">, &amp;</span><span class="hl-identifier">size</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-number">0</span><span class="hl-code"> == </span><span class="hl-identifier">pid</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-identifier">execvp</span><span class="hl-brackets">(</span><span class="hl-identifier">argv</span><span class="hl-brackets">[</span><span class="hl-number">1</span><span class="hl-brackets">]</span><span class="hl-code">, &amp;</span><span class="hl-identifier">argv</span><span class="hl-brackets">[</span><span class="hl-number">1</span><span class="hl-brackets">]</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">execvp()</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">slave name = %s</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">slave_name</span><span class="hl-brackets">)</span><span class="hl-code">;
 
    </span><span class="hl-identifier">loop</span><span class="hl-brackets">(</span><span class="hl-identifier">fdm</span><span class="hl-brackets">)</span><span class="hl-code">;
 
    </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">done</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
 
    </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">0</span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>

<p class="paragraph">
コンパイル : openpty()を使うので所有者をrootにしてset-user-idをセット + &quot;-lutil&quot;をコンパイルオプションに追加
<br />
</p>
<pre>$ su
# cc -o mypty mypty.c -lutil &amp;&amp; chmod +s ./mypty
</pre>

<h5 id="id5c3c42">NetBSD版 slave側擬似端末の制御プロセス用サンプルコード mycat_detectHUP.c</h5>

<ul><li> 標準C関数のfgets()で標準入力を読み、fprintf()で標準出力に自分のPIDを付けて出力する。</li>
<li> SIGHUPを受信すると標準エラー出力にメッセージを出力する。</li></ul>

<p class="paragraph">
mycat_detectHUP.c:
<br />
</p>
<div class="hl-main"><pre><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdio.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdlib.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">fcntl.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">sys/stat.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">unistd.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">signal.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">errno.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
 
</span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">sig_hup</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">signo</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">detect SIGHUP(%d)</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">signo</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-identifier">fflush</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-brackets">)</span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">argc</span><span class="hl-code">, </span><span >char</span><span class="hl-code"> *</span><span class="hl-identifier">argv</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span >char</span><span class="hl-code"> </span><span class="hl-identifier">buf</span><span class="hl-brackets">[</span><span class="hl-number">200</span><span class="hl-brackets">]</span><span class="hl-code">;
    </span><span >struct</span><span class="hl-code"> </span><span class="hl-identifier">sigaction</span><span class="hl-code"> </span><span class="hl-identifier">sa</span><span class="hl-code">;
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">fderr</span><span class="hl-code">;
 
    </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> mypty.cから直接起動され、slave側の擬似端末の制御プロセスとなることを想定している。
     * よって、標準エラー出力のシェルによるリダイレクトが使えない。
     * このため、いったんSTDERR_FILENOをclose()し、自分で標準エラー出力用のファイルをopen()する。
     </span><span class="hl-mlcomment">*/</span><span class="hl-code">
    </span><span class="hl-identifier">close</span><span class="hl-brackets">(</span><span class="hl-identifier">STDERR_FILENO</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-brackets">(</span><span class="hl-identifier">fderr</span><span class="hl-code"> = </span><span class="hl-identifier">open</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">/tmp/mycat_detectHUP</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">O_CREAT</span><span class="hl-code"> | </span><span class="hl-identifier">O_TRUNC</span><span class="hl-code"> | </span><span class="hl-identifier">O_WRONLY</span><span class="hl-code">, </span><span class="hl-identifier">S_IRWXU</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">open(log)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
 
    </span><span class="hl-identifier">sa</span><span class="hl-code">.</span><span class="hl-identifier">sa_handler</span><span class="hl-code"> = </span><span class="hl-identifier">sig_hup</span><span class="hl-code">;
    </span><span class="hl-identifier">sigemptyset</span><span class="hl-brackets">(</span><span class="hl-code">&amp;</span><span class="hl-identifier">sa</span><span class="hl-code">.</span><span class="hl-identifier">sa_mask</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> fgets()がSIGHUP受信で割り込みされるように、
     * sa_flags=0(もし定義されていればSA_INTERRUPTを設定)
     * でシグナルハンドラをインストールする。
     </span><span class="hl-mlcomment">*/</span><span class="hl-code">
    </span><span class="hl-identifier">sa</span><span class="hl-code">.</span><span class="hl-identifier">sa_flags</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">;
</span><span >#ifdef</span><span class="hl-code"> </span><span class="hl-identifier">SA_INTERRUPT</span><span ></span><span class="hl-code">
    </span><span class="hl-identifier">sa</span><span class="hl-code">.</span><span class="hl-identifier">sa_flags</span><span class="hl-code"> |= </span><span class="hl-identifier">SA_INTERRUPT</span><span class="hl-code">;
</span><span >#endif</span><span ></span><span class="hl-code">
    </span><span class="hl-identifier">sigaction</span><span class="hl-brackets">(</span><span class="hl-identifier">SIGHUP</span><span class="hl-code">, &amp;</span><span class="hl-identifier">sa</span><span class="hl-code">, </span><span >NULL</span><span class="hl-brackets">)</span><span class="hl-code">;
 
    </span><span class="hl-reserved">while</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span >NULL</span><span class="hl-code"> != </span><span class="hl-identifier">fgets</span><span class="hl-brackets">(</span><span class="hl-identifier">buf</span><span class="hl-code">, </span><span class="hl-reserved">sizeof</span><span class="hl-brackets">(</span><span class="hl-identifier">buf</span><span class="hl-brackets">)</span><span class="hl-code">, </span><span class="hl-identifier">stdin</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stdout</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">PID[%d] : %s</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">getpid</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">, </span><span class="hl-identifier">buf</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">fflush</span><span class="hl-brackets">(</span><span class="hl-identifier">stdout</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">feof</span><span class="hl-brackets">(</span><span class="hl-identifier">stdin</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">stdin detect EOF</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">else</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">fgets(stdin)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">0</span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>

<h5 id="ida5092f">サンプルコードによるSIGHUPの確認</h5>

<pre class="plugin_pre">
$ ./mypty ./mycat_detectHUP
slave name = /dev/ttyp4
abc   # &lt;- input from keyboard + RETURN
abc   # echo back in parent terminal
PID[1215] : abc    # output from slave

def   # &lt;- input from keyboard + RETURN
def   # echo back in parent terminal
PID[1215] : def    # output from slave
</pre>
<p class="paragraph">
psコマンドによる現在状況の確認：
<br />
</p>
<pre>$ ps ax -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
347  346  347 c8c000  1214 ttyp1 Ss   -bash
1214  347 1214 c8c000  1214 ttyp1 S+   ./mypty ./mycat_detectHUP
1216 1214 1214 c8c000  1214 ttyp1 S+   ./mypty ./mycat_detectHUP
1215 1214 1215 cd2d00  1215 ttyp4 Ss+  ./mycat_detectHUP
</pre>

<p class="paragraph">
全体図：
<br />
</p>
<pre class="plugin_pre">
[putty on Windows]
  +
  | (TCP/IP)
  +
[sshd]
  +
  |
  +
[/dev/ptyp1] : master
[/dev/ttyp1] : slave
  +
  |
  +
[-bash] -&gt; fork(),exec()
                 |
                 v     fork()
            [mypty(1)] -----&gt;[mypty(2)]
                 +                +
                 |                |
                 +----------------+
                 |
                 +
           [/dev/ptyp4] : master
           [/dev/ttyp4] : slave
                 +
                 |
                 +
           [mycat_detectHUP]
</pre>

<p class="paragraph">
中心部分：
<br />
</p>
<pre class="plugin_pre">
     write(STDOUT_FILENO)        read(ptym)
               +&lt;--- [mypty(1)] &lt;---+
               |                    |
[/dev/ttyp1]---+                    +---[/dev/ptyp4]=[/dev/ttyp4]&lt;--+
               |                    |                               |
               +---&gt; [mypty(2)] ---&gt;+           [mycat_detectHUP]&lt;--+
    read(STDIN_FILENO)           write(ptym)
</pre>

<p class="paragraph">
このようにmaster/slave間のread/writeが確認できたら、EOFを入力し、master側のファイル記述子をclose()させる。
<br />
</p>
<pre>(input ^D , no echo back)
child(read stdin, write ptym) detect EOF from stdin.
send SIGTERM to parent...
read(ptym): Interrupted system call
child sent SIGTERM, maybe terminated.
PID[1214] closed ptym, sleeping(10)...
PID[1216] closed ptym, sleeping(10)...
</pre>

<p class="paragraph">
この時点でのps：
<br />
</p>
<pre>$ ps ax -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
347  346  347 c8c000  1214 ttyp1 Ss   -bash
1214  347 1214 c8c000  1214 ttyp1 S+   ./mypty ./mycat_detectHUP
1216 1214 1214 c8c000  1214 ttyp1 S+   ./mypty ./mycat_detectHUP
1215 1214 1215 cd2d00 30001 ttyp4 ZW   (mycat_detectHUP)
</pre>

<p class="paragraph">
mycat_detectHUPがゾンビ状態になっている。
<br />
ファイルに保存された標準エラー出力を確認してみる：
<br />
</p>
<pre>$ cat /tmp/mycat_detectHUP
detect SIGHUP(1)
fgets(stdin): Interrupted system call
$
</pre>

<p class="paragraph">
<strong>SIGHUPの受信を確認できた。</strong>
<br />
</p>

<p class="paragraph">
10秒後、myptyがsleep()から復帰し、終了する。
<br />
</p>
<pre>PID[1214] awaken, terminates.
PID[1216] awaken, terminates.
done
</pre>

<h4 id="id009c2a">終了時にBashがジョブに送信するシグナル</h4>

<p class="paragraph">
Bashバージョン(NetBSD 1.6 インストールCD付属のpkgより)
<br />
</p>
<pre>$ bash --version
GNU bash, version 2.05.0(1)-release (i386--netbsdelf)
Copyright 2000 Free Software Foundation, Inc.
</pre>

<p class="paragraph">
Bashの二種類の終了方法:
<br />
</p>
<ul><li> &quot;exit&quot; or &quot;logout&quot; シェルコマンドを実行する</li>
<li> SIGHUPを受信する</li></ul>

<h5 id="id1a70ad">&quot;exit&quot; or &quot;logout&quot; シェルコマンドを実行して終了するときにBashが送信するシグナル</h5>

<pre>exit_shell() (shell.c)
-&gt; hangup_all_jobs() (jobs.c) : 対話シェルかつログインシェルかつshopt huponexitがセットの場合
   -&gt; killpg(&lt;PGID&gt;, SIGHUP)  : 対象：シェルの内部フラグでJ_NOHUPが未設定のジョブ
   -&gt; killpg(&lt;PGID&gt;, SIGCONT) : 対象：STOP状態のジョブ
-&gt; end_job_control() (jobs.c) : 非サブシェル
   -&gt; terminate_stopped_jobs() (jobs.c) : 対話シェルの場合
      -&gt; killpg(&lt;PGID&gt;, SIGTERM)  : 対象：STOP状態のジョブ
      -&gt; killpg(&lt;PGID&gt;, SIGCONT)  : 対象：同上
</pre>

<p class="paragraph">
&quot;huponexit&quot;有 (&quot;shopt -s huponexit&quot;):
<br />
</p>
<table>
	<tr>
		<td>                         </td>
		<td> SIGHUP </td>
		<td> SIGCONT </td>
		<td> SIGTERM </td>
		<td> 実験による確認 </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP有 </td>
		<td> -      </td>
		<td> -       </td>
		<td> -       </td>
		<td>                </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP無 </td>
		<td> o      </td>
		<td> -       </td>
		<td> -       </td>
		<td>                </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP有    </td>
		<td> -      </td>
		<td> o       </td>
		<td> o       </td>
		<td>                </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP無    </td>
		<td> o      </td>
		<td> o       </td>
		<td> o       </td>
		<td>                </td>
	</tr>
</table>

<p class="paragraph">
&quot;huponexit&quot;無 (&quot;shopt -u huponexit&quot;):
<br />
</p>
<table>
	<tr>
		<td>                         </td>
		<td> SIGHUP </td>
		<td> SIGCONT </td>
		<td> SIGTERM </td>
		<td> 実験による確認 </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP有 </td>
		<td> -      </td>
		<td> -       </td>
		<td> -       </td>
		<td>                </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP無 </td>
		<td> -      </td>
		<td> -       </td>
		<td> -       </td>
		<td>実験1           </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP有    </td>
		<td> -      </td>
		<td> o       </td>
		<td> o       </td>
		<td>                </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP無    </td>
		<td> -      </td>
		<td> o       </td>
		<td> o       </td>
		<td>実験2           </td>
	</tr>
</table>

<h5 id="idff2cfe">SIGHUPを受信して終了するときにBashが送信するシグナル</h5>

<ol><li> bashの初期処理で initialize_terminating_signals() (sig.c) がSIGHUPのシグナルハンドラにtermination_unwind_protect()を設定</li>
<li> （シェル上での作業開始 ... 終了）</li>
<li> クライアントの終了：端末エミュレータ側でのネットワークコネクションまたはウインドウのclose</li>
<li> サーバー側の終了処理開始 → 擬似端末のマスター側のファイル記述子が全てclose</li>
<li> 擬似端末のターミナルドライバが制御プロセス(=bash)へSIGHUPを送信</li></ol>

<pre>SIGHUP : termination_unwind_protect() (sig.c)
-&gt; hangup_all_jobs() (jobs.c) : 対話シェルかつSIGHUPの場合
   -&gt; killpg(&lt;PGID&gt;, SIGHUP)  : 対象：シェルの内部フラグでJ_NOHUPが未設定のジョブ
   -&gt; killpg(&lt;PGID&gt;, SIGCONT) : 対象：STOP状態のジョブ
-&gt; end_job_control() (jobs.c)
   -&gt; terminate_stopped_jobs() (jobs.c) : 対話シェルの場合
      -&gt; killpg(&lt;PGID&gt;, SIGTERM)  : 対象：STOP状態のジョブ
      -&gt; killpg(&lt;PGID&gt;, SIGCONT)  : 対象：同上
</pre>

<table>
	<tr>
		<td>                         </td>
		<td> SIGHUP </td>
		<td> SIGCONT </td>
		<td> SIGTERM </td>
		<td> 実験による確認 </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP有 </td>
		<td> -      </td>
		<td> -       </td>
		<td> -       </td>
		<td>                </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP無 </td>
		<td> o      </td>
		<td> -       </td>
		<td> -       </td>
		<td>実験3,4         </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP有    </td>
		<td> -      </td>
		<td> o       </td>
		<td> o       </td>
		<td>                </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP無    </td>
		<td> o      </td>
		<td> o       </td>
		<td> o       </td>
		<td>実験5           </td>
	</tr>
</table>

<h5 id="id175d87">実際のソースコード（参考）</h5>

<p class="paragraph">
exit_shell() (shell.c) :
<br />
</p>
<div class="hl-main"><pre><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> Exit the shell with status S. </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">exit_shell</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">s</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
</span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> 省略 </span><span class="hl-mlcomment">*/</span><span class="hl-code">
 
</span><span >#if</span><span class="hl-code"> </span><span class="hl-identifier">defined</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">JOB_CONTROL</span><span class="hl-brackets">)</span><span ></span><span class="hl-code">
  </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> If the user has run `shopt -s huponexit', hangup all jobs when we exit
     an interactive login shell.  ksh does this unconditionally. </span><span class="hl-mlcomment">*/</span><span class="hl-code">
  </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">interactive_shell</span><span class="hl-code"> &amp;&amp; </span><span class="hl-identifier">login_shell</span><span class="hl-code"> &amp;&amp; </span><span class="hl-identifier">hup_on_exit</span><span class="hl-brackets">)</span><span class="hl-code">
    </span><span class="hl-identifier">hangup_all_jobs</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
 
  </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> If this shell is interactive, terminate all stopped jobs and
     restore the original terminal process group.  Don't do this if we're
     in a subshell and calling exit_shell after, for example, a failed
     word expansion. </span><span class="hl-mlcomment">*/</span><span class="hl-code">
  </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">subshell_environment</span><span class="hl-code"> == </span><span class="hl-number">0</span><span class="hl-brackets">)</span><span class="hl-code">
    </span><span class="hl-identifier">end_job_control</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
</span><span >#endif</span><span class="hl-code"> </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> JOB_CONTROL </span><span class="hl-mlcomment">*/</span><span ></span><span class="hl-code">
 
</span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> 省略 </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span class="hl-brackets">}</span></pre></div>

<p class="paragraph">
end_job_control(), terminate_stopped_jobs(), hangup_all_jobs() (jobs.c) :
<br />
</p>
<div class="hl-main"><pre><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> If this shell is interactive, terminate all stopped jobs and
   restore the original terminal process group.  This is done
   before the `exec' builtin calls shell_execve. </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">end_job_control</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
  </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">interactive_shell</span><span class="hl-brackets">)</span><span class="hl-code">  </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> XXX - should it be interactive? </span><span class="hl-mlcomment">*/</span><span class="hl-code">
    </span><span class="hl-brackets">{</span><span class="hl-code">
      </span><span class="hl-identifier">terminate_stopped_jobs</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
      </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> 省略 </span><span class="hl-mlcomment">*/</span><span class="hl-code">
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> 省略 </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> Cause all stopped jobs to exit. </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">terminate_stopped_jobs</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
  </span><span >register</span><span class="hl-code"> </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">i</span><span class="hl-code">;
 
  </span><span class="hl-reserved">for</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">i</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">; </span><span class="hl-identifier">i</span><span class="hl-code"> &lt; </span><span class="hl-identifier">job_slots</span><span class="hl-code">; </span><span class="hl-identifier">i</span><span class="hl-code">++</span><span class="hl-brackets">)</span><span class="hl-code">
    </span><span class="hl-brackets">{</span><span class="hl-code">
      </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">jobs</span><span class="hl-brackets">[</span><span class="hl-identifier">i</span><span class="hl-brackets">]</span><span class="hl-code"> &amp;&amp; </span><span class="hl-identifier">STOPPED</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">i</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">
        </span><span class="hl-brackets">{</span><span class="hl-code">
          </span><span class="hl-identifier">killpg</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">jobs</span><span class="hl-brackets">[</span><span class="hl-identifier">i</span><span class="hl-brackets">]</span><span class="hl-code">-&gt;</span><span class="hl-identifier">pgrp</span><span class="hl-code">, </span><span class="hl-identifier">SIGTERM</span><span class="hl-brackets">)</span><span class="hl-code">;
          </span><span class="hl-identifier">killpg</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">jobs</span><span class="hl-brackets">[</span><span class="hl-identifier">i</span><span class="hl-brackets">]</span><span class="hl-code">-&gt;</span><span class="hl-identifier">pgrp</span><span class="hl-code">, </span><span class="hl-identifier">SIGCONT</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> Cause all jobs, running or stopped, to receive a hangup signal.  If
   a job is marked J_NOHUP, don't send the SIGHUP. </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span >void</span><span class="hl-code">
</span><span class="hl-identifier">hangup_all_jobs</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
  </span><span >register</span><span class="hl-code"> </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">i</span><span class="hl-code">;
 
  </span><span class="hl-reserved">for</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">i</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">; </span><span class="hl-identifier">i</span><span class="hl-code"> &lt; </span><span class="hl-identifier">job_slots</span><span class="hl-code">; </span><span class="hl-identifier">i</span><span class="hl-code">++</span><span class="hl-brackets">)</span><span class="hl-code">
    </span><span class="hl-brackets">{</span><span class="hl-code">
      </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">jobs</span><span class="hl-brackets">[</span><span class="hl-identifier">i</span><span class="hl-brackets">]</span><span class="hl-brackets">)</span><span class="hl-code">
        </span><span class="hl-brackets">{</span><span class="hl-code">
          </span><span class="hl-reserved">if</span><span class="hl-code">  </span><span class="hl-brackets">(</span><span class="hl-brackets">(</span><span class="hl-identifier">jobs</span><span class="hl-brackets">[</span><span class="hl-identifier">i</span><span class="hl-brackets">]</span><span class="hl-code">-&gt;</span><span class="hl-identifier">flags</span><span class="hl-code"> &amp; </span><span class="hl-identifier">J_NOHUP</span><span class="hl-brackets">)</span><span class="hl-code"> == </span><span class="hl-number">0</span><span class="hl-brackets">)</span><span class="hl-code">
            </span><span class="hl-identifier">killpg</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">jobs</span><span class="hl-brackets">[</span><span class="hl-identifier">i</span><span class="hl-brackets">]</span><span class="hl-code">-&gt;</span><span class="hl-identifier">pgrp</span><span class="hl-code">, </span><span class="hl-identifier">SIGHUP</span><span class="hl-brackets">)</span><span class="hl-code">;
          </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">STOPPED</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">i</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">
            </span><span class="hl-identifier">killpg</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">jobs</span><span class="hl-brackets">[</span><span class="hl-identifier">i</span><span class="hl-brackets">]</span><span class="hl-code">-&gt;</span><span class="hl-identifier">pgrp</span><span class="hl-code">, </span><span class="hl-identifier">SIGCONT</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span class="hl-brackets">}</span></pre></div>

<p class="paragraph">
termination_unwind_protect() (sig.c):
<br />
</p>
<div class="hl-main"><pre><span class="hl-identifier">sighandler</span><span class="hl-code"> </span><span class="hl-identifier">termination_unwind_protect</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">sig</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
</span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> (省略) </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span >#if</span><span class="hl-code"> </span><span class="hl-identifier">defined</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">JOB_CONTROL</span><span class="hl-brackets">)</span><span ></span><span class="hl-code">
  </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">interactive</span><span class="hl-code"> &amp;&amp; </span><span class="hl-identifier">sig</span><span class="hl-code"> == </span><span class="hl-identifier">SIGHUP</span><span class="hl-brackets">)</span><span class="hl-code">
    </span><span class="hl-identifier">hangup_all_jobs</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
  </span><span class="hl-identifier">end_job_control</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
</span><span >#endif</span><span class="hl-code"> </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> JOB_CONTROL </span><span class="hl-mlcomment">*/</span><span ></span><span class="hl-code">
</span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> (省略) </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span class="hl-brackets">}</span></pre></div>

<h5 id="idb0881c">実験用ソース : detectHUPCONTTERM.c</h5>

<p class="paragraph">
ジョブとして動かすサンプルプログラム(細かいお作法やエラー処理は無視)
<br />
detectHUPCONTTERM.c:
<br />
</p>
<div class="hl-main"><pre><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdio.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdlib.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">fcntl.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">unistd.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">signal.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">errno.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
 
</span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">sig_hup</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">signo</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">detect SIGHUP(%d)</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">signo</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-identifier">fflush</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-brackets">)</span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">sig_cont</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">signo</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">detect SIGCONT(%d)</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">signo</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-identifier">fflush</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-brackets">)</span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">sig_term</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">signo</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">detect SIGTERM(%d)</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">signo</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-identifier">fflush</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-brackets">)</span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">argc</span><span class="hl-code">, </span><span >char</span><span class="hl-code"> *</span><span class="hl-identifier">argv</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">i</span><span class="hl-code">;
 
    </span><span class="hl-identifier">signal</span><span class="hl-brackets">(</span><span class="hl-identifier">SIGHUP</span><span class="hl-code">, </span><span class="hl-identifier">sig_hup</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-identifier">signal</span><span class="hl-brackets">(</span><span class="hl-identifier">SIGCONT</span><span class="hl-code">, </span><span class="hl-identifier">sig_cont</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-identifier">signal</span><span class="hl-brackets">(</span><span class="hl-identifier">SIGTERM</span><span class="hl-code">, </span><span class="hl-identifier">sig_term</span><span class="hl-brackets">)</span><span class="hl-code">;
 
    </span><span class="hl-reserved">for</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">i</span><span class="hl-code">=</span><span class="hl-number">0</span><span class="hl-code">;;</span><span class="hl-identifier">i</span><span class="hl-code">++</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stdout</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">stdout:PID[%d],PPID[%d],PGID[%d] i = %d</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">,
            </span><span class="hl-identifier">getpid</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">, </span><span class="hl-identifier">getppid</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">, </span><span class="hl-identifier">getpgrp</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">, </span><span class="hl-identifier">i</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">fflush</span><span class="hl-brackets">(</span><span class="hl-identifier">stdout</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">stderr:PID[%d],PPID[%d],PGID[%d] i = %d</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">,
            </span><span class="hl-identifier">getpid</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">, </span><span class="hl-identifier">getppid</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">, </span><span class="hl-identifier">getpgrp</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">, </span><span class="hl-identifier">i</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">fflush</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">sleep</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">0</span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>

<h5 id="idc78763">実験1：&quot;exit&quot;でBash終了時のRUNNNING状態バックグラウンドジョブ(J_NOHUP無, huponexit未設定)</h5>

<p class="paragraph">
putty + SSH接続：
<br />
</p>
<pre>$ ./detectHUPCONTTERM 1&gt;out.txt 2&gt;err.txt &amp;
[1] 1056
$ exit
</pre>

<p class="paragraph">
<strong>結果：シグナル未検出</strong>
<br />
</p>

<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1054 1053 1054 c8c680  1054 ttyp4 Ss+  -bash
1056 1054 1056 c8c680  1054 ttyp4 S    ./detectHUPCONTTERM (detectHUPCONTTER)
</pre>
<p class="paragraph">
→
<br />
</p>
<pre>PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1056    1 1056 c8c680 30001 ttyp4 S    ./detectHUPCONTTERM (detectHUPCONTTER)
</pre>

<h5 id="idfa0cc2">実験2：&quot;exit&quot;でBash終了時のSTOP状態バックグラウンドジョブ(J_NOHUP無, huponexit未設定)</h5>

<p class="paragraph">
putty + SSH接続：
<br />
</p>
<pre>$ ./detectHUPCONTTERM 1&gt;out.txt 2&gt;err.txt
^Z
[1]+  Stopped                 ./detectHUPCONTTERM &gt;out.txt 2&gt;err.txt
$ exit
logout
There are stopped jobs.
$ exit
</pre>

<p class="paragraph">
<strong>結果：SIGCONT, SIGTERM 検出</strong>
<br />
</p>

<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1096 1095 1096 cd2080  1096 ttyp4 Ss+  -bash
1104 1096 1104 cd2080  1096 ttyp4 T    ./detectHUPCONTTERM (detectHUPCONTTER)
</pre>
<p class="paragraph">
→
<br />
</p>
<pre>PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1104    1 1104 cd2080 30001 ttyp4 S    ./detectHUPCONTTERM (detectHUPCONTTER)
</pre>


<h5 id="iddddfd2">実験3：SIGHUPでBash終了時のRUNNNING状態フォアグラウンドジョブ(J_NOHUP無, huponexit未設定)</h5>

<p class="paragraph">
putty + SSH接続：
<br />
</p>
<pre>$ ./detectHUPCONTTERM 1&gt;out.txt 2&gt;err.txt
</pre>
<p class="paragraph">
この後、putty側を終了。
<br />
</p>

<p class="paragraph">
<strong>結果：SIGHUP検出</strong>
<br />
</p>

<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1009 1008 1009 cafcc0  1032 ttyp4 Ss   -bash
1032 1009 1032 cafcc0  1032 ttyp4 S+   ./detectHUPCONTTERM (detectHUPCONTTER)
</pre>
<p class="paragraph">
→
<br />
</p>
<pre>PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1032    1 1032 cafcc0 30001 ttyp4 S    ./detectHUPCONTTERM (detectHUPCONTTER)
</pre>

<h5 id="id5a62ec">実験4：SIGHUPでBash終了時のRUNNNING状態バックグラウンドジョブ(J_NOHUP無, huponexit未設定)</h5>

<p class="paragraph">
putty + SSH接続：
<br />
</p>
<pre>$ ./detectHUPCONTTERM 1&gt;out.txt 2&gt;err.txt &amp;
[1] 1045
$
</pre>
<p class="paragraph">
この後、putty側を終了。
<br />
</p>

<p class="paragraph">
<strong>結果：SIGHUP検出</strong>
<br />
</p>

<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1042 1041 1042 cbd7c0  1042 ttyp4 Ss+  -bash
1045 1042 1045 cbd7c0  1042 ttyp4 S    ./detectHUPCONTTERM (detectHUPCONTTER)
</pre>
<p class="paragraph">
→
<br />
</p>
<pre>PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1045    1 1045 cbd7c0 30001 ttyp4 S    ./detectHUPCONTTERM (detectHUPCONTTER)
</pre>

<h5 id="id4129f2">実験5：SIGHUPでBash終了時のSTOP状態バックグラウンドジョブ(J_NOHUP無, huponexit未設定)</h5>

<p class="paragraph">
putty + SSH接続：
<br />
</p>
<pre>$ ./detectHUPCONTTERM 1&gt;out.txt 2&gt;err.txt
^Z
[1]+  Stopped                 ./detectHUPCONTTERM &gt;out.txt 2&gt;err.txt
$ jobs
[1]+  Stopped                 ./detectHUPCONTTERM &gt;out.txt 2&gt;err.txt
$
</pre>
<p class="paragraph">
この後、putty側を終了。
<br />
</p>

<p class="paragraph">
<strong>結果：SIGHUP, SIGCONT x 2, SIGTERM検出</strong>
<br />
</p>

<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1067 1066 1067 cd2e40  1067 ttyp4 Ss+  -bash
1069 1067 1069 cd2e40  1067 ttyp4 T    ./detectHUPCONTTERM (detectHUPCONTTER)
</pre>
<p class="paragraph">
→
<br />
</p>
<pre>PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1069    1 1069 cd2e40 30001 ttyp4 S    ./detectHUPCONTTERM (detectHUPCONTTER)
</pre>


<h4 id="idd5056c">nohupの確認</h4>

<p class="paragraph">
ここまでの擬似端末およびBashの知識を元に、nohupの挙動を再確認してみる。
<br />
まずnohupはSIGHUPをSIG_IGNに設定し、コマンドラインで指定されたプログラムとそのコマンドラインオプションを&quot;sh -c&quot;に続けてexec()する。SIG_IGNを設定されたシグナルはexec()後も引き継がれるため、プログラム側でSIGHUPのシグナルハンドラを再設定する必要は無い。
<br />
nohupはSIGHUPにSIG_IGNを設定する。SIGHUP以外のシグナルハンドラは操作しない。起動されるプログラム側でシグナルハンドラを設定しなければ、たとえばSIGTERMを受信したらデフォルトの処理としてプロセスは終了する。
<br />
</p>

<p class="paragraph">
では、nohupで起動したジョブがSIGTERMを受信するケースはどのようなケースか？
<br />
これまでのBashの調査で、SIGHUPにせよexitコマンドからにせよ、Bashは終了時に、STOP状態のジョブに対してSIGTERMを送信することが判明している。
<br />
</p>

<p class="paragraph">
ではnohupで起動したジョブがSTOP状態になるのはどのようなケースか？
<br />
</p>
<ol><li> フォアグラウンドで起動した後、Ctrl+Z(SIGTSTP)によりSTOP状態のバックグランドジョブになる</li>
<li> 標準入力をread()するプロセスをバックグランドジョブとして実行する。<ol><li> 制御端末に対してread/writeできるのはフォアグラウンドジョブだけ。</li>
<li> バックグラウンドジョブが制御端末に対してread/writeしようとすると、制御端末のターミナルドライバはバックグラウンドジョブに対してSIGTTINを送信する。</li>
<li> シェルはwait()系で子プロセスに送られたSIGTTINを検知し、バックグラウンドジョブをSTOPする。</li></ol></li></ol>

<p class="paragraph">
この２パターンにおいて、Bash終了時にnohupで起動されたジョブも終了すると予想される。
<br />
</p>

<p class="paragraph">
そこで、まずnohupの一般的な使い方について実験し、続いて上記２パターンについて実験してみる。
<br />
また、nohupで起動した時点ではRUNNNINGだが、端末が閉じられた後、標準入力に対してread()するとどうなるか確認する。
<br />
</p>

<h5 id="id987bea">nohupの一般的な使い方：RUNNING状態でバックグランドジョブ続行</h5>

<p class="paragraph">
標準出力・標準エラー出力に対して1秒間隔でメッセージを出力する簡単なサンプルプログラムを作成し、確認する。
<br />
nohuptest.c:
<br />
</p>
<div class="hl-main"><pre><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdio.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">unistd.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
 
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">argc</span><span class="hl-code">, </span><span >char</span><span class="hl-code"> *</span><span class="hl-identifier">argv</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">i</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">;
    </span><span class="hl-reserved">for</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">;;</span><span class="hl-identifier">i</span><span class="hl-code">++</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stdout</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">stdout, i = %d</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">i</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">fflush</span><span class="hl-brackets">(</span><span class="hl-identifier">stdout</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">stderr, i = %d</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">i</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">fflush</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">sleep</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">0</span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>

<p class="paragraph">
まずnohup経由でフォアグラウンドジョブとして起動し、端末エミュレータを終了した後もジョブが続行されるか確認する。
<br />
</p>

<pre>$ nohup ./nohuptest
sending output to nohup.out
</pre>
<p class="paragraph">
ここで端末エミュレータ(putty)をcloseする。
<br />
</p>

<p class="paragraph">
close前：
<br />
</p>
<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
204  203  204 c97f80   214 ttyp1 Ss   -bash
214  204  214 c97f80   214 ttyp1 S+   ./nohuptest
</pre>

<p class="paragraph">
close後：
<br />
</p>
<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
214    1  214 c97f80 30001 ttyp1 S    ./nohuptest
</pre>

<p class="paragraph">
ジョブが続行されるのを確認できた。
<br />
</p>

<p class="paragraph">
次はnohupをバックグランドジョブとして起動し、bashからlogoutした後もジョブが続行されるか確認する。
<br />
</p>

<pre>$ nohup ./nohuptest &amp;
[1] 230
$ sending output to nohup.out  # &lt;&lt;&lt; output from nohup

$ jobs
[1]+  Running                 nohup ./nohuptest &amp;
$ exit
</pre>

<p class="paragraph">
nohup後：
<br />
</p>
<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
225  224  225 c977c0   225 ttyp1 Ss+  -bash
230  225  230 c977c0   225 ttyp1 S    ./nohuptest
</pre>

<p class="paragraph">
exitによるbash終了後：
<br />
</p>
<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
230    1  230 c977c0 30001 ttyp1 S    ./nohuptest
</pre>

<p class="paragraph">
ジョブが続行されるのを確認できた。
<br />
</p>

<p class="paragraph">
次はnohupをバックグランドジョブとして起動し、端末エミュレータを終了した後もジョブが続行されるか確認する。
<br />
</p>

<pre>$ nohup ./nohuptest &amp;
[1] 243
$ sending output to nohup.out  # &lt;&lt;&lt; output from nohup

$ jobs
[1]+  Running                 nohup ./nohuptest &amp;
$
</pre>
<p class="paragraph">
ここで端末エミュレータ(putty)をcloseする。
<br />
</p>

<p class="paragraph">
nohup後：
<br />
</p>
<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
239  238  239 c97800   239 ttyp1 Ss+  -bash
243  239  243 c97800   239 ttyp1 S    ./nohuptest
</pre>

<p class="paragraph">
端末close後：
<br />
</p>
<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
243    1  243 c97800 30001 ttyp1 S    ./nohuptest
</pre>

<p class="paragraph">
ジョブが続行されるのを確認できた。
<br />
</p>

<p class="paragraph">
ここまででnohupの一般的な使い方である、端末終了後もジョブが続行するパターンを確認できた。
<br />
続けて、nohupで起動したとしても、端末終了時にジョブも終了してしまうパターンを確認していく。
<br />
</p>

<h5 id="idfc22e8">nohupで起動しても終了するパターン１：ジョブをCtrl+Z(SIGTSTP)でSTOP状態にしてlogout</h5>

<p class="paragraph">
detectHUPCONTTERM サンプルプログラムを使う。
<br />
</p>

<pre>$ nohup ./detectHUPCONTTERM 1&gt;out.txt 2&gt;err.txt
^Z
[1]+  Stopped                 nohup ./detectHUPCONTTERM &gt;out.txt 2&gt;err.txt
$ exit
logout
There are stopped jobs.
$ exit
</pre>

<p class="paragraph">
nohupにより起動した時点でのps:
<br />
</p>
<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1297 1296 1297 cd2b80  1303 ttyp1 Ss   -bash
1303 1297 1303 cd2b80  1303 ttyp1 S+   ./detectHUPCONTTERM (detectHUPCONTTER)
</pre>

<p class="paragraph">
Ctrl-Z(SIGTSTP)によりSTOP状態にした時点でのps:
<br />
</p>
<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1297 1296 1297 cd2b80  1297 ttyp1 Ss+  -bash
1303 1297 1303 cd2b80  1297 ttyp1 T    ./detectHUPCONTTERM (detectHUPCONTTER)
</pre>

<p class="paragraph">
exit後のps:
<br />
</p>
<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1303    1 1303 cd2b80 30001 ttyp1 S    ./detectHUPCONTTERM (detectHUPCONTTER)
</pre>

<p class="paragraph">
detectHUPCONTTERMはSIGHUP/SIGCONT/SIGTERMを受信しても終了しないようにプログラムされている。
<br />
これら三つのシグナルを受信すると標準エラー出力にメッセージを出力するので、リダイレクトにより保存されたerr.txtを確認してみる。
<br />
</p>
<pre class="plugin_pre">
$ cat out.txt
...
stdout:PID[1303],PPID[1297],PGID[1303] i = 42
stdout:PID[1303],PPID[1297],PGID[1303] i = 43
stdout:PID[1303],PPID[1],PGID[1303] i = 44
stdout:PID[1303],PPID[1],PGID[1303] i = 45
...
$ cat err.txt
...
stderr:PID[1303],PPID[1297],PGID[1303] i = 41
stderr:PID[1303],PPID[1297],PGID[1303] i = 42
detect SIGCONT(19)
detect SIGTERM(15)
stderr:PID[1303],PPID[1297],PGID[1303] i = 43
stderr:PID[1303],PPID[1],PGID[1303] i = 44
stderr:PID[1303],PPID[1],PGID[1303] i = 45
...
</pre>

<p class="paragraph">
<strong>SIGCONT, SIGTERM を受信したことを確認できた。</strong>
<br />
もしnohupにより起動されたプログラムがこれらのシグナルハンドラをカスタマイズしていなければ、SIGTERMによりプロセスは終了する。
<br />
</p>

<h5 id="idf4ef35">nohupで起動しても終了するパターン２：バックグランドジョブで標準入力(=擬似端末のslave側)をread()</h5>

<p class="paragraph">
mycat_detectHUP.cをSIGTERMに対応させたmycat_detectTERM.cを使う。
<br />
mycat_detectTERM.c:
<br />
</p>
<div class="hl-main"><pre><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdio.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdlib.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">unistd.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">signal.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">errno.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
 
</span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">sig_term</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">signo</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">detect SIGTERM(%d)</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">signo</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-identifier">fflush</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-brackets">)</span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">argc</span><span class="hl-code">, </span><span >char</span><span class="hl-code"> *</span><span class="hl-identifier">argv</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span >char</span><span class="hl-code"> </span><span class="hl-identifier">buf</span><span class="hl-brackets">[</span><span class="hl-number">200</span><span class="hl-brackets">]</span><span class="hl-code">;
    </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">nread</span><span class="hl-code">;
    </span><span >struct</span><span class="hl-code"> </span><span class="hl-identifier">sigaction</span><span class="hl-code"> </span><span class="hl-identifier">sa</span><span class="hl-code">;
    </span><span class="hl-identifier">sa</span><span class="hl-code">.</span><span class="hl-identifier">sa_handler</span><span class="hl-code"> = </span><span class="hl-identifier">sig_term</span><span class="hl-code">;
    </span><span class="hl-identifier">sigemptyset</span><span class="hl-brackets">(</span><span class="hl-code">&amp;</span><span class="hl-identifier">sa</span><span class="hl-code">.</span><span class="hl-identifier">sa_mask</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-identifier">sa</span><span class="hl-code">.</span><span class="hl-identifier">sa_flags</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">;
</span><span >#ifdef</span><span class="hl-code"> </span><span class="hl-identifier">SA_INTERRUPT</span><span ></span><span class="hl-code">
    </span><span class="hl-identifier">sa</span><span class="hl-code">.</span><span class="hl-identifier">sa_flags</span><span class="hl-code"> |= </span><span class="hl-identifier">SA_INTERRUPT</span><span class="hl-code">;
</span><span >#endif</span><span ></span><span class="hl-code">
    </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment">signal(SIGTERM, sig_term);</span><span class="hl-mlcomment">*/</span><span class="hl-code">
    </span><span class="hl-identifier">sigaction</span><span class="hl-brackets">(</span><span class="hl-identifier">SIGTERM</span><span class="hl-code">, &amp;</span><span class="hl-identifier">sa</span><span class="hl-code">, </span><span >NULL</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-reserved">for</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">;;</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-brackets">(</span><span class="hl-identifier">nread</span><span class="hl-code"> = </span><span class="hl-identifier">read</span><span class="hl-brackets">(</span><span class="hl-identifier">STDIN_FILENO</span><span class="hl-code">, </span><span class="hl-identifier">buf</span><span class="hl-code">, </span><span class="hl-reserved">sizeof</span><span class="hl-brackets">(</span><span class="hl-identifier">buf</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">read()</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-number">0</span><span class="hl-code"> == </span><span class="hl-identifier">nread</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-reserved">break</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">nread</span><span class="hl-code"> != </span><span class="hl-identifier">write</span><span class="hl-brackets">(</span><span class="hl-identifier">STDOUT_FILENO</span><span class="hl-code">, </span><span class="hl-identifier">buf</span><span class="hl-code">, </span><span class="hl-identifier">nread</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">write()</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-identifier">exit</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">0</span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>

<pre>$ nohup ./mycat_detectTERM 2&gt;err.txt &amp;
[1] 1387
$ jobs
[1]+  Stopped                 nohup ./mycat_detectTERM 2&gt;err.txt
$ exit
</pre>

<p class="paragraph">
nohupで起動した時点でのps:
<br />
</p>
<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1376 1375 1376 cd2b80  1376 ttyp1 Ss+  -bash
1387 1376 1387 cd2b80  1376 ttyp1 T    ./mycat_detectTERM
</pre>

<p class="paragraph">
exitした時点でのps:
<br />
</p>
<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
(ttyp1のプロセスは存在しない)
</pre>

<p class="paragraph">
標準エラー出力のリダイレクト先であるerr.txtを確認してみる：
<br />
</p>
<pre>$ cat err.txt
sending output to nohup.out
detect SIGTERM(15)
read(): Interrupted system call
$
</pre>

<p class="paragraph">
<strong>SIGTERM を受信したことを確認できた。</strong>
<br />
また、SIGTERM受信によりread()がEINTR(Interrupted system call)で終了している。
<br />
</p>

<h5 id="idf20db2">nohupで起動した時点ではRUNNNINGだが、端末が閉じられた後、標準入力に対してread()するとどうなるか</h5>

<p class="paragraph">
予想：端末がcloseされる時点ではRUNNINGなのでSIGTERMは送信されない。よって端末close後もプロセスは存在するが、標準入力をread()しようとすると既にclose()されているためEOFが返される。
<br />
</p>

<p class="paragraph">
1分間sleep()後、標準入力をfgets()で読み込む delay_read.c:
<br />
</p>
<div class="hl-main"><pre><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdio.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">unistd.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">errno.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
 
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">argc</span><span class="hl-code">, </span><span >char</span><span class="hl-code"> *</span><span class="hl-identifier">argv</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span >char</span><span class="hl-code"> </span><span class="hl-identifier">buf</span><span class="hl-brackets">[</span><span class="hl-number">200</span><span class="hl-brackets">]</span><span class="hl-code">;
 
    </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">after 60 seconds, read() and write()...</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-identifier">sleep</span><span class="hl-brackets">(</span><span class="hl-number">60</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">60 seconds passed, now read() and write():</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
 
    </span><span class="hl-identifier">errno</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">;
    </span><span class="hl-reserved">while</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span >NULL</span><span class="hl-code"> != </span><span class="hl-identifier">fgets</span><span class="hl-brackets">(</span><span class="hl-identifier">buf</span><span class="hl-code">, </span><span class="hl-reserved">sizeof</span><span class="hl-brackets">(</span><span class="hl-identifier">buf</span><span class="hl-brackets">)</span><span class="hl-code">, </span><span class="hl-identifier">stdin</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stdout</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">PID[%d] : %s</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">getpid</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">, </span><span class="hl-identifier">buf</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">fflush</span><span class="hl-brackets">(</span><span class="hl-identifier">stdout</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">feof</span><span class="hl-brackets">(</span><span class="hl-identifier">stdin</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">fprintf</span><span class="hl-brackets">(</span><span class="hl-identifier">stderr</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">stdin detect EOF</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">else</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">perror</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">fgets(stdin)</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">0</span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>

<p class="paragraph">
実行してみる：
<br />
</p>
<pre>$ nohup ./delay_read 1&gt;out.txt 2&gt;err.txt &amp;
[1] 1462
$ jobs
[1]+  Running                 nohup ./delay_read &gt;out.txt 2&gt;err.txt &amp;
$ exit
</pre>

<p class="paragraph">
nohup起動時点:
<br />
</p>
<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1437 1436 1437 c9a040  1437 ttyp1 Ss+  -bash
1462 1437 1462 c9a040  1437 ttyp1 S    ./delay_read
</pre>

<p class="paragraph">
exit後、60秒経過前:
<br />
</p>
<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
1462    1 1462 c9a040 30001 ttyp1 S    ./delay_read
</pre>


<p class="paragraph">
60秒経過後のps:
<br />
</p>
<pre>$ ps x -o pid,ppid,pgid,sess,tpgid,tty,stat,command
PID PPID PGID   SESS TGPID TTY   STAT COMMAND
(ttyp1のプロセスは存在しない)
</pre>

<p class="paragraph">
out.txt, err.txtを確認する：
<br />
</p>
<pre>$ wc -c out.txt
       0 out.txt
$ cat err.txt
after 60 seconds, read() and write()...
60 seconds passed, now read() and write():stdin detect EOF
                                          ^^^^^^^^^^^^^^^^
$
</pre>

<p class="paragraph">
<strong>EOFが返されることを確認できた。</strong>
<br />
</p>

<h3 id="id88cc84">Linux(CentOS5.x) における擬似端末, Bash, nohupの確認</h3>

<p class="paragraph">
NetBSD1.6と同様に、CentOS5.x上で以下の実験をしていく。
<br />
</p>
<ol><li> 擬似端末の使い方を簡単なサンプルで確認</li>
<li> Bash終了時のシグナル送信の組み合わせを実際のソースコードを読んで確認</li>
<li> Bash終了時のシグナル送信とnohupの組み合わせを再確認</li></ol>

<h4 id="id9c8517">擬似端末を使ったサンプル</h4>

<p class="paragraph">
mypty.cはNetBSD1.6と同様。ただし、
<br />
</p>
<pre>#include &lt;util.h&gt;
</pre>
<p class="paragraph">
を
<br />
</p>
<pre>#include &lt;pty.h&gt;
</pre>
<p class="paragraph">
に変更してコンパイル。
<br />
</p>
<pre>$ su
# cc -o mypty mypty.c -lutil &amp;&amp; chmod +s ./mypty
</pre>

<p class="paragraph">
mycat_detectHUP.cもNetBSD1.6と同様。変更点無し。
<br />
</p>

<p class="paragraph">
&quot;master&quot;側close時のSIGHUP送信を確認する。
<br />
</p>

<pre class="plugin_pre">
$ ./mypty ./mycat_detectHUP
slave name = /dev/pts/3
abc   # &lt;- input from keyboard + RETURN
abc   # echo back in parent terminal
PID[15481] : abc    # output from slave

def   # &lt;- input from keyboard + RETURN
def   # echo back in parent terminal
PID[15481] : def    # output from slave
</pre>
<p class="paragraph">
psコマンドによる現在状況の確認：
<br />
</p>
<pre>$ ps ax -o pid,ppid,pgid,sess,tpgid,tty,stat,command
 PID  PPID  PGID  SESS TPGID TT       STAT COMMAND
3287  3286  3287  3287  3910 pts/2    Ss   -bash
3910  3287  3910  3287  3910 pts/2    S+   ./mypty ./mycat_detectHUP
3911  3910  3911  3911  3911 pts/3    Ss+  ./mycat_detectHUP
3912  3910  3910  3287  3910 pts/2    S+   ./mypty ./mycat_detectHUP
</pre>

<p class="paragraph">
全体図はNetBSD1.6と同様なため省略。Linuxの場合はslave側デバイスが&quot;/dev/pts/N&quot;というデバイスファイル名になる。
<br />
</p>

<p class="paragraph">
master/slave間のread/writeが確認できたら、EOFを入力し、master側のファイル記述子をclose()させる。
<br />
</p>
<pre>(input ^D , no echo back)
child(read stdin, write ptym) detect EOF from stdin.
send SIGTERM to parent...
read(ptym): Interrupted system call
child sent SIGTERM, maybe terminated.
PID[3910] closed ptym, sleeping(10)...
PID[3912] closed ptym, sleeping(10)...
</pre>

<p class="paragraph">
この時点でのps：
<br />
</p>
<pre>$ ps ax -o pid,ppid,pgid,sess,tpgid,tty,stat,command
 PID  PPID  PGID  SESS TPGID TT       STAT COMMAND
3287  3286  3287  3287  3910 pts/2    Ss   -bash
3910  3287  3910  3287  3910 pts/2    S+   ./mypty ./mycat_detectHUP
3911  3910  3911  3911    -1 ?        Zs   [mycat_detectHUP] &lt;defunct&gt;
3912  3910  3910  3287  3910 pts/2    S+   ./mypty ./mycat_detectHUP
</pre>

<p class="paragraph">
mycat_detectHUPがゾンビ状態になっている。
<br />
</p>

<p class="paragraph">
ファイルに保存された標準エラー出力を確認してみる：(Linuxの場合はrootユーザーで/tmp/mycat_detectHUPが作成されている)
<br />
</p>
<pre># cat /tmp/mycat_detectHUP
detect SIGHUP(1)
stdin detect EOF
#
</pre>

<p class="paragraph">
<strong>SIGHUPの受信を確認できた。</strong>
<br />
</p>

<p class="paragraph">
10秒後、myptyがsleep()から復帰し、終了する。
<br />
</p>
<pre>PID[3910] awaken, terminates.
PID[3912] awaken, terminates.
done
</pre>

<h4 id="id009c2a">終了時にBashがジョブに送信するシグナル</h4>

<p class="paragraph">
Bashバージョン
<br />
</p>
<pre>$ bash --version
GNU bash, version 3.2.25(1)-release (i686-redhat-linux-gnu)
Copyright (C) 2005 Free Software Foundation, Inc.
</pre>

<p class="paragraph">
Bashの二種類の終了方法:
<br />
</p>
<ul><li> &quot;exit&quot; or &quot;logout&quot; シェルコマンドを実行する</li>
<li> SIGHUPを受信する</li></ul>

<h5 id="id1a70ad">&quot;exit&quot; or &quot;logout&quot; シェルコマンドを実行して終了するときにBashが送信するシグナル</h5>

<pre>exit_shell() (shell.c)
-&gt; hangup_all_jobs() (jobs.c) : 対話シェルかつログインシェルかつshopt huponexitがセットの場合
   -&gt; killpg(&lt;PGID&gt;, SIGHUP)  : 対象：シェルの内部フラグでJ_NOHUPが未設定のジョブ
   -&gt; killpg(&lt;PGID&gt;, SIGCONT) : 対象：STOP状態のジョブでJ_NOHUPが未設定のジョブ
-&gt; end_job_control() (jobs.c) : 非サブシェル
   -&gt; terminate_stopped_jobs() (jobs.c) : 対話シェルの場合
      -&gt; killpg(&lt;PGID&gt;, SIGTERM)  : 対象：STOP状態のジョブ
      -&gt; killpg(&lt;PGID&gt;, SIGCONT)  : 対象：同上
</pre>

<p class="paragraph">
&quot;huponexit&quot;有 (&quot;shopt -s huponexit&quot;):
<br />
</p>
<table>
	<tr>
		<td>                         </td>
		<td> SIGHUP </td>
		<td> SIGCONT </td>
		<td> SIGTERM </td>
		<td> 実験による確認 </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP有 </td>
		<td> -      </td>
		<td> -       </td>
		<td> -       </td>
		<td>                </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP無 </td>
		<td> o      </td>
		<td> -       </td>
		<td> -       </td>
		<td>                </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP有    </td>
		<td> -      </td>
		<td> o       </td>
		<td> o       </td>
		<td>                </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP無    </td>
		<td> o      </td>
		<td> o       </td>
		<td> o       </td>
		<td>                </td>
	</tr>
</table>

<p class="paragraph">
&quot;huponexit&quot;無 (&quot;shopt -u huponexit&quot;):
<br />
</p>
<table>
	<tr>
		<td>                         </td>
		<td> SIGHUP </td>
		<td> SIGCONT </td>
		<td> SIGTERM </td>
		<td> 実験による確認 </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP有 </td>
		<td> -      </td>
		<td> -       </td>
		<td> -       </td>
		<td>                </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP無 </td>
		<td> -      </td>
		<td> -       </td>
		<td> -       </td>
		<td>実験1           </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP有    </td>
		<td> -      </td>
		<td> o       </td>
		<td> o       </td>
		<td>                </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP無    </td>
		<td> -      </td>
		<td> o       </td>
		<td> o       </td>
		<td>実験2           </td>
	</tr>
</table>

<h5 id="idff2cfe">SIGHUPを受信して終了するときにBashが送信するシグナル</h5>

<ol><li> bashの初期処理で initialize_terminating_signals() (sig.c) がSIGHUPのシグナルハンドラにtermsig_sighandler()を設定</li>
<li> （シェル上での作業開始 ... 終了）</li>
<li> （シェル上での作業開始 ... 終了）</li>
<li> クライアントの終了：端末エミュレータ側でのネットワークコネクションまたはウインドウのclose</li>
<li> サーバー側の終了処理開始 → 擬似端末のマスター側のファイル記述子が全てclose</li>
<li> 擬似端末のターミナルドライバが制御プロセス(=bash)へSIGHUPを送信</li></ol>

<pre>SIGHUP : termsig_sighandler() -&gt; termsig_handler() (sig.c)
-&gt; hangup_all_jobs() (jobs.c) : 対話シェルかつSIGHUPの場合
   -&gt; killpg(&lt;PGID&gt;, SIGHUP)  : 対象：シェルの内部フラグでJ_NOHUPが未設定のジョブ
   -&gt; killpg(&lt;PGID&gt;, SIGCONT) : 対象：STOP状態のジョブでJ_NOHUPが未設定のジョブ
-&gt; end_job_control() (jobs.c)
   -&gt; terminate_stopped_jobs() (jobs.c) : 対話シェルの場合
      -&gt; killpg(&lt;PGID&gt;, SIGTERM)  : 対象：STOP状態のジョブ
      -&gt; killpg(&lt;PGID&gt;, SIGCONT)  : 対象：同上
</pre>

<table>
	<tr>
		<td>                         </td>
		<td> SIGHUP </td>
		<td> SIGCONT </td>
		<td> SIGTERM </td>
		<td> 実験による確認 </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP有 </td>
		<td> -      </td>
		<td> -       </td>
		<td> -       </td>
		<td>                </td>
	</tr>
	<tr>
		<td> RUNNING状態 + J_NOHUP無 </td>
		<td> o      </td>
		<td> ?       </td>
		<td> -       </td>
		<td>実験3,4         </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP有    </td>
		<td> -      </td>
		<td> o       </td>
		<td> o       </td>
		<td>                </td>
	</tr>
	<tr>
		<td> STOP状態 + J_NOHUP無    </td>
		<td> o      </td>
		<td> o       </td>
		<td> o       </td>
		<td>実験5           </td>
	</tr>
</table>

<p class="paragraph">
&quot;RUNNING状態 + J_NOHUP無&quot;のSIGCONTについては実験4で説明する。
<br />
</p>

<h5 id="id175d87">実際のソースコード（参考）</h5>

<p class="paragraph">
諸事情によりバイナリと異なるバージョンのソースコードを載せる。
<br />
・・・いえ、その、決してSRPM入れて展開するのが面倒くさかったからとかじゃありませんよ？
<br />
</p>

<p class="paragraph">
ソースコードのバージョンは bash-3.2.48 。（ログインシェルとして使っているのはCentOSのRPM, 3.2.25)
<br />
NetBSD1.6のbash-2.x.xから殆ど変わっていない。hangup_all_jobs()中でのループで、J_NOHUPの条件だけがわずかに変更されている。
<br />
</p>

<p class="paragraph">
exit_shell() (shell.c) :
<br />
</p>
<div class="hl-main"><pre><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> Exit the shell with status S. </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">exit_shell</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">s</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
</span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> 省略 </span><span class="hl-mlcomment">*/</span><span class="hl-code">
 
</span><span >#if</span><span class="hl-code"> </span><span class="hl-identifier">defined</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">JOB_CONTROL</span><span class="hl-brackets">)</span><span ></span><span class="hl-code">
  </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> If the user has run `shopt -s huponexit', hangup all jobs when we exit
     an interactive login shell.  ksh does this unconditionally. </span><span class="hl-mlcomment">*/</span><span class="hl-code">
  </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">interactive_shell</span><span class="hl-code"> &amp;&amp; </span><span class="hl-identifier">login_shell</span><span class="hl-code"> &amp;&amp; </span><span class="hl-identifier">hup_on_exit</span><span class="hl-brackets">)</span><span class="hl-code">
    </span><span class="hl-identifier">hangup_all_jobs</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
 
  </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> If this shell is interactive, terminate all stopped jobs and
     restore the original terminal process group.  Don't do this if we're
     in a subshell and calling exit_shell after, for example, a failed
     word expansion. </span><span class="hl-mlcomment">*/</span><span class="hl-code">
  </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">subshell_environment</span><span class="hl-code"> == </span><span class="hl-number">0</span><span class="hl-brackets">)</span><span class="hl-code">
    </span><span class="hl-identifier">end_job_control</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
</span><span >#endif</span><span class="hl-code"> </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> JOB_CONTROL </span><span class="hl-mlcomment">*/</span><span ></span><span class="hl-code">
 
</span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> 省略 </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span class="hl-brackets">}</span></pre></div>

<p class="paragraph">
end_job_control(), terminate_stopped_jobs(), hangup_all_jobs() (jobs.c) :
<br />
</p>
<div class="hl-main"><pre><span >void</span><span class="hl-code"> </span><span class="hl-identifier">end_job_control</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
  </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">interactive_shell</span><span class="hl-brackets">)</span><span class="hl-code">  </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> XXX - should it be interactive? </span><span class="hl-mlcomment">*/</span><span class="hl-code">
    </span><span class="hl-brackets">{</span><span class="hl-code">
      </span><span class="hl-identifier">terminate_stopped_jobs</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
      </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> 省略 </span><span class="hl-mlcomment">*/</span><span class="hl-code">
    </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> 省略 </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> Cause all stopped jobs to exit. </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">terminate_stopped_jobs</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
  </span><span >register</span><span class="hl-code"> </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">i</span><span class="hl-code">;
 
  </span><span class="hl-reserved">for</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">i</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">; </span><span class="hl-identifier">i</span><span class="hl-code"> &lt; </span><span class="hl-identifier">job_slots</span><span class="hl-code">; </span><span class="hl-identifier">i</span><span class="hl-code">++</span><span class="hl-brackets">)</span><span class="hl-code">
    </span><span class="hl-brackets">{</span><span class="hl-code">
      </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">jobs</span><span class="hl-brackets">[</span><span class="hl-identifier">i</span><span class="hl-brackets">]</span><span class="hl-code"> &amp;&amp; </span><span class="hl-identifier">STOPPED</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">i</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">
        </span><span class="hl-brackets">{</span><span class="hl-code">
          </span><span class="hl-identifier">killpg</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">jobs</span><span class="hl-brackets">[</span><span class="hl-identifier">i</span><span class="hl-brackets">]</span><span class="hl-code">-&gt;</span><span class="hl-identifier">pgrp</span><span class="hl-code">, </span><span class="hl-identifier">SIGTERM</span><span class="hl-brackets">)</span><span class="hl-code">;
          </span><span class="hl-identifier">killpg</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">jobs</span><span class="hl-brackets">[</span><span class="hl-identifier">i</span><span class="hl-brackets">]</span><span class="hl-code">-&gt;</span><span class="hl-identifier">pgrp</span><span class="hl-code">, </span><span class="hl-identifier">SIGCONT</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> Cause all jobs, running or stopped, to receive a hangup signal.  If
   a job is marked J_NOHUP, don't send the SIGHUP. </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span >void</span><span class="hl-code">
</span><span class="hl-identifier">hangup_all_jobs</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
  </span><span >register</span><span class="hl-code"> </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">i</span><span class="hl-code">;
 
  </span><span class="hl-reserved">for</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">i</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">; </span><span class="hl-identifier">i</span><span class="hl-code"> &lt; </span><span class="hl-identifier">job_slots</span><span class="hl-code">; </span><span class="hl-identifier">i</span><span class="hl-code">++</span><span class="hl-brackets">)</span><span class="hl-code">
    </span><span class="hl-brackets">{</span><span class="hl-code">
      </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">jobs</span><span class="hl-brackets">[</span><span class="hl-identifier">i</span><span class="hl-brackets">]</span><span class="hl-brackets">)</span><span class="hl-code">
        </span><span class="hl-brackets">{</span><span class="hl-code">
          </span><span class="hl-reserved">if</span><span class="hl-code">  </span><span class="hl-brackets">(</span><span class="hl-identifier">jobs</span><span class="hl-brackets">[</span><span class="hl-identifier">i</span><span class="hl-brackets">]</span><span class="hl-code">-&gt;</span><span class="hl-identifier">flags</span><span class="hl-code"> &amp; </span><span class="hl-identifier">J_NOHUP</span><span class="hl-brackets">)</span><span class="hl-code">
            </span><span class="hl-reserved">continue</span><span class="hl-code">;
          </span><span class="hl-identifier">killpg</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">jobs</span><span class="hl-brackets">[</span><span class="hl-identifier">i</span><span class="hl-brackets">]</span><span class="hl-code">-&gt;</span><span class="hl-identifier">pgrp</span><span class="hl-code">, </span><span class="hl-identifier">SIGHUP</span><span class="hl-brackets">)</span><span class="hl-code">;
          </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">STOPPED</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">i</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">
            </span><span class="hl-identifier">killpg</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">jobs</span><span class="hl-brackets">[</span><span class="hl-identifier">i</span><span class="hl-brackets">]</span><span class="hl-code">-&gt;</span><span class="hl-identifier">pgrp</span><span class="hl-code">, </span><span class="hl-identifier">SIGCONT</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span class="hl-brackets">}</span></pre></div>

<p class="paragraph">
termsig_sighandler() , termsig_handler() (sig.c):
<br />
</p>
<div class="hl-main"><pre><span class="hl-identifier">sighandler</span><span class="hl-code">
</span><span class="hl-identifier">termsig_sighandler</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">sig</span><span class="hl-brackets">)</span><span class="hl-code">
     </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">sig</span><span class="hl-code">;
</span><span class="hl-brackets">{</span><span class="hl-code">
  </span><span class="hl-identifier">terminating_signal</span><span class="hl-code"> = </span><span class="hl-identifier">sig</span><span class="hl-code">;
 
  </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">terminate_immediately</span><span class="hl-brackets">)</span><span class="hl-code">
    </span><span class="hl-brackets">{</span><span class="hl-code">
      </span><span class="hl-identifier">terminate_immediately</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">;
      </span><span class="hl-identifier">termsig_handler</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">sig</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
 
  </span><span class="hl-identifier">SIGRETURN</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-number">0</span><span class="hl-brackets">)</span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">termsig_handler</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">sig</span><span class="hl-brackets">)</span><span class="hl-code">
</span><span class="hl-brackets">{</span><span class="hl-code">
</span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> (省略) </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span >#if</span><span class="hl-code"> </span><span class="hl-identifier">defined</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">JOB_CONTROL</span><span class="hl-brackets">)</span><span ></span><span class="hl-code">
  </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">interactive</span><span class="hl-code"> &amp;&amp; </span><span class="hl-identifier">sig</span><span class="hl-code"> == </span><span class="hl-identifier">SIGHUP</span><span class="hl-brackets">)</span><span class="hl-code">
    </span><span class="hl-identifier">hangup_all_jobs</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
  </span><span class="hl-identifier">end_job_control</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
</span><span >#endif</span><span class="hl-code"> </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> JOB_CONTROL </span><span class="hl-mlcomment">*/</span><span ></span><span class="hl-code">
</span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> (省略) </span><span class="hl-mlcomment">*/</span><span class="hl-code">
</span><span class="hl-brackets">}</span></pre></div>

<h5 id="idc1829f">実験用ソース : detectHUPCONTTERM.c, 実験1 - 5</h5>

<p class="paragraph">
detectHUPCONTTERM.c : NetBSD1.6と同じ。変更点無し。
<br />
</p>

<p class="paragraph">
各実験については結果として検出したシグナルのみ記す。シェル上での作業やpsコマンドの出力は省略する。
<br />
</p>

<p class="paragraph">
・実験1：&quot;exit&quot;でBash終了時のRUNNNING状態バックグラウンドジョブ(J_NOHUP無, huponexit未設定)
<br />
→結果：シグナル未検出
<br />
</p>

<p class="paragraph">
・実験2：&quot;exit&quot;でBash終了時のSTOP状態バックグラウンドジョブ(J_NOHUP無, huponexit未設定)
<br />
→結果：SIGCONT, SIGTERM 検出
<br />
</p>

<p class="paragraph">
・実験3：SIGHUPでBash終了時のRUNNNING状態フォアグラウンドジョブ(J_NOHUP無, huponexit未設定)
<br />
→結果：SIGHUP, SIGCONT, SIGTERM 検出
<br />
</p>

<p class="paragraph">
・実験4：SIGHUPでBash終了時のRUNNNING状態バックグラウンドジョブ(J_NOHUP無, huponexit未設定)
<br />
→結果：SIGHUP, SIGCONT検出
<br />
ざっとソースを読んだ限りではSIGCONTが送信されるとは思えないのだが、それはソース読解が浅いせいかもしれない。想像以上にシグナルの送受信が発生し、何度かbashとジョブの間でステータスの変化やそれにともなうシグナルのやりとり、bashの内部情報の変更などが発生しているのかもしれない。
<br />
</p>

<p class="paragraph">
・実験5：SIGHUPでBash終了時のSTOP状態バックグラウンドジョブ(J_NOHUP無, huponexit未設定)
<br />
→結果：SIGCONT, SIGTERM検出
<br />
</p>


<h4 id="idd5056c">nohupの確認</h4>

<p class="paragraph">
NetBSD1.6と同様、nohupの使い方やnohupを使っても終了してしまうパターンを実験してみる。
<br />
</p>

<p class="paragraph">
nohuptest.c:NetBSD1.6と同じ。変更無し。
<br />
</p>

<p class="paragraph">
・nohupの一般的な使い方：RUNNING状態でフォアグランドジョブ続行
<br />
</p>

<ol><li> nohup経由でフォアグラウンドジョブとして起動</li>
<li> 端末エミュレータを終了した後もジョブが続行されるか確認する。</li></ol>

<p class="paragraph">
結果：ジョブが続行されるのを確認できた。
<br />
</p>

<p class="paragraph">
・nohupの一般的な使い方：RUNNING状態でバックグランドジョブ続行その1
<br />
</p>

<ol><li> nohup経由でバックグラウンドジョブとして起動(RUNNING)</li>
<li> exitコマンドでログアウト後もジョブが続行されるか確認する。</li></ol>

<p class="paragraph">
結果：ジョブが続行されるのを確認できた。
<br />
</p>


<p class="paragraph">
・nohupの一般的な使い方：RUNNING状態でバックグランドジョブ続行その2
<br />
</p>

<ol><li> nohup経由でバックグラウンドジョブとして起動(RUNNING)</li>
<li> 端末エミュレータを終了した後もジョブが続行されるか確認する。</li></ol>

<p class="paragraph">
結果：ジョブが続行されるのを確認できた。
<br />
</p>

<p class="paragraph">
ここまででnohupの一般的な使い方である、端末終了後もジョブが続行するパターンを確認できた。
<br />
続けて、nohupで起動したとしても、端末終了時にジョブも終了してしまうパターンを確認していく。
<br />
</p>


<p class="paragraph">
・nohupで起動しても終了するパターン１：ジョブをCtrl+Z(SIGTSTP)でSTOP状態にしてlogout
<br />
</p>

<p class="paragraph">
結果：SIGTERM, SIGCONT受信を確認できた。
<br />
</p>

<p class="paragraph">
・nohupで起動しても終了するパターン２：バックグランドジョブで標準入力(=擬似端末のslave側)をread()
<br />
</p>

<p class="paragraph">
mycat_detectTERM.c:NetBSD1.6と同じ。変更無し。
<br />
</p>

<pre>$ nohup ./mycat_detectTERM 2&gt;err &amp;
[1] 12704
$
[1]+  Exit 1                  nohup ./mycat_detectTERM 2&gt; err
$ jobs
$
$ which nohup
/usr/bin/nohup
$ rpm -qf /usr/bin/nohup
coreutils-5.97-14.el5
</pre>

<p class="paragraph">
CentOS5.xの場合、即座に終了してしまった。straceでnohupが呼んでいるシステムコールを追跡したところ、標準入力をclose()してからexec()していることが分かった。標準エラー出力のリダイレクト先に保存されたperror()メッセージも、read()でEBADFが発生したことを示している。
<br />
</p>
<pre>$ cat err
nohup: appending output to `nohup.out&#039;
read(): Bad file descriptor
</pre>

<p class="paragraph">
・nohupで起動した時点ではRUNNNINGだが、端末が閉じられた後、標準入力に対してread()するとどうなるか
<br />
</p>

<p class="paragraph">
delay_read.c:NetBSD1.6と同じ、変更点無し。
<br />
</p>

<p class="paragraph">
結果：端末がcloseされる時点ではRUNNINGなのでSIGTERMは送信されない。よって端末close後もプロセスは存在するが、標準入力をread()しようとすると最初からclose()されている(exec()の時点でclose()されている)ためEBADFになる。
<br />
</p>


<h4 id="idd31eb1">実験・検証のまとめと反省</h4>

<p class="paragraph">
まとめ
<br />
</p>
<ul><li> bash終了時の流れと、RUNNING/STOPPEDジョブへのシグナル送信の組み合わせ表を作成し、NetBSD1.6ではその通りに、CentOS5.xではほぼその通りに動作することが確認できた。</li>
<li> カーネル側では放置しているバックグラウンドジョブに対しても、bash側で終了時にSIGTERM/SIGCONTを送信する事を確認できた。</li></ul>

<p class="paragraph">
反省
<br />
</p>
<ul><li> CentOS5.xでの実験結果が安定しなかった。環境によっては、1回では本記事と同じ結果にはならないかもしれない。<ul><li> シグナルハンドラでfprintf()などシグナルセーフでない関数を呼んでいたり、bashとジョブの間で、何度かシグナルがやりとりされ、その結果bash内部のジョブ状態が変更されるなどして、今回取り上げたソース以外の場所でいろいろと処理が走っているのかもしれない。</li>
<li> 使用しているBashと全く同じソースを用意できなかったので、その影響もあるかもしれない。SRPMのバージョンや、内部で適用しているpatchの影響もあるかもしれない。</li></ul></li></ul>

<h3 id="id278e84">まとめ：「いともたやすく行われるえげつないnohup」</h3>

<p class="paragraph">
総括として、nohupを使うときの注意事項をまとめておく。
<br />
</p>
<ol><li> nohupで防げるのはSIGHUPだけ、SIGTERM/SIGCONTに注意すること。</li>
<li> バックグラウンドジョブをSTOPPED状態にして端末終了orログアウトするとSIGTERMが送信される点に注意すること。</li>
<li> nohupで続行させるバックグラウンドジョブの中で、標準入力をreadしないようにすること。</li></ol>

<p class="paragraph">
上記３点に注意すれば、&quot;nohupを使ったのに端末終了orログアウトでジョブが終了してしまった&quot;と戸惑うことは無いだろう。
<br />
ログインシェルによっては、終了時のシグナル送信の条件やシグナルの種類が異なるかもしれないので、気になる場合はmanページ等で確認しておくと良いだろう。
<br />
</p>

<p class="paragraph">
また、nohupを使わなくともバックグランドジョブを続行することは可能である。ただし上記nohup時の注意点に加え、nohup無しなのでSIGHUPについても注意を払う必要がある。
<br />
</p>

<p class="paragraph">
ログインシェル終了時のシグナル送信条件やパターンについて細かく把握するのは非常に手間がかかる。
<br />
nohupを挟むことで少なくともSIGHUPについて頭を悩ませる必要は無くなる。&quot;「誰がSIGHUP送ったの？」&quot;の項でも書いたが、使う側が何も知らず、考えなくてもバックグラウンドジョブを（それなりに）継続できるnohupは、やはりスゴイのだ。
<br />
</p>

<h3 id="id61c6f5">参考資料</h3>

<a href="https://www.amazon.co.jp/dp/0321525949" target="_blank">Amazon | Advanced Programming in the UNIX Environment: Paperback Edition (Addison-Wesley Professional Computing Series) | Stevens, W. Richard Rago, Stephen A. | Software Development</a><br>
<ul><li> &quot;Advanced Programming in the UNIX Envrionment Second Edition&quot;<ul><li> <a class="externallink" href="http://www.apuebook.com/" target="_blank">http://www.apuebook.com/</a></li></ul></li></ul>

<a href="https://www.amazon.co.jp/dp/0131411543" target="_blank">Amazon | Advanced UNIX Programming (Addison-Wesley Professional Computing Series) | Rochkind, Marc J. | Unix</a><br>
<ul><li> &quot;Advanced UNIX Programming&quot;<ul><li> <a class="externallink" href="http://basepath.com/aup/" target="_blank">http://basepath.com/aup/</a></li></ul></li></ul>

<p class="paragraph">
他、UNIXの規格と便利なman検索：
<br />
</p>
<ul><li> Single UNIX &reg;  Specification, Version 3 (The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition)<ul><li> <a class="externallink" href="http://www.unix.org/version3/online.html" target="_blank">http://www.unix.org/version3/online.html</a></li></ul></li>
<li> FreeBSD Man Pages (他のBSDやLinuxディストリビューションのmanページまで検索できるのでスゴイ便利)<ul><li> <a class="externallink" href="http://www.freebsd.org/cgi/man.cgi" target="_blank">http://www.freebsd.org/cgi/man.cgi</a></li></ul></li>
<li> NetBSD1.6, CentOS 5.x 付属のmanpage</li></ul>

<p class="paragraph">
nohupの使い方：
<br />
</p>
<ul><li> nohup - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Nohup" target="_blank">http://en.wikipedia.org/wiki/Nohup</a></li></ul></li>
<li> ログアウトしてもバックグラウンド ジョブを継続する方法<ul><li> <a class="externallink" href="http://www.codereading.com/notebook/moin.cgi/IgnoreTheHangupSignal" target="_blank">http://www.codereading.com/notebook/moin.cgi/IgnoreTheHangupSignal</a></li></ul></li>
<li> 【 nohup 】 ログアウトした後もコマンドを実行し続ける - Linuxコマンド集：ITpro<ul><li> <a class="externallink" href="http://itpro.nikkeibp.co.jp/article/COLUMN/20060227/230850/" target="_blank">http://itpro.nikkeibp.co.jp/article/COLUMN/20060227/230850/</a></li></ul></li>
<li> nohup ハングアップに反応しないようにしてコマンドを実行する - UNIXコマンド辞典：CodeZine（コードジン）<ul><li> <a class="externallink" href="http://codezine.jp/unixdic/w/nohup/" target="_blank">http://codezine.jp/unixdic/w/nohup/</a></li></ul></li>
<li> UNIXの部屋 コマンド検索:nohup (*BSD/Linux)<ul><li> <a class="externallink" href="http://x68000.q-e-d.net/~68user/unix/pickup?nohup" target="_blank">http://x68000.q-e-d.net/~68user/unix/pickup?nohup</a></li></ul></li>
<li> [vine-users:066116] nohupは不要?<ul><li> <a class="externallink" href="http://search.luky.org/vine-users.6/msg06116.html" target="_blank">http://search.luky.org/vine-users.6/msg06116.html</a></li></ul></li>
<li> Do background processes get a SIGHUP when logging off? - Server Fault<ul><li> <a class="externallink" href="http://serverfault.com/questions/117152/do-background-processes-get-a-sighup-when-logging-off" target="_blank">http://serverfault.com/questions/117152/do-background-processes-get-a-sighup-when-logging-off</a></li></ul></li></ul>

<p class="paragraph">
SSHとバックグラウンドジョブ, nohupについて：
<br />
</p>
<ul><li> SSH Frequently Asked Questions<ul><li> <a class="externallink" href="http://www.snailbook.com/faq/background-jobs.auto.html" target="_blank">http://www.snailbook.com/faq/background-jobs.auto.html</a></li></ul></li>
<li> SSH<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Secure_Shell" target="_blank">http://en.wikipedia.org/wiki/Secure_Shell</a></li></ul></li>
<li> The SSH Protocol<ul><li> <a class="externallink" href="http://www.snailbook.com/protocols.html" target="_blank">http://www.snailbook.com/protocols.html</a></li></ul></li></ul>

<p class="paragraph">
擬似端末全般：
<br />
</p>
<ul><li> Pseudo terminal - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Pseudo_terminal" target="_blank">http://en.wikipedia.org/wiki/Pseudo_terminal</a></li></ul></li>
<li> 擬似端末と制御端末(さらにちょっと追記) - ソースコード備忘録<ul><li> <a class="externallink" href="http://d.hatena.ne.jp/yuki_rinrin/20090725/1248521786" target="_blank">http://d.hatena.ne.jp/yuki_rinrin/20090725/1248521786</a></li></ul></li>
<li> LinuxControllingTTY   アクセンスのおまけ<ul><li> <a class="externallink" href="http://omake.accense.com/wiki/LinuxControllingTTY" target="_blank">http://omake.accense.com/wiki/LinuxControllingTTY</a></li></ul></li>
<li> Ctrl-D の話 - ひげぽん OSとか作っちゃうかMona-<ul><li> <a class="externallink" href="http://d.hatena.ne.jp/higepon/20080602/1212385423" target="_blank">http://d.hatena.ne.jp/higepon/20080602/1212385423</a></li></ul></li></ul>

<p class="paragraph">
&quot;/dev/console&quot;とか&quot;/dev/ttyN&quot;の話は本記事では全力でスルーさせて貰いましたww
<br />
いずれその辺も調べてみたいっすね・・・。
<br />
</p>


<p class="paragraph">
擬似端末(Pseudo Terminal) Master側close()時のSIGHUP送信：
<br />
</p>
<ul><li> Linux-Kernel Archive: pty master close and SIGHUP<ul><li> <a class="externallink" href="http://lkml.indiana.edu/hypermail/linux/kernel/0407.2/0084.html" target="_blank">http://lkml.indiana.edu/hypermail/linux/kernel/0407.2/0084.html</a></li></ul></li>
<li> LKML: Albert Cahalan: pty master close and SIGHUP<ul><li> <a class="externallink" href="http://lkml.org/lkml/2004/7/16/86" target="_blank">http://lkml.org/lkml/2004/7/16/86</a></li></ul></li>
<li> Unix &amp; Linux: Child process and pseudo-terminals - programming.itags.org<ul><li> <a class="externallink" href="http://programming.itags.org/unix-linux-programming/79368/" target="_blank">http://programming.itags.org/unix-linux-programming/79368/</a></li></ul></li>
<li> close(2) -- close a file descriptor (man pages section 2: System Calls) - Sun Microsystems<ul><li> <a class="externallink" href="http://docs.sun.com/app/docs/doc/816-5167/close-2?l=en&amp;n=1&amp;a=view" target="_blank">http://docs.sun.com/app/docs/doc/816-5167/close-2?l=en&amp;n=1&amp;a=view</a></li></ul></li></ul>

<hr />
<p class="paragraph">
以下、後書き。
<br />
</p>

<p class="paragraph">
Webアプリケーション全盛の昨今、Unixの端末の仕組みについて知らなくても殆ど困らないのが現実です。
<br />
知ってるから、勉強したからといってお給料が上がるわけでもありません。実際、自分も未だに自宅警備員ですし。
<br />
いやほんと、こーゆーの調べたり記事にしたりすることでお給料もらえるところあったら、就職したいですわー。
<br />
</p>

<p class="paragraph">
話を戻して。
<br />
ただまぁ、Unixの端末の仕組みというのも、知らない人間から見れば結構ミステリアス。オカルトですな。
<br />
今回は全く取り上げていませんが、というかそこまで調べ始めたら話がまとまらないのでお手上げというか戦略的撤退として全力でスルーさせてもらった&quot;/dev/console&quot;なども結構黒魔術めいてます。キーボードに打ち込んだ文字が、いったいカーネル内部をどのように伝播してディスプレイに表示されるのか、気になりだすと夜も眠れません。
<br />
・・・うそです。眠れます。本当に眠れなくなったら、心療内科とか行った方が良いですね。不眠症です。
<br />
</p>

<p class="paragraph">
で、&quot;nohup&quot;コマンドというのは自分の中でかなり長い間、「喉に刺さった魚の小骨」だったんです。気にならないっちゃーならないんだけど、意識しちゃうと暫くそこから離れられない・・・って感じです。
<br />
そこにようやく、ピリオドを打てたので「あー、すっきりした」ってところです。
<br />
</p>

<p class="paragraph">
こうして調べてみますと、Unixというのが本当に、小さなパーツ、独立した仕様が絡み合って蠢いているそれなりに混沌とした&quot;システム&quot;であることがよく分かります。ホント、POSIXとかSUS策定した人たち、マジすげー。
<br />
</p>

<p class="paragraph">
Webアプリケーション全盛の昨今、・・・って同じ書き出しですが、とにかく昨今は、そうした混沌としたシステムの裏側を覗く必要性は殆ど無いと思います。セキュリティ系や大規模なインフラ、金融、通信系は別かもしれませんが。
<br />
つーかそれ以前に、アプリの仕様だのプロジェクトマネジメントだのチーム内の人間関係だのがカオスなんだから、それに加えてもう一つカオスな代物の裏側まで覗きたくねーよ、お腹一杯だぁ。って感じですね。
<br />
</p>

<p class="paragraph">
たとえ裏側を覗こうとしても、たとえば今回のようにnohup一つとっても、nohup単体だけでは不十分で、ログインシェルであるとかシグナルであるとか擬似端末であるとか、いろいろな要素が絡み合っていて、それら全てを、「ほどほど」だけじゃ不十分でSUSであるとか実際のソースコードであるとか、そこまで探索して初めて、全体の「絵」が描けるようになる・・・んだと思います。シグナルにしたって、プロセス間で送受信してる様子を「ビジュアルに」追えるわけではありませんし。
<br />
</p>

<p class="paragraph">
何よりも「地図」が無い。それが困ってます。
<br />
</p>

<p class="paragraph">
個別要素の地図はあるんですよ。擬似端末に絞った記事とか、nohup単体のmanページとか。
<br />
ところがいざ、裏側の全体像に目を凝らそうとすると、地図をつなぎ合わせる横串がどこにあるのか、それがさっぱり見えてこないんです。
<br />
たとえてみれば、地図はあるんですけど、全ページ切り離されてばらばらです。おまけに全体地図が欠落してる。そんな感じです。
<br />
</p>

<p class="paragraph">
自分のオツムが悪いだけですかね・・・。あるいは、調査不足とか。あ、APUEは結構助かります。といってもUnix全般を扱ってるため、Linuxなどプラットフォーム特有の問題までは書いてありません。
<br />
今回、この後書きを書くまで実に5日間、ほぼフルに使いましたが、半分以上がLinux上での悪戦苦闘で占められています。なんというか、なかなか実験結果が安定しないんですよね・・・。
<br />
</p>

<p class="paragraph">
ともあれ、自宅警備員ならではの社会貢献として・・・言い訳ですよ、ハイ。自分で書いてて虚しくなった。
<br />
とにかく、とりあえずnohup周辺の地図を自分なりにつなぎあわせてみました。
<br />
</p>

<p class="paragraph">
今回つなぎ合わせた地図が、自分同様、裏舞台が気になって夜も眠れなくなっちゃうけどまぁちゃっかり眠ってる、そんな読者の、何かしらの糧になれば幸いです。
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-288.html" title="技術/UNIX/「UNIX用のGeekな小技10個」メモ">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-1247.html" title="技術/UNIX/端末やターミナルの文字化け対処(clear,reset,stty sane,tput,ncurses)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-23.html" title="技術">技術</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/854<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2001 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" target="_blank" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>