<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Assembler/ForFun(x86_32)/02, 16bit DOS with NASM - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">Assembler/ForFun(x86_32)/02, 16bit DOS with NASM</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-09-15 18:14:23 &nbsp; / &nbsp; last updated at: 2010-09-19 21:02:53<br>
カテゴリ: <a href="category-48.html">Assembler</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-782.html" title="Assembler/ForFun(x86_32)/01, 16bit DOS with debug.exe">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-784.html" title="Assembler/ForFun(x86_32)/03, x86_32用 デバッグ機能有効化 Bochs をVC++2008でビルド">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-410.html" title="Assembler">Assembler</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
Netwide Assembler(NASM)は80x86およびx86-64用のアセンブラで、MicrosoftやLinux, UNIX上の各種オブジェクトファイル・実行ファイルフォーマットに対応しています。Linux/UNIX/Windows各プラットフォームで動作し、アセンブラの入門レベルからOSの開発まで幅広く使われていています。
<br />
</p>

<p class="paragraph">
なおNASMアセンブラの記述はIntel方式(destination, source)です。
<br />
</p>

<ul><li> The Netwide Assembler: NASM<ul><li> <a class="externallink" href="http://www.nasm.us/" target="_blank">http://www.nasm.us/</a></li></ul></li></ul>

<p class="paragraph">
本記事ではNASMを使って16bitDOSプログラミング(但し.COMファイルフォーマットのみ)を体験してみます。
<br />
2010年9月時点での最新版 nasm-2.09.01 を使用し、 Windows XP SP3 (Pen4) 上で動作確認しています。
<br />
</p>

<p class="paragraph">
NASMのインストール方法の詳細については省略します。Web上で適宜検索・調査してインストールして下さい。
<br />
</p>


<hr />
<ul><li><a href="#ida53d15">NASM版 &quot;Hello, World!&quot;</a></li>
<li><a href="#id54c011">&quot;Hello, World!&quot;改行＋0終端バージョン</a></li>
<li><a href="#idddce28">文字列入力</a><ul><li><a href="#id2c9e0f">ソースの整理</a></li>
<li><a href="#id0ab5c5">AH=0Ahのラッパー用サブルーチン</a></li>
<li><a href="#idc7ee97">完成！</a></li></ul></li>
<li><a href="#id766c4e">コマンドラインと環境変数を取得してみる</a><ul><li><a href="#idc5f0ee">環境変数を表示してみる</a></li>
<li><a href="#id3c0335">コマンドラインを表示してみる(1)</a></li>
<li><a href="#id24d0b1">コマンドラインを表示してみる(2)</a></li></ul></li>
<li><a href="#ide0a9e6">まとめ</a></li></ul>
<hr />
<h3 id="ida53d15">NASM版 &quot;Hello, World!&quot;</h3>

<p class="paragraph">
早速 <a href="./view-782.html" >Assembler/ForFun(x86_32)/01, 16bit DOS with debug.exe</a> でdebugコマンドを使って作成した &quot;Hello, World!&quot; を作ってみましょう。
<br />
ファイル名は&quot;hello_world01.asm&quot;とします。開発環境やツール自体が16bitの制限から離れているので、ファイル名も8.3形式に囚われずに済みます。
<br />
hello_world01.asm:
<br />
</p>
<pre class="plugin_pre">
org 100H
bits 16

section .text

start:
    MOV AH, 9H
    MOV DX, hello
    INT 21H
    MOV AH,4CH
    MOV AL,1H
    INT 21H

section .data
hello:
    db &quot;Hello, World!$&quot;

section .bss

</pre>

<p class="paragraph">
ポイント：
<br />
</p>
<ul><li> &quot;org 100h&quot;で、実行時はDS:0100hから始まることを明示する。(ORGディレクティブ)</li>
<li> &quot;bits 16&quot;で、16bitモードを明示する。(BITSディレクティブ)</li></ul>

<p class="paragraph">
より厳密にCPUモードを指定したい場合は、&quot;CPU&quot;ディレクティブを使って命令セットを制限しても良いでしょう。
<br />
</p>
<pre>ex:
CPU 286  ; 80286の命令セットに制限する。
</pre>

<p class="paragraph">
COMファイル生成におけるセグメントの扱いなど、詳細はNASMのドキュメントを参照して下さい。
<br />
</p>
<ul><li> 8.2 Producing .COM Files<ul><li> <a class="externallink" href="http://www.nasm.us/doc/nasmdoc8.html#section-8.2" target="_blank">http://www.nasm.us/doc/nasmdoc8.html#section-8.2</a></li></ul></li></ul>

<p class="paragraph">
コンパイル：
<br />
</p>
<pre>&gt; nasm -fbin -o hello_world01.com hello_world01.asm
</pre>
<p class="paragraph">
実行：
<br />
</p>
<pre class="plugin_pre">
&gt; hello_world01.com
Microsoft (R) KKCFUNC ﾊﾞｰｼﾞｮﾝ 1.10
Copyright (C) Microsoft Corp. 1991,1993. All rights reserved.

KKCFUNC が組み込まれました.

マイクロソフトかな漢字変換  ﾊﾞｰｼﾞｮﾝ 2.51
(C)Copyright Microsoft Corp. 1992-1993
Hello, World!
&gt;
</pre>

<p class="paragraph">
NASMには逆アセンブラも付属していますので、早速hello_world01.comを逆アセンブルしてみましょう。
<br />
&quot;-b&quot;でプロセッサモード、&quot;-o&quot;でオフセットを指定します。
<br />
</p>
<pre class="plugin_pre">
&gt; ndisasm -b 16 -o 100H hello_world01.com
00000100  B409              mov ah,0x9
00000102  BA1001            mov dx,0x110
00000105  CD21              int 0x21
00000107  B44C              mov ah,0x4c
00000109  B001              mov al,0x1
0000010B  CD21              int 0x21
0000010D  0000              add [bx+si],al
0000010F  004865            add [bx+si+0x65],cl
00000112  6C                insb
00000113  6C                insb
00000114  6F                outsw
00000115  2C20              sub al,0x20
00000117  57                push di
00000118  6F                outsw
00000119  726C              jc 0x187
0000011B  642124            and [fs:si],sp
</pre>
<p class="paragraph">
&quot;Hello, World!&quot;のデータ部分まで逆アセンブルされてしまいましたが、実行コード部分はソースと同じコードに逆アセンブルされていることが確認出来ました。
<br />
</p>

<h3 id="id54c011">&quot;Hello, World!&quot;改行＋0終端バージョン</h3>

<p class="paragraph">
NASMの場合、バッククォートで囲むと改行などのエスケープシーケンスがASCIIコードに展開されます。
<br />
これを使って、改行付でHelloWorldを出力してみましょう。また、AH=09hの文字列出力だと&quot;$&quot;で終端させる必要がありましたが、1文字ずつ出力するAH=06hファンクションコールを使ってC言語と同様の0終端文字列に対応させてみます。
<br />
hello_world02.asm:
<br />
</p>
<pre class="plugin_pre">
org 100H
bits 16

section .text

start:
    MOV AH, 6H
    MOV BX, hello
.print1:
    MOV DL, [DS:BX]
    CMP DL, 0H
    JZ .print1_end
    INT 21H
    INC BX
    JMP .print1
.print1_end:

    MOV AH,4CH
    MOV AL,1H
    INT 21H

section .data
hello:
    db `Hello, \r\nWorld!\r\n`, 0

section .bss

</pre>
<p class="paragraph">
コンパイル＋実行：
<br />
</p>
<pre>&gt; nasm -fbin -o hello_world02.com hello_world02.asm
&gt; hello_world02.com
Hello,
World!

</pre>

<h3 id="idddce28">文字列入力</h3>

<p class="paragraph">
文字入力を扱うDOSファンクションコールはいくつかのバリエーションが存在します。
<br />
</p>
<table>
	<tr>
		<td> AH = 01h </td>
		<td> DOS 1+ - READ CHARACTER FROM STANDARD INPUT, WITH ECHO </td>
	</tr>
	<tr>
		<td> AH = 06h </td>
		<td> DOS 1+ - DIRECT CONSOLE INPUT </td>
	</tr>
	<tr>
		<td> AH = 07h </td>
		<td> DOS 1+ - DIRECT CHARACTER INPUT, WITHOUT ECHO </td>
	</tr>
	<tr>
		<td> AH = 08h </td>
		<td> DOS 1+ - CHARACTER INPUT WITHOUT ECHO </td>
	</tr>
	<tr>
		<td> AH = 0Ah </td>
		<td> DOS 1+ - BUFFERED INPUT </td>
	</tr>
	<tr>
		<td> AH = 0Ch </td>
		<td> DOS 1+ - FLUSH BUFFER AND READ STANDARD INPUT </td>
	</tr>
</table>

<p class="paragraph">
今回は文字「列」としてバッファに保存してくれる AH=0Ah を使って名前を入力してもらい、「Hello, (入力された名前), welcome!」と表示してみます。
<br />
</p>

<h4 id="id2c9e0f">ソースの整理</h4>

<p class="paragraph">
「Hello, (入力された名前), welcome!」を表示するとなると、少なくとも「文字列の出力」を２回行うことになります。
<br />
ソースの機能としても、「文字列の出力」「文字列の入力」「プログラム終了」の３種類のDOSファンクションコールを呼ぶことになりますので、一旦それぞれのファンクションコールをサブルーチンとして切り出しておきましょう。
<br />
</p>

<p class="paragraph">
とりあえずhello_world02.asmを書き直して、C言語のstdcall呼び出し規約を意識してサブルーチン化してみました。
<br />
hello_world03.asm:
<br />
</p>
<pre class="plugin_pre">
org 100H
bits 16

section .text

start:
    PUSH hello
    CALL print1
    PUSH 1H
    CALL exit

; arg1(1byte) : exit code
; return : non
exit:
    PUSH BP
    MOV BP, SP
    MOV AH, 4CH
    MOV AL, [BP+4]
    INT 21H

; arg1(2byte) : address of null-terminated string
; return : non
print1:
    PUSH BP
    MOV BP, SP
    MOV AH, 6H
    MOV BX, [BP+4]
.print1_loop:
    MOV DL, [DS:BX]
    CMP DL, 0H
    JZ .print1_end
    INT 21H
    INC BX
    JMP .print1_loop
.print1_end:
    POP BP
    RET 2

section .data
hello:
    db `Hello, \r\nWorld!\r\n`, 0

section .bss

</pre>
<p class="paragraph">
メインルーチンがぐっと見やすくなりました。
<br />
</p>

<p class="paragraph">
ではこれに AH=0Ah ファンクションコールを導入してみましょう。
<br />
</p>

<h4 id="id0ab5c5">AH=0Ahのラッパー用サブルーチン</h4>

<p class="paragraph">
このファンクションコールは、DS:DXに専用の構造体アドレスを格納する必要があります。
<br />
</p>
<pre>offset size  description
00h    BYTE  読み込む文字数(改行含む)
01h    BYTE  戻り値で読み込まれた文字数(改行含まず)
02h    N*BYTE  読み込まれた文字データ＋改行
</pre>

<p class="paragraph">
サブルーチンのIFとしては、文字列を受け取るバッファのアドレスとバッファサイズの２つにしたほうが分かりやすいので、上述の構造体はサブルーチン内部でスタック上に構築してしまいましょう。
<br />
</p>
<pre class="plugin_pre">
    PUSH バッファアドレス
    PUSH WORD バッファサイズ
    CALL gets

; arg1(2byte) : address of buffer
; arg2(2byte) : buffer length (including null terminator)
; return : non
gets:
    PUSH BP
    MOV BP, SP
    XOR AX, AX
    MOV AX, [BP+4]
    SUB SP, AX
    PUSH AX
</pre>
<p class="paragraph">
構造体のoffset:01hについてですが、初回呼び出し時はとりあえず0でOKです。バッファサイズをPUSHするときにWORDサイズでPUSHしてもらうと、ちょうどAXで受け取りスタックに積み直すことで、リトルエンディアンなので offset 00h, 01h がバッファサイズ, 0の並びになります。
<br />
あとはINT21hを呼びます。
<br />
</p>
<pre>   XOR AX, AX
   MOV AH, 0AH
   MOV DX, SP
   INT 21H
</pre>
<p class="paragraph">
続けて、末尾が改行になっていますので&quot;0&quot;に上書きします。
<br />
</p>
<pre>   ; retrieve &quot;number of read chars&quot;
   MOV BX, SP
   INC BX
   XOR AX, AX
   MOV AL, BYTE [BX]
   ; overwrite CR to 0
   MOV BX, SP
   ADD BX, 2
   ADD BX, AX
   MOV BYTE [BX], 0H
</pre>
<p class="paragraph">
仕上げに、スタック上のバッファ内容を、引数で受け取ったバッファアドレスにコピーします。
<br />
</p>
<pre>   MOV SI, SP
   ADD SI, 2
   MOV DI, [BP+6]
   XOR CX, CX
   MOV CL, AL
   INC CX  ; for terminate character
   REP MOVSB
</pre>
<p class="paragraph">
最後にスタックフレームを復元して戻ります。
<br />
</p>
<pre>   POP AX
   MOV AX, [BP+4]
   ADD SP, AX
   POP BP
   RET
</pre>

<h4 id="idc7ee97">完成！</h4>

<p class="paragraph">
「Hello, (入力された名前), welcome!」を表示する最終的なアセンブラコードは次のようになりました。
<br />
hello_world03.asm:
<br />
</p>
<pre class="plugin_pre">
org 100H
bits 16

section .text

name_buf_len equ 10

start:
    PUSH BP
    MOV BP, SP

    PUSH prompt
    CALL print1

    PUSH name_buf
    PUSH WORD name_buf_len
    CALL gets

    PUSH hello_1
    CALL print1

    PUSH name_buf
    CALL print1

    PUSH hello_2
    CALL print1

    PUSH 1H
    CALL exit

; arg1(2byte) : address of buffer
; arg2(2byte) : buffer length (including null terminator)
; return : non
gets:
    PUSH BP
    MOV BP, SP
    XOR AX, AX
    MOV AX, [BP+4]
    SUB SP, AX
    PUSH AX

    XOR AX, AX
    MOV AH, 0AH
    MOV DX, SP
    INT 21H

    ; retrieve &quot;number of read chars&quot;
    MOV BX, SP
    INC BX
    XOR AX, AX
    MOV AL, BYTE [BX]
    ; overwrite CR to 0
    MOV BX, SP
    ADD BX, 2
    ADD BX, AX
    MOV BYTE [BX], 0H

    MOV SI, SP
    ADD SI, 2
    MOV DI, [BP+6]
    XOR CX, CX
    MOV CL, AL
    INC CX  ; for terminate character
    REP MOVSB

    POP AX
    MOV AX, [BP+4]
    ADD SP, AX
    POP BP
    RET

; arg1(1byte) : exit code
; return : non
exit:
    PUSH BP
    MOV BP, SP
    MOV AH, 4CH
    MOV AL, [BP+4]
    INT 21H

; arg1(2byte) : address of null-terminated string
; return : non
print1:
    PUSH BP
    MOV BP, SP
    MOV AH, 6H
    MOV BX, [BP+4]
.print1_loop:
    MOV DL, [DS:BX]
    CMP DL, 0H
    JZ .print1_end
    INT 21H
    INC BX
    JMP .print1_loop
.print1_end:
    POP BP
    RET 2

section .data
prompt:
    db &quot;What&#039;s your name ? : &quot;, 0
hello_1:
    db `\r\nHello, `, 0
hello_2:
    db `, welcome!\r\n`, 0

section .bss
name_buf resb name_buf_len

</pre>

<p class="paragraph">
コンパイル＋実行：
<br />
</p>
<pre>&gt; nasm -fbin -o hello_world03.com hello_world03.asm
&gt; hello_world03.com
What&#039;s your name ? : 123456789
Hello, 123456789, welcome!

&gt;hello_world03.com
What&#039;s your name ? : FooBar
Hello, FooBar, welcome!

&gt;
</pre>

<h3 id="id766c4e">コマンドラインと環境変数を取得してみる</h3>

<p class="paragraph">
<a href="./view-782.html" >Assembler/ForFun(x86_32)/01, 16bit DOS with debug.exe</a> の記事では取りあげませんでしたが、コマンドラインや環境変数を取得することも出来ます。
<br />
MS-DOSの場合、COM or EXEがロード後、&quot;Program Segment Prefix&quot;(PSP)という領域を参照するとコマンドラインや環境変数を取り出せるようになっています。
<br />
</p>

<p class="paragraph">
&quot;Program Segment Prefix&quot; 参考資料：
<br />
</p>
<ul><li> The Program Segment Prefix - PSP<ul><li> <a class="externallink" href="http://www.nolm.org/TAE/c001p16.htm" target="_blank">http://www.nolm.org/TAE/c001p16.htm</a></li></ul></li>
<li> MS-DOS Program Segment Prefix<ul><li> <a class="externallink" href="http://www.nolm.org/TAE/appd/psp.htm" target="_blank">http://www.nolm.org/TAE/appd/psp.htm</a></li></ul></li>
<li> Art of Assembly: Chapter 13 - 8<ul><li> <a class="externallink" href="http://webster.cs.ucr.edu/AoA/DOS/ch13/CH13-8.html" target="_blank">http://webster.cs.ucr.edu/AoA/DOS/ch13/CH13-8.html</a></li></ul></li>
<li> Program Segment Prefix - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Program_Segment_Prefix" target="_blank">http://en.wikipedia.org/wiki/Program_Segment_Prefix</a></li></ul></li>
<li> DOS Environment Table Description; Basic&#039;s ENVIRON Statement<ul><li> <a class="externallink" href="http://support.microsoft.com/kb/69846" target="_blank">http://support.microsoft.com/kb/69846</a></li></ul></li>
<li> Accessing Command Line Arguments<ul><li> <a class="externallink" href="http://support.microsoft.com/kb/123729" target="_blank">http://support.microsoft.com/kb/123729</a></li></ul></li></ul>

<h4 id="idc5f0ee">環境変数を表示してみる</h4>

<p class="paragraph">
PSPの0x2C, 2Dで示されたセグメントの先頭から環境変数を取得出来ます。一つのエントリは&#039;0&#039;終端で、最後のエントリの後には&#039;0&#039;が二つ続きます。
<br />
ざっくりロジックを作ってみると、こうなりました。ロード直後は、PSPのセグメントはCOM/EXEともにDSに保存されています。
<br />
</p>
<pre class="plugin_pre">
start:
    PUSH BP
    MOV BP, SP

    MOV BX, [DS:002Ch]
    MOV DS, BX

    MOV BX, 0000H

.loop2:
    PUSH BX
    CALL print1
.loop1:
    ; 1エントリの&#039;0&#039;終端までBXポインタを進めます。
    INC BX
    CMP BYTE [DS:BX], 0
    JNZ .loop1
    ; 1文字前進させて&#039;0&#039;なら、&#039;0&#039;が2つ続いたので全エントリを表示し終わったことを意味します。
    INC BX
    CMP BYTE [DS:BX], 0
    JNZ .loop2

    PUSH 1H
    CALL exit
</pre>
<p class="paragraph">
しかしこれだと改行が無いので見づらいです。そこで&quot;.data&quot;セクションにCRLFだけの文字列をおいて、1エントリ分表示した後にCRLFを表示させてみます。
<br />
ここで注意が必要です。エントリをチェックするメインのループでは、DSは環境変数のセグメントを指しています。しかしCRLFの文字列は実行コードと同じCSセグメントに存在します。
<br />
そのため、CRLFを表示するのであれば一時的にセグメントを切替え、表示を終えたらまた環境変数のセグメントに戻す必要があります。なお起動直後はCSとDSは同じ値になっていますので、ここではDSを保存し、切り替えに使います。
<br />
</p>
<ol><li> プログラム起動時点でのDSを保存。</li>
<li> CRLF出力の箇所だけ、保存しておいたDSに切り替える。</li></ol>

<p class="paragraph">
この2点を盛り込み、改行コード付で表示出来るようにしたのが次のソースコードです。
<br />
env.asm:
<br />
</p>
<pre class="plugin_pre">
org 100H
bits 16

section .text

start:
    PUSH BP
    MOV BP, SP

    PUSH DS            ; スタック上にプログラム起動時点でのDSを保存
    MOV BX, [DS:002Ch]
    MOV [segenv], BX   ; 環境変数のセグメントを保存
    MOV DS, BX         ; 環境変数のセグメントに切替

    MOV BX, 0000H

.loop2:
    PUSH BX
    CALL print1

    POP DS            ; プログラム起動時点のDSを復元
    PUSH crlf
    CALL print1
    PUSH DS
    MOV DS, [segenv]  ; 環境変数のセグメントに切替

.loop1:
    INC BX
    CMP BYTE [DS:BX], 0
    JNZ .loop1
    INC BX
    CMP BYTE [DS:BX], 0
    JNZ .loop2

    POP DS
    PUSH 1H
    CALL exit

; arg1(1byte) : exit code
; return : non
exit:
    PUSH BP
    MOV BP, SP
    MOV AH, 4CH
    MOV AL, [BP+4]
    INT 21H

; arg1(2byte) : address of null-terminated string
; return : non
print1:
    PUSH BP
    MOV BP, SP
    PUSH BX
    PUSH DX
    MOV AH, 6H
    MOV BX, [BP+4]
.print1_loop:
    MOV DL, [DS:BX]
    CMP DL, 0H
    JZ .print1_end
    INT 21H
    INC BX
    JMP .print1_loop
.print1_end:
    POP DX
    POP BX
    POP BP
    RET 2

section .data
crlf:
    db `\r\n`, 0

section .bss
segenv:
    resw 1

</pre>

<p class="paragraph">
コンパイル：
<br />
</p>
<pre>&gt; nasm -fbin -o env.com env.asm
</pre>

<p class="paragraph">
実行結果は自明なので省略します。
<br />
</p>

<h4 id="id3c0335">コマンドラインを表示してみる(1)</h4>

<p class="paragraph">
続いてコマンドラインを表示してみます。
<br />
PSPのドキュメントを調べていくと、80hにコマンドラインの長さが、81hからコマンドラインに渡された文字列が格納されていることが分かります。
<br />
終端文字列は不定のようなので、80hで取得された文字数分だけ、1文字ずつ表示してみます。
<br />
</p>

<p class="paragraph">
cmdline1.asm:
<br />
</p>
<pre class="plugin_pre">
org 100H
bits 16

section .text

start:
    PUSH BP
    MOV BP, SP

    XOR CX, CX
    MOV CL, [DS:0080h]
    CMP CX, 0
    JZ .loop_end
    MOV AH, 02H
    XOR DX, DX
    MOV BX, 81H
.loop:
    MOV DL, [BX]
    INT 21H
    INC BX
    LOOP .loop
.loop_end:

    PUSH 1H
    CALL exit

; arg1(1byte) : exit code
; return : non
exit:
    PUSH BP
    MOV BP, SP
    MOV AH, 4CH
    MOV AL, [BP+4]
    INT 21H

section .data

section .bss

</pre>

<p class="paragraph">
コンパイル＋実行:
<br />
</p>
<pre>&gt; nasm -fbin -o cmdline1.com cmdline1.asm
&gt; cmdline1.com

&gt; cmdline1.com a b c d
 a b c d
&gt;
</pre>

<h4 id="id24d0b1">コマンドラインを表示してみる(2)</h4>

<p class="paragraph">
コマンドライン文字列を表示出来ましたが、自分自身のプログラム名が表示されていません。
<br />
MicrosoftのKB自分自身のプログラム名については、KB123729を見ると環境変数のブロックに続けて格納されているようです。
<br />
実際にdebugコマンドで見てみると、環境変数のブロック終端である二つの&#039;0&#039;の後ろに、&quot;01 00&quot;が続き、その後にプログラム名が格納されています。
<br />
</p>
<pre class="plugin_pre">
&gt; debug cmdline1.com
-D 2C 2D
2D57:0020                                      FE 2C                     .,
-D 2CFE:0500 L 100
...
2CFE:0560  33 30 20 54 33 00 00 01-00 43 4D 44 4C 49 4E 45   30 T3....CMDLINE
                                ^^^^^
2CFE:0570  31 2E 43 4F 4D 00 00 00-48 57 00 00 00 00 00 00   1.COM...HW......
</pre>
<p class="paragraph">
終端文字列はとりあえず&#039;0&#039;と仮定して良さそうです。
<br />
</p>

<p class="paragraph">
環境変数を表示した時のenv.asmを改造した cmdline2.asm は以下のようになりました。
<br />
</p>
<pre class="plugin_pre">
org 100H
bits 16

section .text

start:
    PUSH BP
    MOV BP, SP

    PUSH DS
    MOV BX, [DS:002Ch]
    MOV [segenv], BX
    MOV DS, BX

    MOV BX, 0000H

.loop1:
    INC BX
    CMP BYTE [DS:BX], 0
    JNZ .loop1
    INC BX
    CMP BYTE [DS:BX], 0
    JNZ .loop1

    ADD BX, 3       ; &quot;01 00&quot;をスキップ
    PUSH BX
    CALL print1

    POP DS
    PUSH 1H
    CALL exit

; arg1(1byte) : exit code
; return : non
exit:
（以下 env.asm と同じ）
</pre>

<p class="paragraph">
コンパイル＋実行:
<br />
</p>
<pre>&gt; nasm -fbin -o cmdline2.com cmdline2.asm
&gt; cmdline2.com
C:\(...)\CMDLINE2.COM
&gt;
</pre>

<p class="paragraph">
上手く動いてくれたようです。
<br />
なおdebug経由で起動した時は&quot;CMDLINE2.COM&quot;しか格納されていませんが、単体で起動するとフルパスで格納されるようです。
<br />
</p>

<h3 id="ide0a9e6">まとめ</h3>

<p class="paragraph">
NASMを使って16bitDOSプログラム(COMフォーマット)を組み立てる手順を見ていきました。
<br />
またDOS環境における環境変数やコマンドライン文字列の取得方法についても見ていきました。
<br />
32bitから64bitへの移行が進んでいる2010年現在、16bitDOSプログラムをアセンブラで開発する機会は滅多にないと思いますが、もし万が一、そのような機会に遭遇した時にこのページを思い出して頂ければ幸いです。
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-782.html" title="Assembler/ForFun(x86_32)/01, 16bit DOS with debug.exe">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-784.html" title="Assembler/ForFun(x86_32)/03, x86_32用 デバッグ機能有効化 Bochs をVC++2008でビルド">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-790.html" title="Assembler/ForFun(x86_32)">Up</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-410.html" title="Assembler">Assembler</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/783<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2001 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" target="_blank" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>