<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>日記/2009/11/23/yaccの練習 - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">日記/2009/11/23/yaccの練習</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2009-11-23 20:26:15 &nbsp; / &nbsp; last updated at: 2009-11-23 20:41:44<br>
カテゴリ: <a href="category-12.html">プログラミング</a>&nbsp;</div>

<div class="data_body">
<p class="paragraph">
<a href="https://www.amazon.co.jp/dp/4774138959" target="_blank">プログラミング言語を作る</a>
<br />
勉強を始めたのだけれど、速攻でyaccとlexのところで躓いてしまいました。トークンがスタックにshiftされ(=積まれ)、条件にマッチするとreduce(=設定したイベントが走り一つ上位の非終端子にランクアップ)されるのは良いのだけれど、conflictの所が良く理解できないっす。
<br />
</p>

<p class="paragraph">
というわけで、同書の電卓プログラムをベースに単純なものから試行錯誤でグレードアップしていき、最終的に同書と同じレベルに戻してみるというすごい無駄な事をしてみました。。スミマセン、こういうやり方でないと上手く頭に入ってこないんです・・・。つくづく技術書の読み方というか勉強の仕方が下手くそだと思う今日この頃。
<br />
</p>

<p class="paragraph">
※CentOS 5.2 上の byacc-1.9, flex-2.5.4a で動作確認しています。特に &quot;y.output&quot; ファイルのフォーマットなどはバージョンにより異なる可能性がある為注意して下さい。
<br />
</p>



<hr />
<ul><li><a href="#idf6f837">準備と、足し算引き算しか出来ない電卓の作成（第１世代）</a></li>
<li><a href="#id0a47d0">第２世代：数字だけ、あるいは3つ以上の足し算・引き算対応版</a><ul><li><a href="#idbc1650">まず「数字だけ」に対応</a></li>
<li><a href="#id51da9e">3つ以上の足し算・引き算に対応</a></li>
<li><a href="#idfb4a63">YYDEBUGとy.outputを見比べながらshift/reduceの挙動を確認してみる</a><ul><li><a href="#id8b1642">トークンのスタックと、状態のスタック</a></li>
<li><a href="#id1ecf93">トークンのスタックと、状態のスタック（&quot;1 + 2&quot;入力時)</a></li>
<li><a href="#id9686a9">トークンのスタックと、状態のスタック（&quot;1 + 2 + 3&quot;入力時)</a></li></ul></li></ul></li>
<li><a href="#id6222e9">第２世代：かけ算・割り算対応版（不完全版）</a><ul><li><a href="#id7a8f87">とにかく左から順に計算させる</a></li>
<li><a href="#idb6b11e">かけ算・割り算を優先させてみる（不完全版）</a></li></ul></li>
<li><a href="#idabf79c">第３世代：かけ算・割り算対応の完全版</a><ul><li><a href="#id0de2ed">トークンスタック・状態スタック詳解</a><ul><li><a href="#id498a41">少し気になったところ</a></li></ul></li></ul></li>
<li><a href="#id03004b">まとめと感想</a></li></ul>
<hr />

<h3 id="idf6f837">準備と、足し算引き算しか出来ない電卓の作成（第１世代）</h3>

<p class="paragraph">
サポートページからソースを入手して展開します。&quot;calc/mycalc&quot; ディレクトリに入り、&quot;mycalc.y&quot; を &quot;mycalc2.y&quot; にコピー。
<br />
そして &quot;mycalc2.y&quot;の構文規則を次のように書き換えます。
<br />
</p>
<pre class="plugin_pre">
...
%type &lt;double_value&gt; expression
%%
line_list
    : line
    | line_list line
    ;
line
    : expression CR
    {
        printf(&quot;&gt;&gt;%lf\n&quot;, $1);
    }
expression
    : DOUBLE_LITERAL ADD DOUBLE_LITERAL
    {
        printf(&quot;reduction (ADD) occurr!!\n&quot;);
        printf(&quot;[%f ADD %f]\n&quot;, $1, $3);
        $$ = $1 + $3;
    }
    | DOUBLE_LITERAL SUB DOUBLE_LITERAL
    {
        printf(&quot;reduction (SUB) occurr!!\n&quot;);
        printf(&quot;[%f SUB %f]\n&quot;, $1, $3);
        $$ = $1 - $3;
    }
    ;
%%
</pre>
<p class="paragraph">
mycalc.lの方はそのまま使い回せます。で、コンパイル。
<br />
</p>
<pre>$ yacc -dv mycalc2.y
$ lex mycalc.l
$ gcc -o mycalc2 y.tab.c lex.yy.c
</pre>
<p class="paragraph">
この時点でパニック。「え、lexが字句解析で、yaccが構文解析でしょ？なんで先にyaccを実行して、後にlexを実行するの？」
<br />
一般的な説明としては「lexの方でy.tab.hを必要としていて(#includeしてる)、y.tab.hを作るにはyaccを実行しないといけない」からなのですが、そうなると「y.tab.hって何？」となるわけです。で、覗いてみるとこんな感じ。
<br />
</p>
<div class="hl-main"><pre><span >#ifndef</span><span class="hl-code"> </span><span class="hl-identifier">YYERRCODE</span><span ></span><span class="hl-code">
</span><span >#define</span><span class="hl-code"> </span><span class="hl-identifier">YYERRCODE</span><span class="hl-code"> </span><span class="hl-number">256</span><span ></span><span class="hl-code">
</span><span >#endif</span><span ></span><span class="hl-code">
 
</span><span >#define</span><span class="hl-code"> </span><span class="hl-identifier">DOUBLE_LITERAL</span><span class="hl-code"> </span><span class="hl-number">257</span><span ></span><span class="hl-code">
</span><span >#define</span><span class="hl-code"> </span><span class="hl-identifier">ADD</span><span class="hl-code"> </span><span class="hl-number">258</span><span ></span><span class="hl-code">
</span><span >#define</span><span class="hl-code"> </span><span class="hl-identifier">SUB</span><span class="hl-code"> </span><span class="hl-number">259</span><span ></span><span class="hl-code">
</span><span >#define</span><span class="hl-code"> </span><span class="hl-identifier">MUL</span><span class="hl-code"> </span><span class="hl-number">260</span><span ></span><span class="hl-code">
</span><span >#define</span><span class="hl-code"> </span><span class="hl-identifier">DIV</span><span class="hl-code"> </span><span class="hl-number">261</span><span ></span><span class="hl-code">
</span><span >#define</span><span class="hl-code"> </span><span class="hl-identifier">CR</span><span class="hl-code"> </span><span class="hl-number">262</span><span ></span><span class="hl-code">
</span><span >typedef</span><span class="hl-code"> </span><span >union</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span >int</span><span class="hl-code">          </span><span class="hl-identifier">int_value</span><span class="hl-code">;
    </span><span >double</span><span class="hl-code">       </span><span class="hl-identifier">double_value</span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-identifier">YYSTYPE</span><span class="hl-code">;
</span><span >extern</span><span class="hl-code"> </span><span class="hl-identifier">YYSTYPE</span><span class="hl-code"> </span><span class="hl-identifier">yylval</span><span class="hl-code">;</span></pre></div>
<p class="paragraph">
うーん、mycalc2.yファイル中で &quot;%token&quot;指定したシンボルのdefine値、あとは%union指定した構造のC言語表現ですが・・・シンボルのdefineとか、何か適当な数値がdefineされてて訳分かりません。
<br />
ただしmycalc.lの方では、各トークンの正規表現に対して &quot;return ADD&quot;とか&quot;return DOUBLE_LIETRAL&quot;とかしてて、これがC言語のコード、つまりy.tab.hというのはlex側で「return ほげほげ」するための定義ファイルになるわけです。他にもlex側でunionに値をセットする所もあります。
<br />
</p>

<p class="paragraph">
だったらlexファイルの方で定義して、それをyacc側で読むようにすればいいじゃん・・・とも思いますが、結局 ADD とか SUB とかのトークンは構文定義と一体ですので、一箇所にまとめておいた方がメンテナンスは楽です。であれば、yacc側で生成したのを逆にlex側で取り込んだ方が良い。みたいな理由でこうなったのだろうな・・・と理解しました。本当は違うかも知れませんが。
<br />
</p>

<p class="paragraph">
とまれ、実行時の処理の流れとしては「字句解析→構文解析」なのですが、字句解析の結果をどう構文解析に橋渡しすればよいのか、となりますとやっぱり「字句解析から何を貰えば良いのか」は構文解析側が一番良く分かっているはずです。なので、主従関係は「構文解析（主）→字句解析（従）」となるわけです。y.tab.hというのは構文解析側が「こういう結果が欲しい」と字句解析側に提示する為のインターフェイス、と考えると、自分の場合はすんなりと理解できました。
<br />
</p>

<p class="paragraph">
寄り道しましたが実行してみます。
<br />
</p>
<pre>$ ./mycalc2
1 + 2
reduction (ADD) occurr!!
[1.000000 ADD 2.000000]
&gt;&gt;3.000000
3 - 1
reduction (SUB) occurr!!
[3.000000 SUB 1.000000]
&gt;&gt;2.000000
</pre>
<p class="paragraph">
ここまではちゃんと動いてます。いつ&quot;reduce&quot;されるのかも分かって良いですね。ところが3つ以上を足し算させるとエラーになってしまいます。
<br />
</p>
<pre>1 + 2 + 3
reduction (ADD) occurr!!
[1.000000 ADD 2.000000]
parser error near +
Error ! Error ! Error !
</pre>
<p class="paragraph">
これは当然で、まだそんな構文は定義してません。あと、&quot;123&quot;みたいな数字だけのもNGです。
<br />
</p>
<pre>$ ./mycalc2
123
parser error near

Error ! Error ! Error !
</pre>

<p class="paragraph">
ということで、まずは&quot;123&quot;みたいな只の数字だけのにも対応させてみます。
<br />
</p>

<h3 id="id0a47d0">第２世代：数字だけ、あるいは3つ以上の足し算・引き算対応版</h3>

<h4 id="idbc1650">まず「数字だけ」に対応</h4>

<p class="paragraph">
mycalc2.yのexpressionにパターンを一つ追加します。
<br />
</p>
<pre>...
expression
    : DOUBLE_LITERAL
    | DOUBLE_LITERAL ADD DOUBLE_LITERAL
    {
...
</pre>
<p class="paragraph">
でコンパイル、実行。
<br />
</p>
<pre>$ ./mycalc2
123
&gt;&gt;123.000000
</pre>
<p class="paragraph">
はいOK。
<br />
</p>

<h4 id="id51da9e">3つ以上の足し算・引き算に対応</h4>

<p class="paragraph">
これは本にならって、
<br />
</p>
<pre>expression = expression ADD DOUBLE_LITERAL
expression = expression SUB DOUBLE_LITERAL
</pre>
<p class="paragraph">
みたいにすればよさそうです。
<br />
</p>
<pre class="plugin_pre">
expression
    : DOUBLE_LITERAL
    | expression ADD DOUBLE_LITERAL
    {
        printf(&quot;reduction (ADD) occurr!!\n&quot;);
        printf(&quot;[%f ADD %f]\n&quot;, $1, $3);
        $$ = $1 + $3;
    }
    | expression SUB DOUBLE_LITERAL
    {
        printf(&quot;reduction (SUB) occurr!!\n&quot;);
        printf(&quot;[%f SUB %f]\n&quot;, $1, $3);
        $$ = $1 - $3;
    }
    ;
</pre>
<p class="paragraph">
コンパイルして実行してみます。
<br />
</p>
<pre>$ yacc -dv mycalc2.y
$ gcc -o mycalc2 y.tab.c lex.yy.c
$ ./mycalc2
1 + 2
reduction (ADD) occurr!!
[1.000000 ADD 2.000000]
&gt;&gt;3.000000
1
&gt;&gt;1.000000
</pre>
<p class="paragraph">
ここから3つ以上の足し算引き算をさせてみます。
<br />
</p>
<pre>1 + 2 + 3
reduction (ADD) occurr!!
[1.000000 ADD 2.000000]
reduction (ADD) occurr!!
[3.000000 ADD 3.000000]
&gt;&gt;6.000000
3 - 2 + 1
reduction (SUB) occurr!!
[3.000000 SUB 2.000000]
reduction (ADD) occurr!!
[1.000000 ADD 1.000000]
&gt;&gt;2.000000
</pre>
<p class="paragraph">
OKぽいです。
<br />
</p>

<h4 id="idfb4a63">YYDEBUGとy.outputを見比べながらshift/reduceの挙動を確認してみる</h4>

<p class="paragraph">
mycalc.yでは、ヘッダー部に
<br />
</p>
<pre>#define YYDEBUG 1
</pre>
<p class="paragraph">
というのが定義されています。しかしこれだけではデバッグメッセージは表示されません。生成されたy.tab.cを&quot;YYDEBUG&quot;でgrepすれば分かりますが、YYDEBUG環境変数が&quot;1&quot;以上に設定されている必要があります。
<br />
というわけで、以下のようにするとデバッグメッセージが表示されます(bashの場合)。
<br />
</p>
<pre>$ YYDEBUG=1 ./mycalc2
</pre>

<p class="paragraph">
ここから、説明がもの凄い細かくて冗長になってくるので「大体把握してるからオッケー。」な人は読み飛ばして下さい。
<br />
</p>

<p class="paragraph">
さてデバッグメッセージを元にyaccのshift/reduceの流れを追っていきたいと思います。先ほどからyacc実行時に&quot;-dv&quot;をつけていますが、&quot;-v&quot;オプションが、y.outputファイルでパーサの詳細を人間で読める形に出力してくれます。ということで、y.outputも見つつ追っていきます。
<br />
下準備として y.output の構成だけざっくりと見ておきます。
<br />
y.output:
<br />
</p>
<pre class="plugin_pre">
   0  $accept : line_list $end

   1  line_list : line
   2            | line_list line

   3  line : expression CR

   4  expression : DOUBLE_LITERAL
   5             | expression ADD DOUBLE_LITERAL
   6             | expression SUB DOUBLE_LITERAL
^L
state 0
        $accept : . line_list $end  (0)

        DOUBLE_LITERAL  shift 1
        .  error

        line_list  goto 2
        expression  goto 3
        line  goto 4


state 1
        expression : DOUBLE_LITERAL .  (4)

        .  reduce 4
...
</pre>
<p class="paragraph">
&quot;^L&quot;までが構文規則そのもののようです。&quot;|&quot;も番号を振って、別ものとして分かるようにしてくれています。
<br />
&quot;state 0&quot;以降がパーサ処理の状態遷移を表しているようです。パース処理を行う場合は、次々と字句解析からやってくるトークンに対して、「今はこの状態で、次のトークンがこれだったら、あの処理を行ってあっちの状態に移る」みたいな状態遷移でぐるぐるまわしているようです。読み方ですが、
<br />
</p>
<pre>state 番号
    reduceルール (ルール番号)

    終端子(トークン) shift (shift先のstate番号)
    終端子(トークン) reduce (reduceで使うルール番号)
    . error # 想定外のトークンなのでパースエラーにしたい時
    . reduce (reduceで使うルール番号) # この状態に来た段階でreduceかけたい時

    非終端子 goto (shift先のstate番号)
</pre>
<p class="paragraph">
ポイントとしては以下の2点。
<br />
</p>
<ul><li> ルール定義, 字句解析からのトークンに応じたアクション, 非終端子があった時のアクションの順で定義</li>
<li> &quot;.&quot;が、トークンアクションと非終端子アクションの境目</li></ul>

<p class="paragraph">
では実際に、まず数字だけを入力してみた場合です。
<br />
</p>
<pre>123
</pre>
<p class="paragraph">
このデバッグメッセージは以下になります。
<br />
</p>
<pre class="plugin_pre">
123
yydebug: state 0, reading 257 (DOUBLE_LITERAL)
yydebug: state 0, shifting to state 1
yydebug: state 1, reducing by rule 4 (expression : DOUBLE_LITERAL)
yydebug: after reduction, shifting from state 0 to state 3
yydebug: state 3, reading 262 (CR)
yydebug: state 3, shifting to state 8
yydebug: state 8, reducing by rule 3 (line : expression CR)
&gt;&gt;123.000000
yydebug: after reduction, shifting from state 0 to state 4
yydebug: state 4, reducing by rule 1 (line_list : line)
yydebug: after reduction, shifting from state 0 to state 2
</pre>
<p class="paragraph">
まず&quot;state 0&quot;で始まり、字句解析から DOUBLE_LITERAL がやってきます。
<br />
</p>
<pre>yydebug: state 0, reading 257 (DOUBLE_LITERAL)
</pre>
<p class="paragraph">
すると・・・
<br />
</p>
<pre>state 0
        $accept : . line_list $end  (0)
                  ↑ &quot;.&quot;というのは、「今ここにいるよ」という印みたいです。

        DOUBLE_LITERAL  shift 1
        ↑で、こに引っ掛かります。
</pre>
<p class="paragraph">
というわけで、字句解析が読み込んだ値がスタックに積まれ、状態は&quot;state 1&quot;に遷移します。
<br />
</p>
<pre>yydebug: state 0, shifting to state 1
</pre>
<p class="paragraph">
&quot;state 1&quot;を見てみましょう。
<br />
</p>
<pre>state 1
        expression : DOUBLE_LITERAL .  (4)

        .  reduce 4
</pre>
<p class="paragraph">
デバッグメッセージを見ると・・・
<br />
</p>
<pre>yydebug: state 1, reducing by rule 4 (expression : DOUBLE_LITERAL)
</pre>
<p class="paragraph">
ルール&quot;4&quot;により&quot;reduce&quot;される、と言っています。つまり&quot;expression : DOUBLE_LITERAL&quot;に引っ掛かったのでreduceされます。この時は何もイベントを定義していないので、暗黙の&quot;$$ = $1&quot;が実行されるだけです。
<br />
</p>

<p class="paragraph">
次のデバッグログですが・・・
<br />
</p>
<pre>yydebug: after reduction, shifting from state 0 to state 3
</pre>
<p class="paragraph">
reduceが終わった後、&quot;state 0&quot;から&quot;state 3&quot;へ移動するとあります。<strong>先ほどまで &quot;state 1&quot; にいた筈なのに、何時の間に &quot;state 0&quot; になったんだ！？</strong>という感じです。ほかにも、なぜ次の状態が &quot;state 3&quot; なのか？何時の間に決められたのか？
<br />
何となく、先ほどのreduceで &quot;DOUBLE_LITERAL&quot; が &quot;expression&quot; になり、state 0 の方では
<br />
</p>
<pre>state 0
...
       expression  goto 3
</pre>
<p class="paragraph">
とあるから・・・かなぁ？という雰囲気ではあります。
<br />
</p>

<h5 id="id8b1642">トークンのスタックと、状態のスタック</h5>

<p class="paragraph">
結論から先に書くと、yaccはトークンのスタックの他に「状態」もスタックさせています。「状態」のスタックには最初は&quot;state 0&quot;がスタックされていて、一方初期状態ではトークンは勿論空っぽです。
<br />
</p>
<pre>state stack       |-&gt; [state 0]
------------------+--------------
token/value stack |-&gt; (empty)
</pre>
<p class="paragraph">
ではこのスタックを、デバッグメッセージを元に最初から手で操作していきましょう。
<br />
</p>
<pre>123(リターン)
yydebug: state 0, reading 257 (DOUBLE_LITERAL)
</pre>
<p class="paragraph">
→
<br />
</p>
<pre>state stack       |-&gt; [state 0]
------------------+--------------
token/value stack |-&gt; DOUBLE_LITERAL(=123)
</pre>
<p class="paragraph">
と言う風に値が積まれます。すると、&quot;y.output&quot;で書かれているように
<br />
</p>
<pre>state 0
        DOUBLE_LITERAL  shift 1
</pre>
<p class="paragraph">
として&quot;state 1&quot;に遷移します。内部的には、状態スタックの方に&quot;state 1&quot;が積まれます。
<br />
</p>
<pre>yydebug: state 0, shifting to state 1
</pre>
<p class="paragraph">
→
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 1]
------------------+--------------
token/value stack |-&gt; DOUBLE_LITERAL(=123)
</pre>
<p class="paragraph">
するとここで、&quot;y.output&quot;にあるとおり構文解析のルール4番が適用できます。
<br />
</p>
<pre>state 1
        expression : DOUBLE_LITERAL .  (4)
        .  reduce 4
</pre>
<p class="paragraph">
このデバッグログにあたります。
<br />
</p>
<pre>yydebug: state 1, reducing by rule 4 (expression : DOUBLE_LITERAL)
</pre>
<p class="paragraph">
ここで暗黙の &quot;$$ = $1&quot; が実行されます。すると、&quot;DOUBLE_LITERAL&quot;が&quot;expression&quot;にreduceされます。
<br />
<strong>さらに、状態スタックがreduceされた要素数分、ポップアップされます。</strong>reduceされたのは&quot;DOUBLE_LITERAL&quot;一つ分なので、最後にpushされた1つ分の[state 1] が削られます。
<br />
</p>
<pre>state stack       |-&gt; [state 0]
------------------+--------------
token/value stack |-&gt; expression(=123)
</pre>
<p class="paragraph">
<strong>そして現在のステータスは、状態スタックに積まれているlast要素になります。</strong>つまり今の状態なら&quot;state 0&quot;になります。
<br />
ここで、&quot;y.output&quot;では &quot;state 0&quot; で非終端子がexpressionなら&quot;state 3&quot;に遷移するよう指示されています。
<br />
</p>
<pre>state 0
       ...
       expression  goto 3
</pre>
<p class="paragraph">
これによる状態遷移が、次のデバッグログにあたります。
<br />
</p>
<pre>yydebug: after reduction, shifting from state 0 to state 3
</pre>
<p class="paragraph">
&quot;state 3&quot;ですが、非終端子アクションは未定義です。
<br />
</p>
<pre>state 3
        line : expression . CR  (3)
        expression : expression . ADD DOUBLE_LITERAL  (5)
        expression : expression . SUB DOUBLE_LITERAL  (6)

        ADD  shift 6
        SUB  shift 7
        CR  shift 8
        .  error
</pre>
<p class="paragraph">
よってここでは字句解析からのトークンを待つ事になりますが、既に&quot;CR&quot;(改行)が入力に入っています。
<br />
</p>
<pre>yydebug: state 3, reading 262 (CR)
</pre>
<p class="paragraph">
すると
<br />
</p>
<pre>        CR  shift 8
</pre>
<p class="paragraph">
が反応して、&quot;state 8&quot;に遷移します。
<br />
</p>
<pre>yydebug: state 3, shifting to state 8
</pre>
<p class="paragraph">
この状態のスタックを見ると、次のようになっています。
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 8]
------------------+--------------
token/value stack |-&gt; expression(=123), CR
</pre>
<p class="paragraph">
さて、&quot;state 8&quot;の状態遷移定義を&quot;y.output&quot;で見てみるとトークンアクションも非終端子アクションも未定義で、すぐreduceに入るようになっています。
<br />
</p>
<pre>state 8
        line : expression CR .  (3)

        .  reduce 3
</pre>
<p class="paragraph">
このデバッグログです。
<br />
</p>
<pre>yydebug: state 8, reducing by rule 3 (line : expression CR)
</pre>
<p class="paragraph">
ここはmycalc2.yの
<br />
</p>
<pre>line
    : expression CR
    {
        printf(&quot;&gt;&gt;%lf\n&quot;, $1);
    }
</pre>
<p class="paragraph">
にあたりますので、値を表示しています。
<br />
</p>
<pre>&gt;&gt;123.000000
</pre>
<p class="paragraph">
reduceアクションが終わりましたが、ここでルール定義をもう一度見てみるとreduceされる要素は2つです。
<br />
</p>
<pre>line : expression CR .  (3)
</pre>
<p class="paragraph">
すると状態スタックも2つ分popされますので、
<br />
</p>
<pre>reduce前：
state stack       |-&gt; [state 0], [state 3], [state 8]
------------------+--------------
token/value stack |-&gt; expression(=123), CR
↓
reduce後：
state stack       |-&gt; [state 0]
------------------+--------------
token/value stack |-&gt; line
</pre>
<p class="paragraph">
となります。これが次のデバッグログで &quot;from state 0&quot; となる理由です。
<br />
</p>
<pre>yydebug: after reduction, shifting from state 0 to state 4
</pre>
<p class="paragraph">
さて、reduce→状態スタックpop完了後の最終状態は &quot;state 0&quot; です。トークンスタックには &quot;line&quot; が載っています。すると、&quot;y.output&quot;中の
<br />
</p>
<pre>state 0
       ...
       line  goto 4
</pre>
<p class="paragraph">
この定義により、&quot;state 4&quot; に遷移します。
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 4]
------------------+--------------
token/value stack |-&gt; line
</pre>
<p class="paragraph">
さらに &quot;state 4&quot; を見てみると
<br />
</p>
<pre>state 4
        line_list : line .  (1)

        .  reduce 1
</pre>
<p class="paragraph">
としてルール1番、&quot;line_list : line&quot;を使ってreduceせよ、となっています。
<br />
</p>
<pre>yydebug: state 4, reducing by rule 1 (line_list : line)
</pre>
<p class="paragraph">
スタックの動きを見ると、reduceされる要素は1なので、次のように動きます。
<br />
</p>
<pre>reduce前：
state stack       |-&gt; [state 0], [state 4]
------------------+--------------
token/value stack |-&gt; line
↓
reduce後（途中）：
state stack       |-&gt; [state 0]
------------------+--------------
token/value stack |-&gt; line_list
</pre>
<p class="paragraph">
また &quot;state 0&quot; に戻ってくると、今度は次の定義が発動して・・・
<br />
</p>
<pre>state 0
       ...
       line_list  goto 2
</pre>
<p class="paragraph">
&quot;state 2&quot; に遷移します。
<br />
</p>
<pre>yydebug: after reduction, shifting from state 0 to state 2
↓
reduce後：
state stack       |-&gt; [state 0], [state 2]
------------------+--------------
token/value stack |-&gt; line_list
</pre>
<p class="paragraph">
&quot;state 2&quot;の定義を見ると、&quot;line_list&quot;非終端子のアクションは定義されていないので、ここで再び字句解析からのトークン待ちになります。
<br />
</p>

<h5 id="id1ecf93">トークンのスタックと、状態のスタック（&quot;1 + 2&quot;入力時)</h5>

<p class="paragraph">
ここまでの状態で、&quot;1 + 2(改行)&quot;と入力した時のデバッグログを見てみましょう。
<br />
</p>
<pre>1 + 2
</pre>

<pre class="plugin_pre">
yydebug: state 2, reading 257 (DOUBLE_LITERAL)
yydebug: state 2, shifting to state 1
yydebug: state 1, reducing by rule 4 (expression : DOUBLE_LITERAL)
yydebug: after reduction, shifting from state 2 to state 3
yydebug: state 3, reading 258 (ADD)
yydebug: state 3, shifting to state 6
yydebug: state 6, reading 257 (DOUBLE_LITERAL)
yydebug: state 6, shifting to state 9
yydebug: state 9, reducing by rule 5 (expression : expression ADD DOUBLE_LITERAL)
reduction (ADD) occurr!!
[1.000000 ADD 2.000000]
yydebug: after reduction, shifting from state 2 to state 3
yydebug: state 3, reading 262 (CR)
yydebug: state 3, shifting to state 8
yydebug: state 8, reducing by rule 3 (line : expression CR)
&gt;&gt;3.000000
yydebug: after reduction, shifting from state 2 to state 5
yydebug: state 5, reducing by rule 2 (line_list : line_list line)
yydebug: after reduction, shifting from state 0 to state 2
</pre>
<p class="paragraph">
ざっくりとした単位で動きを見ていきます。
<br />
</p>
<pre>yydebug: state 2, reading 257 (DOUBLE_LITERAL)
yydebug: state 2, shifting to state 1
yydebug: state 1, reducing by rule 4 (expression : DOUBLE_LITERAL)
yydebug: after reduction, shifting from state 2 to state 3
</pre>
<p class="paragraph">
ここまでは先ほどと一緒です。
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 2]
------------------+--------------
token/value stack |-&gt; line_list, DOUBLE_LITERAL
↓
state stack       |-&gt; [state 0], [state 2], [state 1]
------------------+--------------
token/value stack |-&gt; line_list, DOUBLE_LITERAL
</pre>
<p class="paragraph">
ここでstate 1に定義されているreduceが走り、DOUBLE_LITERALがexpressionになります。reduceされる要素は1ですので、状態スタックからも1つ分popされます。
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 2]
------------------+--------------
token/value stack |-&gt; line_list, expression
</pre>
<p class="paragraph">
&quot;state 2&quot;では &quot;expression&quot; での状態遷移が &quot;state 3&quot; へ行くよう指示されていますので、以下のスタック状態になります。
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 2], [state 3]
------------------+--------------
token/value stack |-&gt; line_list, expression
</pre>

<p class="paragraph">
では次のデバッグメッセージです。
<br />
</p>
<pre>yydebug: state 3, reading 258 (ADD)
yydebug: state 3, shifting to state 6
yydebug: state 6, reading 257 (DOUBLE_LITERAL)
yydebug: state 6, shifting to state 9
</pre>
<p class="paragraph">
まず字句解析から ADD トークンがやってきます。
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 2], [state 3]
------------------+--------------
token/value stack |-&gt; line_list, expression, ADD
</pre>
<p class="paragraph">
ここで&quot;y.output&quot;の &quot;state 3&quot; では 
<br />
</p>
<pre>state 3
       ADD  shift 6
</pre>
<p class="paragraph">
となっていますので、&quot;state 6&quot; へ遷移します。
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 2], [state 3], [state 6]
------------------+--------------
token/value stack |-&gt; line_list, expression(=1), ADD
</pre>
<p class="paragraph">
続けてDOUBLE_LITERALがやってきます。同様に &quot;state 6&quot;の定義に従い、&quot;state 9&quot;へ遷移します。
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 2], [state 3], [state 6], [state 9]
------------------+--------------
token/value stack |-&gt; line_list, expression(=1), ADD(=+), DOUBLE_LITERAL(=2)
</pre>
<p class="paragraph">
ここで &quot;state 9&quot; の次のルールに従い、reduceされます。
<br />
</p>
<pre>state 9
        expression : expression ADD DOUBLE_LITERAL .  (5)

        .  reduce 5
</pre>
<p class="paragraph">
次のデバッグログに相当します。
<br />
</p>
<pre>yydebug: state 9, reducing by rule 5 (expression : expression ADD DOUBLE_LITERAL)
reduction (ADD) occurr!!
[1.000000 ADD 2.000000]
yydebug: after reduction, shifting from state 2 to state 3
</pre>
<p class="paragraph">
ここでreduceされるトークンは3つですので、状態スタックからも3つ分popされます。
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 2]
------------------+--------------
token/value stack |-&gt; line_list, expression(3)
</pre>

<p class="paragraph">
後は前のパターン同様、&quot;state 2&quot;でexpressionが値スタックの先頭ですのでそのまま &quot;state 3&quot; に遷移し、改行が来たので &quot;state 8&quot; に遷移、reduceされて&quot;state 2&quot;へ戻ります。
<br />
</p>
<pre>yydebug: state 3, reading 262 (CR)
yydebug: state 3, shifting to state 8
yydebug: state 8, reducing by rule 3 (line : expression CR)
&gt;&gt;3.000000
yydebug: after reduction, shifting from state 2 to state 5
</pre>

<pre>state stack       |-&gt; [state 0], [state 2], [state 3]
------------------+--------------
token/value stack |-&gt; line_list, expression(3)
↓(&quot;CR&quot;入力)
state stack       |-&gt; [state 0], [state 2], [state 3]
------------------+--------------
token/value stack |-&gt; line_list, expression(3), CR
↓(&quot;state 8&quot;へ遷移)
state stack       |-&gt; [state 0], [state 2], [state 3], [state 8]
------------------+--------------
token/value stack |-&gt; line_list, expression(3), CR
↓(reduce: &quot;line : expression CR&quot;)
state stack       |-&gt; [state 0], [state 2]
------------------+--------------
token/value stack |-&gt; line_list, line
</pre>

<p class="paragraph">
前のパターンと異なるのは、ここで &quot;state 2&quot; に戻ってきたところで &quot;line_list: line_list line&quot; のreduceルールが適用され、&quot;state 5&quot; に遷移する点です。
<br />
</p>
<pre>yydebug: state 5, reducing by rule 2 (line_list : line_list line)
</pre>
<p class="paragraph">
スタックの動き：
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 2]
------------------+--------------
token/value stack |-&gt; line_list, line
↓
state stack       |-&gt; [state 0]
------------------+--------------
token/value stack |-&gt; line_list
</pre>

<p class="paragraph">
&quot;state 0&quot;で&quot;line_list&quot;非終端子の場合は、結局 &quot;state 2&quot; へ遷移します。
<br />
</p>
<pre>yydebug: after reduction, shifting from state 0 to state 2
</pre>
<p class="paragraph">
スタック：
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 2]
------------------+--------------
token/value stack |-&gt; line_list
</pre>

<p class="paragraph">
&quot;1 + 2(改行)&quot; が入力される直前と同じ状態になりました。
<br />
</p>

<h5 id="id9686a9">トークンのスタックと、状態のスタック（&quot;1 + 2 + 3&quot;入力時)</h5>

<p class="paragraph">
ここまでの状態で、いよいよ&quot;1 + 2 + 3(改行)&quot;と入力した時のデバッグログを見てみましょう。
<br />
</p>
<pre>1 + 2 + 3
</pre>

<pre class="plugin_pre">
yydebug: state 2, reading 257 (DOUBLE_LITERAL)
yydebug: state 2, shifting to state 1
yydebug: state 1, reducing by rule 4 (expression : DOUBLE_LITERAL)
yydebug: after reduction, shifting from state 2 to state 3
yydebug: state 3, reading 258 (ADD)
yydebug: state 3, shifting to state 6
yydebug: state 6, reading 257 (DOUBLE_LITERAL)
yydebug: state 6, shifting to state 9
yydebug: state 9, reducing by rule 5 (expression : expression ADD DOUBLE_LITERAL)
reduction (ADD) occurr!!
[1.000000 ADD 2.000000]
yydebug: after reduction, shifting from state 2 to state 3
yydebug: state 3, reading 258 (ADD)
yydebug: state 3, shifting to state 6
yydebug: state 6, reading 257 (DOUBLE_LITERAL)
yydebug: state 6, shifting to state 9
yydebug: state 9, reducing by rule 5 (expression : expression ADD DOUBLE_LITERAL)
reduction (ADD) occurr!!
[3.000000 ADD 3.000000]
yydebug: after reduction, shifting from state 2 to state 3
yydebug: state 3, reading 262 (CR)
yydebug: state 3, shifting to state 8
yydebug: state 8, reducing by rule 3 (line : expression CR)
&gt;&gt;6.000000
yydebug: after reduction, shifting from state 2 to state 5
yydebug: state 5, reducing by rule 2 (line_list : line_list line)
yydebug: after reduction, shifting from state 0 to state 2
</pre>

<p class="paragraph">
長いので、ざっくりとした単位でデバッグログとスタックの状態変化を追います。
<br />
</p>
<pre>yydebug: state 2, reading 257 (DOUBLE_LITERAL)
...
yydebug: state 9, reducing by rule 5 (expression : expression ADD DOUBLE_LITERAL)
reduction (ADD) occurr!!
[1.000000 ADD 2.000000]
yydebug: after reduction, shifting from state 2 to state 3
</pre>
<p class="paragraph">
ここまでは先ほどまでのパターンと同じです。スタックは次のようになっています。
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 2]
------------------+--------------
token/value stack |-&gt; line_list, expression(3)
</pre>

<p class="paragraph">
ここで続けて ADD, DOUBLE_LITERAL と入ってきますが、あとはもう一度同じパターンになります。
<br />
</p>

<p class="paragraph">
ここで、続いて ADD が入力されます。
<br />
</p>
<pre>yydebug: state 3, reading 258 (ADD)
yydebug: state 3, shifting to state 6
</pre>
<p class="paragraph">
スタックの動き：
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 2]
------------------+--------------
token/value stack |-&gt; line_list, expression(3), ADD
↓
state stack       |-&gt; [state 0], [state 2], [state 6]
------------------+--------------
token/value stack |-&gt; line_list, expression(3), ADD
</pre>

<p class="paragraph">
さらに続けて DOUBLE_LITERAL が入力されます。
<br />
</p>
<pre>yydebug: state 6, reading 257 (DOUBLE_LITERAL)
yydebug: state 6, shifting to state 9
</pre>
<p class="paragraph">
スタックの動き：
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 2], [state 6]
------------------+--------------
token/value stack |-&gt; line_list, expression(3), ADD, DOUBLE_LITERAL(3)
↓
state stack       |-&gt; [state 0], [state 2], [state 6], [state 9]
------------------+--------------
token/value stack |-&gt; line_list, expression(3), ADD, DOUBLE_LITERAL(3)
</pre>

<p class="paragraph">
ここでまたreduceです。
<br />
</p>
<pre>yydebug: state 9, reducing by rule 5 (expression : expression ADD DOUBLE_LITERAL)
reduction (ADD) occurr!!
[3.000000 ADD 3.000000]
yydebug: after reduction, shifting from state 2 to state 3
state stack       |-&gt; [state 0], [state 2], [state 6], [state 9]
------------------+--------------
token/value stack |-&gt; line_list, expression(3), ADD, DOUBLE_LITERAL(3)
↓
state stack       |-&gt; [state 0], [state 2], [state 3]
------------------+--------------
token/value stack |-&gt; line_list, expression(6)
</pre>

<p class="paragraph">
以降はこれまでのパターン同様ですので、省略します。
<br />
</p>


<h3 id="id6222e9">第２世代：かけ算・割り算対応版（不完全版）</h3>

<p class="paragraph">
とりあえずかけ算・割り算を行わせてみます。
<br />
</p>

<h4 id="id7a8f87">とにかく左から順に計算させる</h4>

<p class="paragraph">
とりあえずmycalc2.yのexpressionの構文を次のようにすれば左から右へ計算していきます。
<br />
</p>
<pre class="plugin_pre">
expression
    : DOUBLE_LITERAL
    | expression ADD DOUBLE_LITERAL
    {
        printf(&quot;reduction (ADD) occurr!!\n&quot;);
        printf(&quot;[%f ADD %f]\n&quot;, $1, $3);
        $$ = $1 + $3;
    }
    | expression SUB DOUBLE_LITERAL
    {
        printf(&quot;reduction (SUB) occurr!!\n&quot;);
        printf(&quot;[%f SUB %f]\n&quot;, $1, $3);
        $$ = $1 - $3;
    }
    | expression MUL DOUBLE_LITERAL
    {
        printf(&quot;reduction (MUL) occurr!!\n&quot;);
        printf(&quot;[%f MUL %f]\n&quot;, $1, $3);
        $$ = $1 * $3;
    }
    | expression DIV DOUBLE_LITERAL
    {
        printf(&quot;reduction (DIV) occurr!!\n&quot;);
        printf(&quot;[%f DIV %f]\n&quot;, $1, $3);
        $$ = $1 / $3;
    }
    ;
</pre>

<pre>$ ./mycalc2
1 + 2 * 3 - 3 / 2
reduction (ADD) occurr!!
[1.000000 ADD 2.000000] # 1 + 2 = 3
reduction (MUL) occurr!!
[3.000000 MUL 3.000000] # 3 * 3 = 9
reduction (SUB) occurr!!
[9.000000 SUB 3.000000] # 9 - 3 = 6
reduction (DIV) occurr!!
[6.000000 DIV 2.000000] # 6 / 2 = 3
&gt;&gt;3.000000
</pre>

<p class="paragraph">
良さそうです。
<br />
</p>

<h4 id="idb6b11e">かけ算・割り算を優先させてみる（不完全版）</h4>

<p class="paragraph">
続けて、かけ算・割り算を優先させてみます。とりあえず、MUL, DIV処理だけを抜き出してみます。
<br />
</p>
<pre class="plugin_pre">
expression
    : DOUBLE_LITERAL
    | expression ADD DOUBLE_LITERAL
    {
        printf(&quot;reduction (ADD) occurr!!\n&quot;);
        printf(&quot;[%f ADD %f]\n&quot;, $1, $3);
        $$ = $1 + $3;
    }
    | expression SUB DOUBLE_LITERAL
    {
        printf(&quot;reduction (SUB) occurr!!\n&quot;);
        printf(&quot;[%f SUB %f]\n&quot;, $1, $3);
        $$ = $1 - $3;
    }
    ;
expression_muldiv
    : DOUBLE_LITERAL
    | expression_muldiv MUL DOUBLE_LITERAL
    {
        printf(&quot;reduction (MUL) occurr!!\n&quot;);
        printf(&quot;[%f MUL %f]\n&quot;, $1, $3);
        $$ = $1 * $3;
    }
    | expression_muldiv DIV DOUBLE_LITERAL
    {
        printf(&quot;reduction (DIV) occurr!!\n&quot;);
        printf(&quot;[%f DIV %f]\n&quot;, $1, $3);
        $$ = $1 / $3;
    }
    ;
</pre>
<p class="paragraph">
ところが、&quot;expression_muldivは型が指定されてない&quot;旨のエラーが出てしまいます。
<br />
</p>
<pre>$ yacc -dv mycalc2.y
yacc: e - line 44 of &quot;mycalc2.y&quot;, $1 (expression_muldiv) is untyped
</pre>
<p class="paragraph">
というわけで、&quot;%type&quot;にexpression_muldivを追加します。
<br />
</p>
<pre>%type &lt;double_value&gt; expression
↓
%type &lt;double_value&gt; expression expression_muldiv
</pre>
<p class="paragraph">
すると今度は、&quot;3つのルールが使われないままですよ&quot;となります。確かにexpression_muldivは何処にも組み込んでなかったです。
<br />
</p>
<pre>$ yacc -dv mycalc2.y
yacc: 3 rules never reduced
</pre>

<p class="paragraph">
というわけで、expressionに組み込んでみます。どうせexpression_muldiv : DOUBLE_LITERALを設定してますので、
<br />
</p>
<pre>expression
   : DOUBLE_LITERAL
</pre>
<p class="paragraph">
これを置き換えちゃいましょう。
<br />
</p>
<pre>expression
   : expression_muldiv
</pre>
<pre class="plugin_pre">
$ yacc -dv mycalc2.y
$ gcc -o mycalc2 y.tab.c lex.yy.c
$ ./mycalc2
2 * 3 + 2
reduction (MUL) occurr!!
[2.000000 MUL 3.000000]
reduction (ADD) occurr!!
[6.000000 ADD 2.000000]
&gt;&gt;8.000000
4 / 2 -1
reduction (DIV) occurr!!
[4.000000 DIV 2.000000]
reduction (SUB) occurr!!
[2.000000 SUB 1.000000]
&gt;&gt;1.000000
1 + 2 * 3
reduction (ADD) occurr!!
[1.000000 ADD 2.000000]
parser error near *
Error ! Error ! Error !
</pre>
<p class="paragraph">
このように、かけ算・割り算を &quot;+&quot;/&quot;-&quot; の次に持ってくると、未定義の構文の為エラーになります。
<br />
</p>

<p class="paragraph">
ここまでくれば、本に載っている電卓プログラムまであと一歩です。
<br />
</p>

<h3 id="idabf79c">第３世代：かけ算・割り算対応の完全版</h3>

<p class="paragraph">
あとはexpression中のDOUBLE_LITERALを、expression_muldivに返ればOKです。
<br />
</p>
<pre class="plugin_pre">
expression
    : expression_muldiv
    | expression ADD expression_muldiv
    {
        printf(&quot;reduction (ADD) occurr!!\n&quot;);
        printf(&quot;[%f ADD %f]\n&quot;, $1, $3);
        $$ = $1 + $3;
    }
    | expression SUB expression_muldiv
    {
        printf(&quot;reduction (SUB) occurr!!\n&quot;);
        printf(&quot;[%f SUB %f]\n&quot;, $1, $3);
        $$ = $1 - $3;
    }
    ;
</pre>

<pre class="plugin_pre">
$ yacc -dv mycalc2.y
$ gcc -o mycalc2 y.tab.c lex.yy.c
$ ./mycalc2
2 * 3 + 2
reduction (MUL) occurr!!
[2.000000 MUL 3.000000]
reduction (ADD) occurr!!
[6.000000 ADD 2.000000]
&gt;&gt;8.000000
1 + 2 * 3
reduction (MUL) occurr!!
[2.000000 MUL 3.000000]
reduction (ADD) occurr!!
[1.000000 ADD 6.000000]
&gt;&gt;7.000000
</pre>

<p class="paragraph">
この時点で、足し算・引き算・かけ算・割り算の電卓機能としては本と同じものになりました。expression_muldivをtermに置換して、あとterm中のDOUBLE_LITERALをprimary_expressionにまとめれば本の &quot;mycalc.y&quot; と同じになります。
<br />
</p>

<h4 id="id0de2ed">トークンスタック・状態スタック詳解</h4>

<p class="paragraph">
では最後に優先順位付けされた時のスタック挙動を確認してみます。まずデバッグログの全貌：
<br />
</p>
<pre class="plugin_pre">
$ YYDEBUG=1 ./mycalc2
1 + 2 * 3 + 4
yydebug: state 0, reading 257 (DOUBLE_LITERAL)
yydebug: state 0, shifting to state 1
yydebug: state 1, reducing by rule 7 (expression_muldiv : DOUBLE_LITERAL)
yydebug: after reduction, shifting from state 0 to state 4
yydebug: state 4, reading 258 (ADD)
yydebug: state 4, reducing by rule 4 (expression : expression_muldiv)
yydebug: after reduction, shifting from state 0 to state 3
yydebug: state 3, shifting to state 7
yydebug: state 7, reading 257 (DOUBLE_LITERAL)
yydebug: state 7, shifting to state 1
yydebug: state 1, reducing by rule 7 (expression_muldiv : DOUBLE_LITERAL)
yydebug: after reduction, shifting from state 7 to state 12
yydebug: state 12, reading 260 (MUL)
yydebug: state 12, shifting to state 10
yydebug: state 10, reading 257 (DOUBLE_LITERAL)
yydebug: state 10, shifting to state 14
yydebug: state 14, reducing by rule 8 (expression_muldiv : expression_muldiv MUL DOUBLE_LITERAL)
reduction (MUL) occurr!!
[2.000000 MUL 3.000000]
yydebug: after reduction, shifting from state 7 to state 12
yydebug: state 12, reading 258 (ADD)
yydebug: state 12, reducing by rule 5 (expression : expression ADD expression_muldiv)
reduction (ADD) occurr!!
[1.000000 ADD 6.000000]
yydebug: after reduction, shifting from state 0 to state 3
yydebug: state 3, shifting to state 7
yydebug: state 7, reading 257 (DOUBLE_LITERAL)
yydebug: state 7, shifting to state 1
yydebug: state 1, reducing by rule 7 (expression_muldiv : DOUBLE_LITERAL)
yydebug: after reduction, shifting from state 7 to state 12
yydebug: state 12, reading 262 (CR)
yydebug: state 12, reducing by rule 5 (expression : expression ADD expression_muldiv)
reduction (ADD) occurr!!
[7.000000 ADD 4.000000]
yydebug: after reduction, shifting from state 0 to state 3
yydebug: state 3, shifting to state 9
yydebug: state 9, reducing by rule 3 (line : expression CR)
&gt;&gt;11.000000
yydebug: after reduction, shifting from state 0 to state 5
yydebug: state 5, reducing by rule 1 (line_list : line)
yydebug: after reduction, shifting from state 0 to state 2
</pre>

<p class="paragraph">
順に追っていきます。&quot;y.output&quot;中の定義については、必要最低記載します。
<br />
</p>
<pre>yydebug: state 0, reading 257 (DOUBLE_LITERAL)
yydebug: state 0, shifting to state 1
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 1]
------------------+--------------
token/value stack |-&gt; DOUBLE_LITERAL
</pre>

<pre>yydebug: state 1, reducing by rule 7 (expression_muldiv : DOUBLE_LITERAL)
yydebug: after reduction, shifting from state 0 to state 4
</pre>
<p class="paragraph">
↓ reduce発生, &quot;state 0&quot; with expression_muldiv は &quot;goto 4&quot;と定義。
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 4]
------------------+--------------
token/value stack |-&gt; expression_muldiv(=1)
</pre>

<pre>yydebug: state 4, reading 258 (ADD)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 4]
------------------+--------------
token/value stack |-&gt; expression_muldiv(=1), ADD
</pre>

<pre>yydebug: state 4, reducing by rule 4 (expression : expression_muldiv)
</pre>
<p class="paragraph">
↓ reduce発生
<br />
</p>
<pre>state stack       |-&gt; [state 0]
------------------+--------------
token/value stack |-&gt; expression(=1), ADD
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: after reduction, shifting from state 0 to state 3
state stack       |-&gt; [state 0], [state 3]
------------------+--------------
token/value stack |-&gt; expression(=1), ADD
</pre>
<p class="paragraph">
↓さらに&quot;state 3&quot; で ADD だと &quot;state 7&quot; へ遷移と定義。
<br />
</p>
<pre>yydebug: state 3, shifting to state 7
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7]
------------------+--------------
token/value stack |-&gt; expression(=1), ADD
</pre>

<pre>yydebug: state 7, reading 257 (DOUBLE_LITERAL)
yydebug: state 7, shifting to state 1
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7], [state 1]
------------------+--------------
token/value stack |-&gt; expression(=1), ADD, DOUBLE_LITERAL(=2)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: state 1, reducing by rule 7 (expression_muldiv : DOUBLE_LITERAL)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7]
------------------+--------------
token/value stack |-&gt; expression(=1), ADD, expression_muldiv(=2)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: after reduction, shifting from state 7 to state 12
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7], [state 12]
------------------+--------------
token/value stack |-&gt; expression(=1), ADD, expression_muldiv(=2)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: state 12, reading 260 (MUL)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7], [state 12]
------------------+--------------
token/value stack |-&gt; expression(=1), ADD, expression_muldiv(=2), MUL
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: state 12, shifting to state 10
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7], [state 12], [state 10]
------------------+--------------
token/value stack |-&gt; expression(=1), ADD, expression_muldiv(=2), MUL
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: state 10, reading 257 (DOUBLE_LITERAL)
yydebug: state 10, shifting to state 14
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7], [state 12], [state 10], [state 14]
------------------+--------------
token/value stack |-&gt; expression(=1), ADD, expression_muldiv(=2), MUL, DOUBLE_LITERAL(3)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: state 14, reducing by rule 8 (expression_muldiv : expression_muldiv MUL DOUBLE_LITERAL)
reduction (MUL) occurr!!
[2.000000 MUL 3.000000]
</pre>
<p class="paragraph">
↓reduce, ３つ分状態スタックからpop
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7]
------------------+--------------
token/value stack |-&gt; expression(=1), ADD, expression_muldiv(=6)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: after reduction, shifting from state 7 to state 12
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7], [state 12]
------------------+--------------
token/value stack |-&gt; expression(=1), ADD, expression_muldiv(=6)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: state 12, reading 258 (ADD)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7], [state 12]
------------------+--------------
token/value stack |-&gt; expression(=1), ADD, expression_muldiv(=6), ADD
</pre>
<p class="paragraph">
↓
<br />
yydebug: state 12, reducing by rule 5 (expression : expression ADD expression_muldiv)
<br />
reduction (ADD) occurr!!
<br />
[1.000000 ADD 6.000000]
<br />
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0]
------------------+--------------
token/value stack |-&gt; expression(=7), ADD
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: after reduction, shifting from state 0 to state 3
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3]
------------------+--------------
token/value stack |-&gt; expression(=7), ADD
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: state 3, shifting to state 7
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7]
------------------+--------------
token/value stack |-&gt; expression(=7), ADD
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: state 7, reading 257 (DOUBLE_LITERAL)
yydebug: state 7, shifting to state 1
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7], [state 1]
------------------+--------------
token/value stack |-&gt; expression(=7), ADD, DOUBE_LITERAL(=4)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: state 1, reducing by rule 7 (expression_muldiv : DOUBLE_LITERAL)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7]
------------------+--------------
token/value stack |-&gt; expression(=7), ADD, expression_muldiv(=4)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: after reduction, shifting from state 7 to state 12
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7], [state 12]
------------------+--------------
token/value stack |-&gt; expression(=7), ADD, expression_muldiv(=4)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: state 12, reading 262 (CR)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7], [state 12]
------------------+--------------
token/value stack |-&gt; expression(=7), ADD, expression_muldiv(=4), CR
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: state 12, reducing by rule 5 (expression : expression ADD expression_muldiv)
reduction (ADD) occurr!!
[7.000000 ADD 4.000000]
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0]
------------------+--------------
token/value stack |-&gt; expression(=11), CR
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: after reduction, shifting from state 0 to state 3
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3]
------------------+--------------
token/value stack |-&gt; expression(=11), CR
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: state 3, shifting to state 9
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 9]
------------------+--------------
token/value stack |-&gt; expression(=11), CR
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: state 9, reducing by rule 3 (line : expression CR)
&gt;&gt;11.000000
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0]
------------------+--------------
token/value stack |-&gt; line
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: after reduction, shifting from state 0 to state 5
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 5]
------------------+--------------
token/value stack |-&gt; line
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: state 5, reducing by rule 1 (line_list : line)
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0]
------------------+--------------
token/value stack |-&gt; line_list
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: after reduction, shifting from state 0 to state 2
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 2]
------------------+--------------
token/value stack |-&gt; line_list
</pre>

<h5 id="id498a41">少し気になったところ</h5>

<pre class="plugin_pre">
yydebug: state 4, reducing by rule 4 (expression : expression_muldiv)
yydebug: after reduction, shifting from state 0 to state 3
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
yydebug: state 3, shifting to state 7
...
yydebug: state 12, reducing by rule 5 (expression : expression ADD expression_muldiv)
reduction (ADD) occurr!!
[1.000000 ADD 6.000000]
yydebug: after reduction, shifting from state 0 to state 3
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
yydebug: state 3, shifting to state 7
...
yydebug: state 12, reducing by rule 5 (expression : expression ADD expression_muldiv)
reduction (ADD) occurr!!
[7.000000 ADD 4.000000]
yydebug: after reduction, shifting from state 0 to state 3
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
yydebug: state 3, shifting to state 9
...
</pre>

<p class="paragraph">
この３箇所、reduceして状態遷移した後に、さらにもう一度状態遷移している。このパターンは初めてみた。
<br />
三つ目のスタック挙動を見てみる。
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3], [state 7], [state 12]
------------------+--------------
token/value stack |-&gt; expression(=7), ADD, expression_muldiv(=4), CR
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>yydebug: state 12, reducing by rule 5 (expression : expression ADD expression_muldiv)
reduction (ADD) occurr!!
[7.000000 ADD 4.000000]
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0]
------------------+--------------
token/value stack |-&gt; expression(=11), CR
</pre>

<p class="paragraph">
ここまでは特に気にならないのだけれど、次：
<br />
</p>
<pre>yydebug: after reduction, shifting from state 0 to state 3
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>state stack       |-&gt; [state 0], [state 3]
------------------+--------------
token/value stack |-&gt; expression(=11), CR
</pre>
<p class="paragraph">
これが分からない・・・。&quot;state 0&quot; で &quot;state 3&quot;に遷移する定義は、
<br />
</p>
<pre>state 0
       ...
       expression  goto 3
</pre>
<p class="paragraph">
これだけなのだけど、今値のスタックに積まれている末尾要素は &quot;CR&quot; なのだが・・・。
<br />
それとも、CRは終端子なので無視して、次が非終端子の&quot;expression&quot;だから引っ掛かったのだろうか。
<br />
</p>

<h3 id="id03004b">まとめと感想</h3>

<p class="paragraph">
YYDEBUG有効化の方法、およびYYDEBUGによるデバッグ出力と、yacc内部の値・状態のスタック挙動を突き合わせた事で、yacc構文解析の挙動や仕組みを理解する事が出来た。
<br />
</p>

<p class="paragraph">
実際は y.tab.c に生成されたコードまで一通り目を通しているが、書き出すと長くなるので省略した。
<br />
</p>

<p class="paragraph">
感想としては、状態までスタックに保存されていて、しかもreduceされるトークンの数に合わせて状態スタックからもpopされる事に気づくまでが大変だった。
<br />
</p>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/498<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2001 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" target="_blank" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>