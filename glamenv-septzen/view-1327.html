<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Java/文字コードメモ5, Stringコンストラクタの内部実装, ISO-8859-1とUS-ASCIIの違い, CoderResultのパフォーマンス問題 - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">Java/文字コードメモ5, Stringコンストラクタの内部実装, ISO-8859-1とUS-ASCIIの違い, CoderResultのパフォーマンス問題</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2014-11-30 21:38:10 &nbsp; / &nbsp; last updated at: 2014-11-30 21:46:58<br>
カテゴリ: <a href="category-11.html">Java</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-1317.html" title="Java/文字コードメモ4">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-1208.html" title="Java/標準入力, コンソール入力の読み取り(System.in, System.console(), java.io.Console)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-457.html" title="Java">Java</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
<a href="./view-1317.html" >Java/文字コードメモ4</a> に続いたメモ5.
<br />
</p>

<h3 id="id750446">Stringクラスで文字列を保持している実体は何か？ → char[]</h3>

<p class="paragraph">
Oracle JDK 7(jdk7u25)のJDKソースを確認してみる。
<br />
</p>
<pre class="plugin_pre">
public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
</pre>

<p class="paragraph">
→Stringクラスのコンストラクタは、いずれも最終的にvalueというchar配列に値を設定してる。
<br />
</p>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> String (Java) class – Under the hood | Play with Java<ul><li> <a class="externallink" href="http://shyamalmadura.wordpress.com/2013/11/01/string-java-class-under-the-hood/" target="_blank">http://shyamalmadura.wordpress.com/2013/11/01/string-java-class-under-the-hood/</a></li></ul></li>
<li> String Memory Internals | Javalobby<ul><li> <a class="externallink" href="http://java.dzone.com/articles/string-memory-internals" target="_blank">http://java.dzone.com/articles/string-memory-internals</a></li></ul></li>
<li> What is the Java&#039;s internal represention for String? Modified UTF-8? UTF-16? - Stack Overflow<ul><li> <a class="externallink" href="http://stackoverflow.com/questions/9699071/what-is-the-javas-internal-represention-for-string-modified-utf-8-utf-16" target="_blank">http://stackoverflow.com/questions/9699071/what-is-the-javas-internal-represention-for-string-modified-utf-8-utf-16</a></li></ul></li></ul>

<h3 id="idd5e53d">byte[]からStringを生成するコンストラクタは何をしているのか？</h3>

<p class="paragraph">
&quot;String(byte[], int, int, Charset)&quot;のコンストラクタから追ってみる。
<br />
JDK7u25のソースを参考にしている。
<br />
</p>
<pre class="plugin_pre">
    public String(byte bytes[], int offset, int length, Charset charset) {
        // (...)
        this.value =  StringCoding.decode(charset, bytes, offset, length);
    }
</pre>
<p class="paragraph">
StringCodingはpackage privateスコープのクラスのため、未公開。JDKのソースで確認する。細かいエラー処理とかは思い切って省略すると以下の流れになっている。
<br />
</p>
<pre class="plugin_pre">
    static char[] decode(Charset cs, byte[] ba, int off, int len) {
        // Charset#newDecoder()から、CharsetDecoderインスタンスを取得
        CharsetDecoder cd = cs.newDecoder();
        // 1バイト辺りの最大文字数とlenより、最大の文字数を計算
        int en = scale(len, cd.maxCharsPerByte());
        // 最大の文字数でchar配列を作成
        char[] ca = new char[en];

        // CharsetDecoderの準備
        cd.onMalformedInput(CodingErrorAction.REPLACE)
          .onUnmappableCharacter(CodingErrorAction.REPLACE)
          .reset();

        if (cd instanceof ArrayDecoder) {
            // CharsetDecoderがsun.nio.cs.ArrayDecoderの派生クラスならそのままdecode()メソッドを呼ぶ。

            int clen = ((ArrayDecoder)cd).decode(ba, off, len, ca);
            return safeTrim(ca, clen, cs, isTrusted);

        } else {
            // sun.nio.cs.ArrayDecoderの派生クラスでなければ、
            // ByteBufferとCharBufferにラップしてdecode()メソッドを呼ぶ。

            ByteBuffer bb = ByteBuffer.wrap(ba, off, len);
            CharBuffer cb = CharBuffer.wrap(ca);
            try {
                CoderResult cr = cd.decode(bb, cb, true);
                if (!cr.isUnderflow())
                    cr.throwException();
                cr = cd.flush(cb);
                if (!cr.isUnderflow())
                    cr.throwException();
            } catch (CharacterCodingException x) {
                // Substitution is always enabled,
                // so this shouldn&#039;t happen
                throw new Error(x);
            }
            return safeTrim(ca, cb.position(), cs, isTrusted);
        }
    }
</pre>

<p class="paragraph">
CharsetDecoderの実装については後述するが、JDKで提供されているものについては &quot;sun.nio.cs&quot; パッケージ以下で実装されている。
<br />
インターフェイスとしては java.nio.charset.CharsetDecoder abstract class として公開されている。
<br />
</p>

<h3 id="id3bdacc">Java 7u6 で行われたString.substring()に関するチューニングとは？</h3>

<p class="paragraph">
それまでのJavaでは、String.substring()の結果は、元のStringインスタンスの&quot;char[] value&quot;をそのまま参照し、beginとendだけを変更したインスタンスを返していた。
<br />
その場合、巨大なテキストデータから文字列を切り出す処理を考えると、元のテキストデータが不要になっても、切りだされたStringインスタンスが巨大な&quot;char[] value&quot;を参照しつづけ、GCで回収されない。
<br />
これによるメモリリークが問題視されたらしく、Java 7u6 では、元の&quot;char[] value&quot;から必要な範囲だけをコピーして新規に作成する形式に変更された。これにより、不要になった元の巨大なテキストデータが適切にGCで回収されるようになる。
<br />
</p>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> Changes to String in Java 7u6 - Java Performance Tuning Guide<ul><li> <a class="externallink" href="http://java-performance.info/changes-to-string-java-1-7-0_06/" target="_blank">http://java-performance.info/changes-to-string-java-1-7-0_06/</a></li></ul></li>
<li> Oracle Tunes Java&#039;s Internal String Representation<ul><li> <a class="externallink" href="http://www.infoq.com/news/2013/12/Oracle-Tunes-Java-String" target="_blank">http://www.infoq.com/news/2013/12/Oracle-Tunes-Java-String</a></li></ul></li></ul>

<p class="paragraph">
実際にJDKのソースを確認してみる。
<br />
</p>

<p class="paragraph">
JDK6のString.substring()の流れを確認する：
<br />
<a class="externallink" href="http://grepcode.com/file_/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/String.java/?v=source" target="_blank">http://grepcode.com/file_/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/String.java/?v=source</a>
<br />
</p>
<pre class="plugin_pre">
    public String substring(int beginIndex, int endIndex) {
        // (...)
        return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this :
            new String(offset + beginIndex, endIndex - beginIndex, value);
    }
</pre>
<p class="paragraph">
→ String(int, int, char[]) のコンストラクタで生成したのを返している。このコンストラクタは以下のようにpackage privateとなっており、外部には公開されていない。
<br />
</p>
<pre class="plugin_pre">
    String(int offset, int count, char value[]) {
        this.value = value;
        this.offset = offset;
        this.count = count;
    }
</pre>
<p class="paragraph">
このコンストラクタでは、確かに、元の&quot;char[] value&quot;をそのまま引き継ぎ、offsetとcountだけを更新している。このため、元のStringが巨大なテキストデータだった場合、その&quot;char[] value&quot;で本来は使われない領域が参照され続ける。
<br />
これにより、元の巨大なテキストデータが不要になっても、substring()されたインスタンスの方で参照が残っているため、不要なデータがGCに回収されない。(substring()された新しいStringインスタンスが不要になってようやくGC対象になる。)
<br />
</p>

<p class="paragraph">
一方、JDK 7u40 のソースを確認してみる。
<br />
<a class="externallink" href="http://grepcode.com/file_/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/lang/String.java/?v=source" target="_blank">http://grepcode.com/file_/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/lang/String.java/?v=source</a>
<br />
</p>
<pre class="plugin_pre">
    public String substring(int beginIndex, int endIndex) {
        // (...)
        return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this
                : new String(value, beginIndex, subLen);
    }
</pre>
<p class="paragraph">
→JDK6とは異なり、String(char[], int, int)のコンストラクタを呼んでいる。
<br />
</p>
<pre class="plugin_pre">
    public String(char value[], int offset, int count) {
        // (...)
        this.value = Arrays.copyOfRange(value, offset, offset+count);
    }
</pre>
<p class="paragraph">
新しく配列をコピーして作ったのを、&quot;this.value&quot;に設定している。
<br />
</p>

<h3 id="iddb03de">new String(byte bytes[], int offset, int length)はどうやってCharsetを決定しているのか？</h3>

<p class="paragraph">
JDK7の場合：
<br />
</p>
<ol><li> Javaのシステムプロパティ：&quot;file.encoding&quot; で指定された名前をデフォルトのCharsetとして使ってみる。</li>
<li> ↑で無効なCharset名だったら、ISO-8859-1を仮定して使ってみる。</li></ol>

<p class="paragraph">
Oracle JDK 7(jdk7u25)のJDKソースを確認してみる。
<br />
java.lang.Stringのコンストラクタ：
<br />
</p>
<pre class="plugin_pre">
    public String(byte bytes[], int offset, int length) {
        checkBounds(bytes, offset, length);
        this.value = StringCoding.decode(bytes, offset, length);
    }
</pre>

<p class="paragraph">
→ StringCodingはpackageスコープのクラスのため、未公開。JDKのソースを確認する。
<br />
</p>

<p class="paragraph">
java.lang.StringCoding:
<br />
</p>
<pre class="plugin_pre">
class StringCoding {

    // (...)

    static char[] decode(byte[] ba, int off, int len) {
        String csn = Charset.defaultCharset().name();
        try {
            // use charset name decode() variant which provides caching.
            return decode(csn, ba, off, len);
        } catch (UnsupportedEncodingException x) {
            warnUnsupportedCharset(csn);
        }
        try {
            return decode(&quot;ISO-8859-1&quot;, ba, off, len);
        } catch (UnsupportedEncodingException x) {
            // If this code is hit during VM initialization, MessageUtils is
            // the only way we will be able to get any kind of error message.
            MessageUtils.err(&quot;ISO-8859-1 charset not available: &quot;
                             + x.toString());
            // If we can not find ISO-8859-1 (a required encoding) then things
            // are seriously wrong with the installation.
            System.exit(1);
            return null;
        }
    }
</pre>

<p class="paragraph">
→最初にCharset.defaultCharset()でCharset名を取得し、StringCoding.decode()でデコードを試みてる。それに失敗したら、&quot;ISO-8859-1&quot;でデコードできないか試してみて、ソレでも駄目ならISO-8859-1でエラーになるというのはシステムレベルでおかしいので、JVMを終了(System.exit(1))してる。
<br />
</p>

<p class="paragraph">
Charset.defaultCharset()はどこからCharset名を取り出してるのか？これも、Charset.defaultCharset()の実装をJDKのソースで確認する。
<br />
</p>
<pre class="plugin_pre">
    public static Charset defaultCharset() {
        if (defaultCharset == null) {
            synchronized (Charset.class) {
                String csn = AccessController.doPrivileged(
                    new GetPropertyAction(&quot;file.encoding&quot;));
                Charset cs = lookup(csn);
                if (cs != null)
                    defaultCharset = cs;
                else
                    defaultCharset = forName(&quot;UTF-8&quot;);
            }
        }
        return defaultCharset;
    }
</pre>
<p class="paragraph">
→ &quot;file.encoding&quot; システムプロパティから取得している。&quot;file.encoding&quot;の値がおかしかったら、&quot;UTF-8&quot;を試してる。
<br />
</p>


<h3 id="id5bdda3">&quot;ISO-8859-1&quot;と、&quot;US-ASCII&quot;は何が違うのか？</h3>

<p class="paragraph">
US-ASCIIは7bitの範囲の文字までしかマッピングしていないことから、US-ASCIIはISO-8859-1のサブセットと考えることができる。
<br />
</p>
<ul><li> Running EncodingSampler.java with ISO-8859-1 and US-ASCII<ul><li> <a class="externallink" href="http://www.herongyang.com/JDK/charset-Character-Encoding-Test-ISO-8859-1-US-ASCII.html" target="_blank">http://www.herongyang.com/JDK/charset-Character-Encoding-Test-ISO-8859-1-US-ASCII.html</a></li></ul></li></ul>

<h3 id="id03b184">Charsetの実装コードはどこにあるのか？</h3>

<p class="paragraph">
OpenJDK7だと、sun.nio.cs パッケージ以下にあるぽい。
<br />
</p>
<ul><li> ISO-8859-1の実装：<ul><li> <a class="externallink" href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/sun/nio/cs/ISO_8859_1.java?av=f" target="_blank">http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/sun/nio/cs/ISO_8859_1.java?av=f</a></li>
<li> <a class="externallink" href="http://code.metager.de/source/xref/openjdk/jdk7/jdk/src/share/classes/sun/nio/cs/ISO_8859_1.java" target="_blank">http://code.metager.de/source/xref/openjdk/jdk7/jdk/src/share/classes/sun/nio/cs/ISO_8859_1.java</a></li></ul></li>
<li> US-ASCIIの実装：<ul><li> <a class="externallink" href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/sun/nio/cs/US_ASCII.java?av=f" target="_blank">http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/sun/nio/cs/US_ASCII.java?av=f</a></li>
<li> <a class="externallink" href="http://code.metager.de/source/xref/openjdk/jdk7/jdk/src/share/classes/sun/nio/cs/US_ASCII.java" target="_blank">http://code.metager.de/source/xref/openjdk/jdk7/jdk/src/share/classes/sun/nio/cs/US_ASCII.java</a></li></ul></li></ul>

<h3 id="id60e7fe">java.nio.charset.CoderResult クラスでのスレッド間ロックについての再考</h3>

<p class="paragraph">
<a href="./view-1317.html" >Java/文字コードメモ4</a> で軽く触れた、&quot;java.nio.charset.CoderResult&quot; について再考する。
<br />
</p>
<ul><li> Thread blocking on java.nio.charset.CoderResult | Oracle Community<ul><li> <a class="externallink" href="https://community.oracle.com/thread/1145918?start=0&amp;tstart=0" target="_blank">https://community.oracle.com/thread/1145918?start=0&amp;tstart=0</a></li></ul></li></ul>

<p class="paragraph">
java.nio.charset.CoderReusltクラスは、java.nio.charset.CharsetDecoder#decode() や java.nio.charset.CharsetEncoder#encode() などの処理結果を表現するクラスになっている。
<br />
byte配列をdecodeする、あるいはUnicode文字の配列をbyte配列にencodeする処理はどうしても状態遷移が伴う処理であり、入力バッファ・出力バッファの長さや中途半端なデータ、対応していないデータなど様々な異常処理が発生し得る。
<br />
そのため、CharsetDecoder/CharsetEncoderの実装は、内部でCoderResultに適切な異常状態の詳細を設定して、呼び出し元に返す仕組みになっている。
<br />
<a class="externallink" href="http://docs.oracle.com/javase/jp/7/api/java/nio/charset/CoderResult.html" target="_blank">http://docs.oracle.com/javase/jp/7/api/java/nio/charset/CoderResult.html</a>
<br />
</p>

<p class="paragraph">
「長さが中途半端」なパターンが頻用されるのか、専用のstatic factoryが用意されている。
<br />
</p>
<ul><li> CoderResult#malformedForLength(int length) : 指定された長さの不正入力エラーを表した一意のオブジェクトを返す</li>
<li> CoderResult#unmappableForLength(int length) : 指定された長さのマップ不可文字エラーを表した一意のオブジェクトを返す</li></ul>

<p class="paragraph">
このstatic factoryが、内部で length に対応するCoderResultのインスタンスをstaticにキャッシュしている。これが CoderResultクラスに対するsynchronizedブロックでスレッドセーフティを確保している。
<br />
つまりこれが、マルチスレッド（正確にはClassLoaderに対してとなるが、システムクラスなので事実上システム全体）間でのロックにつながるsynchronizedブロックになる。
<br />
</p>

<p class="paragraph">
以下が上記２つのstatic factoryのJDK7u25におけるソース。
<br />
</p>
<pre class="plugin_pre">
    public static CoderResult malformedForLength(int length) {
        return malformedCache.get(length);
    }
    public static CoderResult unmappableForLength(int length) {
        return unmappableCache.get(length);
    }
</pre>
<p class="paragraph">
&quot;malformedCache&quot;, &quot;unmappableCache&quot;ともにCoderResultのstaticメンバ。
<br />
</p>
<pre class="plugin_pre">
    private static Cache malformedCache
        = new Cache() {
                public CoderResult create(int len) {
                    return new CoderResult(CR_MALFORMED, len);
                }};

    private static Cache unmappableCache
        = new Cache() {
                public CoderResult create(int len) {
                    return new CoderResult(CR_UNMAPPABLE, len);
                }};
</pre>
<p class="paragraph">
&quot;Cache&quot;はCoderResultクラス内のインナークラスとして宣言されており、&quot;create(int len)&quot;をabstractとしている。
<br />
</p>
<pre class="plugin_pre">

    private static abstract class Cache {

        private Map&lt;Integer,WeakReference&lt;CoderResult&gt;&gt; cache = null;

        protected abstract CoderResult create(int len);

        private synchronized CoderResult get(int len) {
            if (len &lt;= 0)
                throw new IllegalArgumentException(&quot;Non-positive length&quot;);
            Integer k = new Integer(len);
            WeakReference&lt;CoderResult&gt; w;
            CoderResult e = null;
            if (cache == null) {
                cache = new HashMap&lt;Integer,WeakReference&lt;CoderResult&gt;&gt;();
            } else if ((w = cache.get(k)) != null) {
                e = w.get();
            }
            if (e == null) {
                e = create(len);
                cache.put(k, new WeakReference&lt;CoderResult&gt;(e));
            }
            return e;
        }

    }
</pre>
<p class="paragraph">
これにより、CR_MALFORMED/CR_UNMAPPABLEにそれぞれ対応する、長さ毎のCoderResultインスタンスをstaticかつスレッドセーフにキャッシュしている。
<br />
</p>

<p class="paragraph">
確かにクラスのstaticメンバに対するsynchronizedなのでマルチスレッド間でグローバルにロックされてしまう。しかし、これがチューニングレベルで影響してしまうのはどのような時か？
<br />
</p>

<p class="paragraph">
まず、これらのstatic factoryは長さが不正であったり文字とのマッピングに失敗している状態を表している。つまり、異常処理で呼ばれるのを意図している。
<br />
したがって、大抵の時間が正常処理に費やされる一般的なシステムであれば、これらのstatic factoryが呼ばれることはほとんど無いと考えられ、チューニングレベルで影響することも無いと考えられる。
<br />
</p>

<p class="paragraph">
チューニングに影響するレベルとしては、システムが想定している文字コードとは異なるデータを大量に扱う状態が考えられる。
<br />
ただその場合、当然decode/encodeが正常に終了していないため、結果として文字化けなどが大量発生してすぐに異常に気づくだろう。
<br />
あるいはそもそもどんな文字コードがくるか分からず、アスキー範囲だけを文字として扱いたい場合に、UTF-8などdecode/encodeで状態遷移が必要なCharsetを使ってしまっているケースが考えられる。
<br />
バイナリデータを無理やり、アスキー範囲だけでも文字として扱う際に、UTF-8を使ってStringにすると、UTF-8に従わないbyte[]部分でunmappableが発生する可能性がある。
<br />
つまり定常的に文字コード処理の異常が発生している状態であり、そのようなユースケースだと体感レベルでパフォーマンスに影響してしまうかもしれない。
<br />
</p>

<p class="paragraph">
解決策としては、システムの特性によっていくつか考えられる。
<br />
</p>
<ul><li> バイナリデータを無理やり、アスキー範囲だけでも文字として扱いたい場合<ul><li> UTF-8などではなく、ISO-8859-1を使う。特にISO-8859-1のCharsetDecoder実装(byte[] -&gt; char[]変換)では、CoderResult.malformedForLength()/unmappableForLength()が一切呼ばれない。<ul><li> <a class="externallink" href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/sun/nio/cs/ISO_8859_1.java?av=f" target="_blank">http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/sun/nio/cs/ISO_8859_1.java?av=f</a></li>
<li> ただし、CharsetEncoderの実装については、u00FF 以上の文字についてはサロゲートペアの処理を経由し、CoderResult.malformedForLength()/unmappableForLength()が呼ばれる可能性がある。</li>
<li> 上記については、元々ISO-8859-1でdecode()したStringであれば、そのchar[]の中身についてもu0000 - u00FFまでの範囲に収まってるはずなので、心配要らないかも・・・？</li></ul></li></ul></li>
<li> 諸事情で文字コードを変更できない場合<ul><li> 対応策不明。</li>
<li> 原理的にはCoderResultのクラスを改変する他ない。<ul><li> システムクラスに属してしまうため、ClassLoader#loadClass()でゴニョゴニョする難易度が半端ない。</li>
<li> agentの仕組みを使って、CoderResultクラスのロードが発生するタイミングで、synchronized cacheでない実装に改変した独自のCoderResultに挿げ替える仕組みは出来るかもしれないが、システム全体への影響が発生してしまうため、影響度が大きい。</li></ul></li>
<li> CoderResult.malformedForLength()/unmappableForLength()を呼ばない、独自のCharsetProviderを実装するのはアリかもしれない・・・。</li></ul></li></ul>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-1317.html" title="Java/文字コードメモ4">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-1208.html" title="Java/標準入力, コンソール入力の読み取り(System.in, System.console(), java.io.Console)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-457.html" title="Java">Up</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-457.html" title="Java">Java</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/1327<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2001 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" target="_blank" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>