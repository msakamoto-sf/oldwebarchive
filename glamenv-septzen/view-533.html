<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>C言語系/ポインタ・配列の定義と宣言メモ1 - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">C言語系/ポインタ・配列の定義と宣言メモ1</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-01-03 18:51:35 &nbsp; / &nbsp; last updated at: 2010-01-03 18:55:26<br>
カテゴリ: <a href="category-10.html">C言語</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-851.html" title="C言語系/「デーモン君のソース探検」読書メモ/A11(Intermission), exit(2) → wait4(2)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-615.html" title="C言語系/呼び出し規約/x86">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
「エキスパートCプログラミング」を読んでいたら、ポインタ/配列として定義したオブジェクトを別のファイルで配列/ポインタとして宣言すると動作がおかしくなるよ、誤解してるよ、という部分があったので、ちょっと面白そうなので試してみた。
<br />
</p>




<ul><li><a href="#id853885">定義と宣言の型を一致させる「正しい」使い方をしてみる。</a><ul><li><a href="#id9d3a4f">メモリ配置の確認</a></li>
<li><a href="#ida9d9a3">main関数の逆アセンブル</a></li>
<li><a href="#id5c2984">gdbによるステップ実行確認</a></li></ul></li>
<li><a href="#id0a3b1e">定義と宣言が一致しない場合</a><ul><li><a href="#id086d5f">メモリ配置の確認とmain関数の逆アセンブル</a></li>
<li><a href="#id5c2984">gdbによるステップ実行確認</a></li></ul></li></ul>
<hr />
<h3 id="id853885">定義と宣言の型を一致させる「正しい」使い方をしてみる。</h3>

<p class="paragraph">
まず「正しい」使い方をしてみる。
<br />
</p>

<p class="paragraph">
aryptr0.c というファイルに、char型のポインタ(ptr1)と配列(ary1)を定義する。
<br />
</p>
<pre>char *ptr1 = &quot;Hello&quot;;
char ary1[] = &quot;World&quot;;
</pre>

<p class="paragraph">
これを、型を変えずに宣言して別ファイルの中で使ってみる：aryptr1.c
<br />
</p>
<div class="hl-main"><pre><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdio.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
 
</span><span >extern</span><span class="hl-code"> </span><span >char</span><span class="hl-code"> *</span><span class="hl-identifier">ptr1</span><span class="hl-code">;
</span><span >extern</span><span class="hl-code"> </span><span >char</span><span class="hl-code"> </span><span class="hl-identifier">ary1</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-code">;
 
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span >char</span><span class="hl-code"> </span><span class="hl-identifier">c</span><span class="hl-code">;
        </span><span class="hl-identifier">c</span><span class="hl-code"> = </span><span class="hl-identifier">ptr1</span><span class="hl-brackets">[</span><span class="hl-number">2</span><span class="hl-brackets">]</span><span class="hl-code">;
        </span><span class="hl-identifier">c</span><span class="hl-code"> = </span><span class="hl-identifier">ary1</span><span class="hl-brackets">[</span><span class="hl-number">2</span><span class="hl-brackets">]</span><span class="hl-code">;
        </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">0</span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>

<p class="paragraph">
それぞれコンパイルし、リンクする。
<br />
</p>
<pre>cc -Wall -g -c -o aryptr0.o aryptr0.c
cc -Wall -g -c -o aryptr1.o aryptr1.c
cc -Wall -o aryptr aryptr1.o aryptr0.o
</pre>

<h4 id="id9d3a4f">メモリ配置の確認</h4>

<p class="paragraph">
ptr1, ary1がどこのセクションに配置されたか確認してみる。まずはnmコマンドでアドレスを確認してみる。
<br />
</p>
<pre>$ nm aryptr
...
08049a9c D ary1
...
080488d4 T main
08049a98 D ptr1
</pre>

<p class="paragraph">
0x8049a98 にptr1, 4バイト後ろの 0x8049a9c に ary1が配置されている。ちなみにmain関数は0x80488d4に配置される。
<br />
ここでセクションヘッダーをチェックし、実際のセクション名を突き止める。
<br />
</p>
<pre class="plugin_pre">
$ objdump -h aryptr

aryptr:     file format elf32-i386

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .interp       00000017  080480f4  080480f4  000000f4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
(途中省略)
  9 .text         000002d4  08048624  08048624  00000624  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .fini         00000081  08048900  08048900  00000900  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .rodata       000000e6  080489a0  080489a0  000009a0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 12 .data         0000001c  08049a88  08049a88  00000a88  2**2
                  CONTENTS, ALLOC, LOAD, DATA
(以下省略)
</pre>
<p class="paragraph">
&quot;.data&quot;セクションが丁度、0x8049a88 から 0x1c サイズ分ある。つまり、ptr1(0x8049a98), ary1(0x8049a9c)が入ってると思われる。
<br />
ということで&quot;.data&quot;セクションをダンプしてみる。
<br />
</p>
<pre class="plugin_pre">
$ objdump -s -j .data aryptr

aryptr:     file format elf32-i386

Contents of section .data:
 8049a88 a0890408 00000000 00000000 00000000  ................
 8049a98 808a0408 576f726c 64000000           ....World...
</pre>
<p class="paragraph">
うまい具合に ptr1(0x8049a98)が2行目の先頭に来ている。その4バイト後に、ary1の配列初期化データ&quot;World&quot;が来ている。
<br />
またptr1の内容を見てみると &quot;808a0408&quot;, エンディアンを戻せば 0x8048a80 を示しており、このアドレス範囲を含んでいるのは先の&quot;objdump -h&quot;の結果から &quot;.rodata&quot; セクションであることが分かる。ということで、&quot;.rodata&quot;をダンプしてみる。
<br />
</p>
<pre class="plugin_pre">
$ objdump -s -j .rodata aryptr

aryptr:     file format elf32-i386

Contents of section .rodata:
 80489a0 00000000 00000000 00000000 00000000  ................
 ...
 8048a80 48656c6c 6f00                        Hello.
</pre>
<p class="paragraph">
ちょうどキリの良いアドレスと言うこともあり、&quot;Hello&quot;という、ptr1の指しているデータが 0x8048a80 に存在することが確認出来た。
<br />
</p>

<h4 id="ida9d9a3">main関数の逆アセンブル</h4>

<p class="paragraph">
ここまでで ptr1, ary1 のメモリ配置イメージは確認出来たので、いよいよmain関数の中でどう処理されるのかdisassembleしてみる。
<br />
main関数は0x80488d4、つまり&quot;.text&quot;セクションにあるので、&quot;--start-address&quot;オプションを活用して次のようにobjdumpコマンドで逆アセンブルする。&quot;-d&quot;で逆アセンブル、&quot;-S&quot;で対応するソースコード行を出力、&quot;-j&quot;でセクション指定。
<br />
</p>
<pre class="plugin_pre">
$ objdump -d -S -j .text --start-address=0x80488d4 aryptr

aryptr:     file format elf32-i386

Disassembly of section .text:

080488d4 &lt;main&gt;:
 80488d4:       55                      push   %ebp
 80488d5:       89 e5                   mov    %esp,%ebp
 80488d7:       83 ec 18                sub    $0x18,%esp
extern char ary1[];

int main() {
        char c;
        c = ptr1[2];
 80488da:       a1 98 9a 04 08          mov    0x8049a98,%eax
 80488df:       83 c0 02                add    $0x2,%eax
 80488e2:       8a 10                   mov    (%eax),%dl
 80488e4:       88 55 ff                mov    %dl,0xffffffff(%ebp)
        c = ary1[2];
 80488e7:       a0 9e 9a 04 08          mov    0x8049a9e,%al
 80488ec:       88 45 ff                mov    %al,0xffffffff(%ebp)
        return 0;
 80488ef:       31 c0                   xor    %eax,%eax
 80488f1:       eb 01                   jmp    80488f4 &lt;main+0x20&gt;
}
 80488f3:       90                      nop
 80488f4:       c9                      leave
 80488f5:       c3                      ret
 80488f6:       89 f6                   mov    %esi,%esi
</pre>

<p class="paragraph">
ptr1, ary1の処理をそれぞれ見てみる。
<br />
</p>
<pre>c = ptr1[2];
</pre>
<p class="paragraph">
char型ポインタとして宣言された&quot;ptr1&quot;に配列の添字をつけている。配列の添字はオフセットに計算される。実際にアセンブラを呼んでみると、まず以下のmov命令で&quot;ptr1&quot;(0x8049a98)の中身がEAXレジスタに転送される。
<br />
</p>
<pre>80488da:       a1 98 9a 04 08          mov    0x8049a98,%eax
</pre>
<p class="paragraph">
先ほどメモリ配置を確認したとおり、EAXの中身はptr1の指しているアドレスの値、0x8048a80 になる。
<br />
続いて&quot;[2]&quot;が計算される。char型なので1バイト単位、つまり2バイト分追加となるのが次のadd命令になる。
<br />
</p>
<pre>80488df:       83 c0 02                add    $0x2,%eax
</pre>
<p class="paragraph">
そしてEAXの値をアドレスとして、そこの値をDLに転送し、ローカル変数c(=スタック上の領域)に転送している。
<br />
</p>
<pre>80488e2:       8a 10                   mov    (%eax),%dl
80488e4:       88 55 ff                mov    %dl,0xffffffff(%ebp)
</pre>

<p class="paragraph">
続いてchar型の配列として宣言された&quot;ary1&quot;の処理を見てみる。
<br />
</p>
<pre>c = ary1[2];
</pre>
<p class="paragraph">
これは非常に素直に、&quot;ary1&quot;のアドレス 0x8049a9c に2を足したアドレス 0x8049a9e の値をALに転送し、続けてローカル変数c(=スタック上の領域)に転送している。
<br />
</p>
<pre>80488e7:       a0 9e 9a 04 08          mov    0x8049a9e,%al
80488ec:       88 45 ff                mov    %al,0xffffffff(%ebp)
</pre>

<h4 id="id5c2984">gdbによるステップ実行確認</h4>

<p class="paragraph">
では実際にgdb上で動かして確認してみる。
<br />
</p>
<pre class="plugin_pre">
$ gdb aryptr
GNU gdb 5.0nb1
(...)
This GDB was configured as &quot;i386--netbsdelf&quot;...
(gdb) b main
Breakpoint 1 at 0x80488da: file aryptr1.c, line 8.
(gdb) run
Starting program: /home/msakamoto/lang.c/aryptr

Breakpoint 1, main () at aryptr1.c:8
8               c = ptr1[2];
</pre>
<p class="paragraph">
ブレークポイントで停まったので、プログラムカウンタを見てみる。
<br />
</p>
<pre>(gdb) p/x $pc
$1 = 0x80488da
</pre>
<p class="paragraph">
これは先ほどobjdumpで逆アセンブルした以下のコードの直前、ということが分かる。
<br />
</p>
<pre>80488da:       a1 98 9a 04 08          mov    0x8049a98,%eax
</pre>
<p class="paragraph">
早速 &quot;next&quot; と行きたいところだが、それだとC言語のソース1行丸ごと実行してしまう。
<br />
アセンブラのインストラクション単位で実行していきたいので、&quot;i&quot;をつけて &quot;nexti&quot; を実行し、プログラムカウンタを確認する。
<br />
</p>
<pre>(gdb) nexti
0x80488df       8               c = ptr1[2];
(gdb) p/x $pc
$2 = 0x80488df
</pre>
<p class="paragraph">
この時点でのEAXレジスタを確認してみる。
<br />
</p>
<pre>(gdb) p/x $eax
$3 = 0x8048a80
</pre>
<p class="paragraph">
予想通り 0x8048a80 になっている。続けて&quot;nexti&quot;を実行すると、
<br />
</p>
<pre>80488df:       83 c0 02                add    $0x2,%eax
</pre>
<p class="paragraph">
この命令が実行されるので、EAXには2が足されるはずだ。
<br />
</p>
<pre>(gdb) nexti
0x80488e2       8               c = ptr1[2];
(gdb) p/x $eax
$4 = 0x8048a82
</pre>
<p class="paragraph">
予想通り、0x8048a80 + 2 で 0x8048a82 になっている。では、このアドレスの中身をDLレジスタに転送させてみる。以下のコードが実行される筈。
<br />
</p>
<pre>80488e2:       8a 10                   mov    (%eax),%dl
</pre>
<p class="paragraph">
ということで&quot;nexti&quot;。
<br />
</p>
<pre>(gdb) nexti
0x80488e4       8               c = ptr1[2];
(gdb) p/x $dx
$5 = Value can&#039;t be converted to integer. # あちゃー、この名前(dx)は使えないか。
(gdb) p/x $edx
$6 = 0x6c
</pre>
<p class="paragraph">
&quot;Hello&quot;の&quot;[2]&quot;なので3文字目、&quot;l&quot;のASCIIコードがEDXに格納されたことが確認できた。
<br />
最後、逆アセンブルした以下のコードが実行される。
<br />
</p>
<pre>80488e4:       88 55 ff                mov    %dl,0xffffffff(%ebp)
</pre>
<p class="paragraph">
ということで&quot;next&quot;。(ここまで来れば&quot;i&quot;はつけなくても良いでしょう。)
<br />
</p>
<pre>(gdb) next
9               c = ary1[2];
(gdb) print c
$7 = 108 &#039;l&#039;
</pre>
<p class="paragraph">
ローカル変数&quot;c&quot;に&quot;l&quot;が格納されたことを確認出来た。
<br />
</p>

<p class="paragraph">
続けて&quot;ary1&quot;の処理を確認する。
<br />
</p>
<pre>(gdb) p/x $pc
$8 = 0x80488e7
</pre>
<p class="paragraph">
プログラムカウンタを見てみると、ちょうど次の命令の実行直前になっている。
<br />
</p>
<pre>80488e7:       a0 9e 9a 04 08          mov    0x8049a9e,%al
</pre>
<p class="paragraph">
&quot;nexti&quot;で見ていく。
<br />
</p>
<pre>(gdb) nexti
0x80488ec       9               c = ary1[2];
(gdb) p/x $eax
$9 = 0x8048a72
</pre>
<p class="paragraph">
EAXが &quot;0x8048a72&quot;になっているが、&quot;0x8048a&quot;は前の結果なので気にしなくて良い。最後の&quot;0x72&quot;は&quot;World&quot;の3文字目、&quot;r&quot;のASCIIコードになっている。
<br />
予想通りの動きになっている。最後に、以下の命令が実行される。
<br />
</p>
<pre>80488ec:       88 45 ff                mov    %al,0xffffffff(%ebp)
</pre>
<p class="paragraph">
&quot;nexti&quot;で実行後、ローカル変数&quot;c&quot;に&quot;r&quot;が格納されたことを確認出来た。
<br />
</p>
<pre>(gdb) nexti
10              return 0;
(gdb) print c
$10 = 114 &#039;r&#039;
(gdb) continue
Continuing.

Program exited normally.
(gdb) quit
</pre>

<h3 id="id0a3b1e">定義と宣言が一致しない場合</h3>

<p class="paragraph">
長かったがここからが本題である。今までは「配列で定義されたオブジェクトは配列で宣言」「ポインタで定義された(以下略)」として「正しい」使い方をした場合を見てきたが、これを逆にしてみるとどうなるか確認したい。
<br />
</p>

<p class="paragraph">
aryptr2.c:
<br />
</p>
<div class="hl-main"><pre><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdio.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
 
</span><span >extern</span><span class="hl-code"> </span><span >char</span><span class="hl-code"> </span><span class="hl-identifier">ptr1</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-code">;
</span><span >extern</span><span class="hl-code"> </span><span >char</span><span class="hl-code"> *</span><span class="hl-identifier">ary1</span><span class="hl-code">;
 
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span >char</span><span class="hl-code"> </span><span class="hl-identifier">c</span><span class="hl-code">;
        </span><span class="hl-identifier">c</span><span class="hl-code"> = </span><span class="hl-identifier">ptr1</span><span class="hl-brackets">[</span><span class="hl-number">2</span><span class="hl-brackets">]</span><span class="hl-code">;
        </span><span class="hl-identifier">c</span><span class="hl-code"> = </span><span class="hl-identifier">ary1</span><span class="hl-brackets">[</span><span class="hl-number">2</span><span class="hl-brackets">]</span><span class="hl-code">;
        </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">0</span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>

<p class="paragraph">
ptr1, ary1を定義している実体ファイルは前に使ったのと同じ、aryptr0.cを使う。
<br />
</p>
<pre>char *ptr1 = &quot;Hello&quot;;
char ary1[] = &quot;World&quot;;
</pre>

<p class="paragraph">
これにより、aryptr2.cでは「ポインタで定義された ptr1 を配列として宣言」「配列として定義された ary1 をポインタとして宣言」したことになる。
<br />
コンパイル、リンクしてみる。
<br />
</p>
<pre>cc -Wall -g -c -o aryptr2.o aryptr2.c
cc -Wall -g -o aryptr2 aryptr2.o aryptr0.o
</pre>

<h4 id="id086d5f">メモリ配置の確認とmain関数の逆アセンブル</h4>

<p class="paragraph">
&quot;nm&quot;コマンドでシンボルを確認する。
<br />
</p>
<pre>$ nm aryptr2
...
08049a9c D ary1
...
080488d4 T main
08049a98 D ptr1
</pre>

<p class="paragraph">
ary1, ptr1に関しては変化していない。main関数をダンプしてみる。
<br />
</p>
<pre class="plugin_pre">
$ objdump -d -S -j .text --start-address=0x80488d4 aryptr2

aryptr2:     file format elf32-i386

Disassembly of section .text:

080488d4 &lt;main&gt;:
 80488d4:       55                      push   %ebp
 80488d5:       89 e5                   mov    %esp,%ebp
 80488d7:       83 ec 18                sub    $0x18,%esp
extern char *ary1;

int main() {
        char c;
        c = ptr1[2];
 80488da:       a0 9a 9a 04 08          mov    0x8049a9a,%al
 80488df:       88 45 ff                mov    %al,0xffffffff(%ebp)
        c = ary1[2];
 80488e2:       a1 9c 9a 04 08          mov    0x8049a9c,%eax
 80488e7:       83 c0 02                add    $0x2,%eax
 80488ea:       8a 10                   mov    (%eax),%dl
 80488ec:       88 55 ff                mov    %dl,0xffffffff(%ebp)
        return 0;
 80488ef:       31 c0                   xor    %eax,%eax
 80488f1:       eb 01                   jmp    80488f4 &lt;main+0x20&gt;
}
 80488f3:       90                      nop
 80488f4:       c9                      leave
 80488f5:       c3                      ret
 80488f6:       89 f6                   mov    %esi,%esi
</pre>

<p class="paragraph">
ptr1とary1の処理が丁度 aryptr1.c のアセンブラコードと逆さまになっていることが分かる。ptr1は配列として、ary1はポインタとして処理するコードになっている。
<br />
</p>

<h4 id="id5c2984">gdbによるステップ実行確認</h4>

<p class="paragraph">
gdbを使いデバッグしてみる。
<br />
</p>
<pre class="plugin_pre">
$ gdb aryptr2
GNU gdb 5.0nb1
...
This GDB was configured as &quot;i386--netbsdelf&quot;...
(gdb) b main
Breakpoint 1 at 0x80488da: file aryptr2.c, line 8.
(gdb) run
Starting program: /home/msakamoto/lang.c/aryptr2

Breakpoint 1, main () at aryptr2.c:8
8               c = ptr1[2];
</pre>
<p class="paragraph">
ブレークポイントで停止した時点のプログラムカウンタを確認する。
<br />
</p>
<pre>(gdb) p/x $pc
$1 = 0x80488da
</pre>
<p class="paragraph">
次に実行される命令は次のmov命令であることが分かる。
<br />
</p>
<pre>80488da:       a0 9a 9a 04 08          mov    0x8049a9a,%al
</pre>
<p class="paragraph">
&quot;nexti&quot;で実行してみる。
<br />
</p>
<pre>(gdb) nexti
0x80488df       8               c = ptr1[2];
(gdb) p/x $eax
$2 = 0x8049b04
</pre>
<p class="paragraph">
EAXの値が&quot;0x8049b04&quot;になっている。念のため、0x8049a9aにあった値を確認してみる。
<br />
</p>
<pre>(gdb) x/b 0x8049a9a
0x8049a9a &lt;ptr1+2&gt;:     0x04
</pre>
<p class="paragraph">
&quot;0x04&quot;がALに転送されていることが確認出来た。&quot;0x8049b&quot;の部分は以前の計算結果が残っていたものと思われる。
<br />
引き続き実行してみる。
<br />
</p>
<pre>(gdb) nexti
9               c = ary1[2];
(gdb) print c
$5 = 4 &#039;\004&#039;
</pre>
<p class="paragraph">
実行されたのは次の命令であり、ALの値(0x04)がローカル変数&quot;c&quot;に転送されたことを確認出来た。
<br />
</p>
<pre>80488df:       88 45 ff                mov    %al,0xffffffff(%ebp)
</pre>

<p class="paragraph">
ここまでは（本来の挙動としては間違っているものの）セグメンテーションフォルトなどは発生せずに実行できた。
<br />
引き続き&quot;ary1&quot;の処理に進めてみる。
<br />
</p>
<pre>(gdb) nexti
0x80488e7       9               c = ary1[2];
(gdb) p/x $pc
$6 = 0x80488e7
(gdb) p/x $eax
$7 = 0x6c726f57
</pre>
<p class="paragraph">
これは以下の命令が完了した直後の状態である。
<br />
</p>
<pre>80488e2:       a1 9c 9a 04 08          mov    0x8049a9c,%eax
</pre>
<p class="paragraph">
ary1(=0x8049a9c)が、配列として定義されているのに、使う側ではポインタとして宣言されてしまった為、ary1のアドレスの中身がまずEAXに転送されてしまっている。
<br />
</p>
<pre>0x8049a9c[0] : &quot;W&quot;(=0x57)
         [1] : &quot;o&quot;(=0x6f)
         [2] : &quot;r&quot;(=0x72)
         [3] : &quot;l&quot;(=0x6c)
         [4] : &quot;d&quot;(=0x64)
</pre>
<p class="paragraph">
これの、ポインタ型つまり4バイト分がEAXに転送されたので、エンディアンの影響で
<br />
</p>
<pre>EAX = &quot;l&quot;(0x6c), &quot;r&quot;(0x72), &quot;o&quot;(0x6f), &quot;W&quot;(0x57)
    = 0x6c726f57
</pre>
<p class="paragraph">
となった。
<br />
ステップ実行を続けてみる。
<br />
</p>
<pre>80488e7:       83 c0 02                add    $0x2,%eax
</pre>
<p class="paragraph">
この処理へnextiでステップ実行する。
<br />
</p>
<pre>(gdb) nexti
0x80488ea       9               c = ary1[2];
(gdb) p/x $eax
$8 = 0x6c726f59
</pre>
<p class="paragraph">
EAXの値に2が加算された。そして次の処理へステップ実行してみる。
<br />
</p>
<pre>80488ea:       8a 10                   mov    (%eax),%dl
</pre>
<p class="paragraph">
ここでセグメンテーションフォルトが発生する。
<br />
</p>
<pre>(gdb) nexti

Program received signal SIGSEGV, Segmentation fault.
0x80488ea in main () at aryptr2.c:9
9               c = ary1[2];
</pre>
<p class="paragraph">
EAXの値、0x6c726f59のアドレスを参照してみると、不正なメモリ参照でエラーになる。
<br />
</p>
<pre>(gdb) x/b 0x6c726f59
0x6c726f59:     Error accessing memory address 0x6c726f59: Invalid argument.
</pre>

<p class="paragraph">
このように、配列定義をポインタとして宣言、あるいはポインタ定義を配列として宣言して処理しようとすると、不正メモリ参照を初めとするバグが発生することが確認出来た。
<br />
またgcc/gdbが使える場合は、アセンブラのインストラクション単位でステップ実行することにより、そうしたバグの発生原因を効率的に突き止めることが可能であることが分かった。
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-851.html" title="C言語系/「デーモン君のソース探検」読書メモ/A11(Intermission), exit(2) → wait4(2)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-615.html" title="C言語系/呼び出し規約/x86">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">Up</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/533<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2001 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" target="_blank" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>