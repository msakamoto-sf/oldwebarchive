<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>日記/2012/05/02/JavaでHTTP(S)両対応のProxyを実験してみた。 - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">日記/2012/05/02/JavaでHTTP(S)両対応のProxyを実験してみた。</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2012-05-02 21:48:47 &nbsp; / &nbsp; last updated at: 2012-05-02 22:40:45<br>
カテゴリ: <a href="category-11.html">Java</a>&nbsp;<a href="category-23.html">セキュリティ</a>&nbsp;</div>

<div class="data_body">
<p class="paragraph">
前回・前々回のエントリーとJavaでSSLSocket関連のお勉強をしてきましたが、そもそもの目的はBurpSuiteなどのHTTP/HTTPS両対応のJavaのProxyが、どうやってHTTPSのProxyを実現しているかの調査でした。基本的にはHTTPSプロキシを設定されたUser-Agentは、最初にCONNECTメソッドで本来のホスト名とポート番号をProxyに伝え、Proxyは以降、HTTPではなくTCPレベルでUser-Agentと実際のサーバとの間のパケットの中継のみを行います。したがってSSL/TLSのパケットの中身には触れません。一方で、BurpSuiteやDoormanなどはSSL/TLSのパケットの中身についても読み書きが出来ます。さらにBurpSuiteなどは接続先に応じて証明書をその場で生成することが可能で、共通のPortSwiggerのCA証明書で署名された証明書がUser-Agentには提示されます。
<br />
ProxyがSSL/TLSの内容について読み書きする方式は、少なくとも2種類の実装方式があるようです。
<br />
</p>
<ul><li> 内部でMITMのSSL/TLSサーバを立ち上げ、そこに中継するタイプ。(jumperz.netのDoormanがこのタイプ)</li>
<li> SSLEngine(JDK 1.5以降)を使ってProxy自身がハンドシェイクからSSL/TLSパケットのwrap()/unwrap()を行うタイプ。</li></ul>

<p class="paragraph">
今回はMITMのSSL/TLSサーバを立ち上げ、中継するタイプを作れるか実験してみました。HTTPサーバ・クライアントの実装やHTTPメッセージの処理については Apache HttpComponents の HttpCore を使って手抜きしました。さすがにソケット入出力の調整やHTTPメッセージの処理まで、ゼロからコーディングする体力は無いです・・・。
<br />
</p>

<ul><li> Apache HttpComponents<ul><li> <a class="externallink" href="http://hc.apache.org/" target="_blank">http://hc.apache.org/</a></li></ul></li>
<li> 前回・前々回のエントリー：<ul><li> <a href="./view-1075.html" >日記/2012/04/22/JavaでSSLSocketの勉強メモ1</a></li>
<li> <a href="./view-1076.html" >日記/2012/04/22/JavaでSSLSocketの勉強メモ2</a></li></ul></li></ul>



<ul><li><a href="#id3ca3de">ソースコード</a></li>
<li><a href="#id2f6a90">実験用のHTTP/HTTPSサーバを組み立てる</a></li>
<li><a href="#id66784a">まずHTTP Proxyを作ってみる。</a></li>
<li><a href="#idd5c060">HTTPS Proxyを組み立ててみる（HTTPSは中継するだけ）</a></li>
<li><a href="#ida407ae">HTTPS Proxyを組み立ててみる（HTTPSの中にも触れる）</a></li>
<li><a href="#id7ff36c">curlでの実験</a></li></ul>
<hr />
<h3 id="id3ca3de">ソースコード</h3>

<p class="paragraph">
ソースコードは以下のzipを参照してください。HttpCoreのjarファイルについては除外し、.javaとKeyStoreファイルのみにしています。適当なEclipseプロジェクトに展開し、HttpCore 4.1.4 (GA) をDLしてjarファイルを追加してください。
<br />
</p>

<p class="paragraph">
<a href="./../images/https_proxy_exercise/https_proxy_exercise.zip" target="_blank" >./../images/https_proxy_exercise/https_proxy_exercise.zip</a>
<br />
</p>

<p class="paragraph">
※「動けばいいや」で作ってますので、クラス構成とかエラー処理とか色々ヒドイ作りになってます。HttpCore付属のサンプルを適当に切り貼りしたから・・・。
<br />
</p>

<h3 id="id2f6a90">実験用のHTTP/HTTPSサーバを組み立てる</h3>

<p class="paragraph">
まず実験用のHTTP/HTTPSサーバを組み立ててみます。HttpCoreについてくるサンプルコードの、ElementalHttpServer を参考に、クラスを分割したりしてます。
<br />
</p>
<ul><li> exercise.hello. 以下のクラス：<ul><li> Server … main()定義、RequestListenerとTlsRequestListenerを起動するだけのクラス</li>
<li> RequestListener … HTTP処理の準備とServerSocketの作成 + accept()</li>
<li> TlsRequestListener … HTTP処理の準備とSSLServerSocketの作成 + accept()</li>
<li> WorkerThread … accept()後の各クライアントとのソケット処理スレッド。<ul><li> 実際の入出力処理とHandlerの呼び出しは、HttpServiceクラスのインスタンスが処理します。ここでのWorkerThreadは単にHttpService#handleRequest()を繰り返し呼び出すだけの容れ物になっています。</li></ul></li>
<li> HelloHandler … ダミーのHTMLを返すハンドラ。</li></ul></li></ul>

<p class="paragraph">
あまり複雑な構成にはなっていませんが、一応図にすると以下の様な構成になっています。TLSでは、異なっているのはSSLServerSocketを用意するところだけですので、accept()後のソケット処理とHTTPメッセージの処理についてはWorkerThreadとHelloHandlerを使いまわしています。
<br />
</p>

<p class="paragraph">
<a href="./../images/https_proxy_exercise/https_proxy_exercise_01.png" title="" target="_blank"><img src="./../images/https_proxy_exercise/https_proxy_exercise_01.png" alt="" title=""  /></a>
<br />
</p>

<h3 id="id66784a">まずHTTP Proxyを作ってみる。</h3>

<p class="paragraph">
HttpCoreについてくるサンプルコードの、ElementalReverseProxy を参考に・・・してはいるんですが、リバースプロキシとはやはり性質が違うため、いろいろ試行錯誤が必要になってしまいました。サンプルコード中のはHTTPS Proxyの機能も混ざってはいますが、HTTP Proxyについての機能に絞れば以下のクラスで実装しています。
<br />
</p>
<ul><li> exercise.proxy1. 以下のクラス：<ul><li> Server … main()定義、IncommingListenerを起動するだけのクラス</li>
<li> IncommingListener … HTTP処理の準備とServerSocketの作成 + accept()</li>
<li> ProxyWorker … accept()後の各クライアントとのソケット処理スレッド。<ul><li> HTTP Proxyの機能だけに絞れば、実験用サーバのWorkerThreadと殆ど一緒です。</li></ul></li>
<li> ProxyHandler … Proxy機能の実装。HttpRequestExecutorを使って実際のサーバと通信した結果をresponseに格納します。</li></ul></li></ul>

<p class="paragraph">
図にすると以下の様な構成になっています。
<br />
<a href="./../images/https_proxy_exercise/https_proxy_exercise_02.png" title="" target="_blank"><img src="./../images/https_proxy_exercise/https_proxy_exercise_02.png" alt="" title=""  /></a>
<br />
</p>


<p class="paragraph">
HTTP Proxyの中心であるProxyHandlerについて簡単にソースコードコメントで解説します。
<br />
</p>
<div class="hl-main"><pre><span class="hl-reserved">public</span><span class="hl-code"> </span><span class="hl-reserved">class</span><span class="hl-code"> </span><span class="hl-identifier">ProxyHandler</span><span class="hl-code"> </span><span class="hl-reserved">implements</span><span class="hl-code"> </span><span class="hl-identifier">HttpRequestHandler</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span class="hl-reserved">private</span><span class="hl-code"> </span><span >final</span><span class="hl-code"> </span><span class="hl-identifier">HttpProcessor</span><span class="hl-code"> </span><span class="hl-identifier">httpproc</span><span class="hl-code">;
    </span><span class="hl-reserved">private</span><span class="hl-code"> </span><span >final</span><span class="hl-code"> </span><span class="hl-identifier">HttpRequestExecutor</span><span class="hl-code"> </span><span class="hl-identifier">httpexecutor</span><span class="hl-code">;
    </span><span class="hl-reserved">private</span><span class="hl-code"> </span><span >final</span><span class="hl-code"> </span><span class="hl-identifier">HttpParams</span><span class="hl-code"> </span><span class="hl-identifier">params</span><span class="hl-code">;
    </span><span class="hl-reserved">public</span><span class="hl-code"> </span><span class="hl-identifier">ProxyHandler</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-comment">//</span><span class="hl-comment"> Set up HTTP protocol processor for outgoing connections</span><span class="hl-comment"></span><span class="hl-code">
        </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">httpproc</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">ImmutableHttpProcessor</span><span class="hl-brackets">(</span><span class="hl-comment">/*</span><span class="hl-comment"> ... </span><span class="hl-comment">*/</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-comment">//</span><span class="hl-comment"> Set up outgoing request executor </span><span class="hl-comment"></span><span class="hl-code">
        </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">httpexecutor</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">HttpRequestExecutor</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">params</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">SyncBasicHttpParams</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">params</span><span class="hl-code">.</span><span class="hl-identifier">setIntParameter</span><span class="hl-brackets">(</span><span class="hl-comment">/*</span><span class="hl-comment"> … </span><span class="hl-comment">*/</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
 
    @</span><span class="hl-identifier">Override</span><span class="hl-code">
    </span><span class="hl-reserved">public</span><span class="hl-code"> </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">handle</span><span class="hl-brackets">(</span><span class="hl-code">
            </span><span >final</span><span class="hl-code"> </span><span class="hl-identifier">HttpRequest</span><span class="hl-code"> </span><span class="hl-identifier">request</span><span class="hl-code">, 
            </span><span >final</span><span class="hl-code"> </span><span class="hl-identifier">HttpResponse</span><span class="hl-code"> </span><span class="hl-identifier">response</span><span class="hl-code">,
            </span><span >final</span><span class="hl-code"> </span><span class="hl-identifier">HttpContext</span><span class="hl-code"> </span><span class="hl-identifier">context</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-reserved">throws</span><span class="hl-code"> </span><span class="hl-identifier">HttpException</span><span class="hl-code">, </span><span class="hl-identifier">IOException</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
 
        </span><span class="hl-comment">//</span><span class="hl-comment"> Proxyを使った &quot;</span><span class="hl-url">http://hostname</span><span class="hl-comment">(:port)/path&quot; 形式からホスト名と</span><span class="hl-comment"></span><span class="hl-code">
        </span><span class="hl-comment">//</span><span class="hl-comment"> ポート番号と実際のURL Pathを取り出します。</span><span class="hl-comment"></span><span class="hl-code">
        </span><span class="hl-identifier">String</span><span class="hl-code"> </span><span class="hl-identifier">incommingUrlStr</span><span class="hl-code"> = </span><span class="hl-identifier">request</span><span class="hl-code">.</span><span class="hl-identifier">getRequestLine</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">.</span><span class="hl-identifier">getUri</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">URL</span><span class="hl-code"> </span><span class="hl-identifier">incommingUrl</span><span class="hl-code"> = </span><span class="hl-reserved">null</span><span class="hl-code">;
        </span><span class="hl-reserved">try</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-identifier">incommingUrl</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">URL</span><span class="hl-brackets">(</span><span class="hl-identifier">incommingUrlStr</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">catch</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">MalformedURLException</span><span class="hl-code"> </span><span class="hl-identifier">e</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-identifier">e</span><span class="hl-code">.</span><span class="hl-identifier">printStackTrace</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-identifier">System</span><span class="hl-code">.</span><span class="hl-identifier">err</span><span class="hl-code">.</span><span class="hl-identifier">println</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">ignore illegal url : </span><span class="hl-quotes">&quot;</span><span class="hl-code"> + </span><span class="hl-identifier">incommingUrlStr</span><span class="hl-code"> + </span><span class="hl-quotes">&quot;</span><span class="hl-string">]</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-reserved">return</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-identifier">String</span><span class="hl-code"> </span><span class="hl-identifier">realHost</span><span class="hl-code"> = </span><span class="hl-identifier">incommingUrl</span><span class="hl-code">.</span><span class="hl-identifier">getHost</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">realPort</span><span class="hl-code"> = </span><span class="hl-identifier">incommingUrl</span><span class="hl-code">.</span><span class="hl-identifier">getPort</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-identifier">realPort</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-identifier">realPort</span><span class="hl-code"> = </span><span class="hl-number">80</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-identifier">String</span><span class="hl-code"> </span><span class="hl-identifier">actualRequestPath</span><span class="hl-code"> = </span><span class="hl-identifier">incommingUrl</span><span class="hl-code">.</span><span class="hl-identifier">getFile</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
 
        </span><span class="hl-comment">//</span><span class="hl-comment"> 実際のサーバに向けたクライアント用Socketを作成し、</span><span class="hl-comment"></span><span class="hl-code">
        </span><span class="hl-comment">//</span><span class="hl-comment"> DefaultHttpClientConnectionを使ってHTTPパラメータを設定します。</span><span class="hl-comment"></span><span class="hl-code">
        </span><span class="hl-identifier">Socket</span><span class="hl-code"> </span><span class="hl-identifier">outsocket</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">Socket</span><span class="hl-brackets">(</span><span class="hl-identifier">realHost</span><span class="hl-code">, </span><span class="hl-identifier">realPort</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">DefaultHttpClientConnection</span><span class="hl-code"> </span><span class="hl-identifier">outconn</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">DefaultHttpClientConnection</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">outconn</span><span class="hl-code">.</span><span class="hl-identifier">bind</span><span class="hl-brackets">(</span><span class="hl-identifier">outsocket</span><span class="hl-code">, </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">params</span><span class="hl-brackets">)</span><span class="hl-code">;
        
        </span><span class="hl-comment">//</span><span class="hl-comment"> この間にProxy関連のリクエストヘッダを除去しています。</span><span class="hl-comment"></span><span class="hl-code">
 
        </span><span class="hl-comment">//</span><span class="hl-comment"> 実際のリクエストURL Pathを使ってリクエストヘッダを組み立てます。</span><span class="hl-comment"></span><span class="hl-code">
        </span><span class="hl-identifier">HttpRequest</span><span class="hl-code"> </span><span class="hl-identifier">targetRequest</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">BasicHttpRequest</span><span class="hl-brackets">(</span><span class="hl-code">
                </span><span class="hl-identifier">request</span><span class="hl-code">.</span><span class="hl-identifier">getRequestLine</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">.</span><span class="hl-identifier">getMethod</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">, 
                </span><span class="hl-identifier">actualRequestPath</span><span class="hl-code">, 
                </span><span class="hl-identifier">request</span><span class="hl-code">.</span><span class="hl-identifier">getRequestLine</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">.</span><span class="hl-identifier">getProtocolVersion</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">targetRequest</span><span class="hl-code">.</span><span class="hl-identifier">setHeaders</span><span class="hl-brackets">(</span><span class="hl-identifier">request</span><span class="hl-code">.</span><span class="hl-identifier">getAllHeaders</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">;
 
        </span><span class="hl-comment">//</span><span class="hl-comment"> 実際のHTTPサーバと通信します。</span><span class="hl-comment"></span><span class="hl-code">
        </span><span class="hl-identifier">HttpResponse</span><span class="hl-code"> </span><span class="hl-identifier">targetResponse</span><span class="hl-code"> = </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">httpexecutor</span><span class="hl-code">.</span><span class="hl-identifier">execute</span><span class="hl-brackets">(</span><span class="hl-identifier">targetRequest</span><span class="hl-code">, </span><span class="hl-identifier">outconn</span><span class="hl-code">, </span><span class="hl-identifier">context</span><span class="hl-brackets">)</span><span class="hl-code">;
 
        </span><span class="hl-comment">//</span><span class="hl-comment"> レスポンスBODYを取り出します。</span><span class="hl-comment"></span><span class="hl-code">
        </span><span class="hl-identifier">HttpEntity</span><span class="hl-code"> </span><span class="hl-identifier">entity</span><span class="hl-code"> = </span><span class="hl-identifier">targetResponse</span><span class="hl-code">.</span><span class="hl-identifier">getEntity</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">System</span><span class="hl-code">.</span><span class="hl-identifier">out</span><span class="hl-code">.</span><span class="hl-identifier">println</span><span class="hl-brackets">(</span><span class="hl-identifier">EntityUtils</span><span class="hl-code">.</span><span class="hl-identifier">getContentMimeType</span><span class="hl-brackets">(</span><span class="hl-identifier">entity</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-comment">//</span><span class="hl-comment"> 今回は実際のHTTPサーバとは毎回切断しますので、切断する前に、</span><span class="hl-comment"></span><span class="hl-code">
        </span><span class="hl-comment">//</span><span class="hl-comment"> レスポンスBODYを全て取り出しておく必要があります。</span><span class="hl-comment"></span><span class="hl-code">
        </span><span class="hl-comment">//</span><span class="hl-comment"> これを忘れると、最終的にUser-Agentに返すレスポンスBODYを作るときに、</span><span class="hl-comment"></span><span class="hl-code">
        </span><span class="hl-comment">//</span><span class="hl-comment"> すでに実際のHTTPサーバとの接続は閉じられているためBODYが読めずに例外となります。</span><span class="hl-comment"></span><span class="hl-code">
        </span><span >byte</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-code"> </span><span class="hl-identifier">responseBody</span><span class="hl-code"> = </span><span class="hl-identifier">EntityUtils</span><span class="hl-code">.</span><span class="hl-identifier">toByteArray</span><span class="hl-brackets">(</span><span class="hl-identifier">entity</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">EntityUtils</span><span class="hl-code">.</span><span class="hl-identifier">consume</span><span class="hl-brackets">(</span><span class="hl-identifier">entity</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-comment">//</span><span class="hl-comment"> これは要らないかも？</span><span class="hl-comment"></span><span class="hl-code">
 
        </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">httpexecutor</span><span class="hl-code">.</span><span class="hl-identifier">postProcess</span><span class="hl-brackets">(</span><span class="hl-identifier">response</span><span class="hl-code">, </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">httpproc</span><span class="hl-code">, </span><span class="hl-identifier">context</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-comment">//</span><span class="hl-comment"> Proxy関連のResponse Headerの除去と、最終的なResponseの組立</span><span class="hl-comment"></span><span class="hl-code">
        </span><span class="hl-identifier">response</span><span class="hl-code">.</span><span class="hl-identifier">setStatusLine</span><span class="hl-brackets">(</span><span class="hl-identifier">targetResponse</span><span class="hl-code">.</span><span class="hl-identifier">getStatusLine</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">response</span><span class="hl-code">.</span><span class="hl-identifier">setHeaders</span><span class="hl-brackets">(</span><span class="hl-identifier">targetResponse</span><span class="hl-code">.</span><span class="hl-identifier">getAllHeaders</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">response</span><span class="hl-code">.</span><span class="hl-identifier">setEntity</span><span class="hl-brackets">(</span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">ByteArrayEntity</span><span class="hl-brackets">(</span><span class="hl-identifier">responseBody</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">;
 
        </span><span class="hl-reserved">try</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-comment">//</span><span class="hl-comment"> 今回は毎回実際のHTTPサーバとの接続は切断します。</span><span class="hl-comment"></span><span class="hl-code">
            </span><span class="hl-identifier">outsocket</span><span class="hl-code">.</span><span class="hl-identifier">close</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">catch</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">Exception</span><span class="hl-code"> </span><span class="hl-identifier">e</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span class="hl-brackets">}</span></pre></div>

<p class="paragraph">
つまづいた点：
<br />
</p>
<ul><li> HttpCoreのサンプルはリバースプロキシのため、最初に接続先のサーバとのSocketを作成していた。こちらは通常のProxyなので、User-Agentのリクエストから接続先のSocketを作成する必要があったため、その辺りを色々組み替える必要があった。</li>
<li> 最初、EntityUtils.toByteArray()で読みだすことを行わずに、そのまま最終的なresponseにentityを渡していた。すると最終的なresponseを返す段階になってSocketはすでに閉じられています〜という趣旨の例外が発声した。暫くの間原因が分からなかったが、ようやく、最終的なresponseを返す段階になってStreamを読み出そうとするが、その時点ではすでに実際のHTTPサーバとのSocketは閉じられていたのでそれが原因とわかり、閉じる前に一旦メモリ上に読みだして(EntityUtisl.toByteArray())おくように変更した。</li>
<li> HttpCoreのサンプルはHttpService, HttpParams, HttpContext, HandlerなどなどがIncommingListenerに当たる上位クラスで全て生成され、Constructorを経由して多段に渡される構造になっていたため、最初、各クラスが本当に必要としているクラスとインスタンスが何なのかさっぱり分からなかった。</li>
<li> HttpServiceやHandlerのインスタンスはListenerレベルで1インスタンスずつ作成し、各Workerで共有している。HttpServiceについては関連するオブジェクト(=コンストラクタに渡す各パラメータ類)がスレッドセーフになっていれば問題ない（「スレッドセーフであること」を保証するのが大変・・・）。Handlerについても同様で、handle()中でHandler自身のinstanceの状態が変わらないように注意していれば基本的には問題ない・・・はず。一応サンプルがそのようになっていて、ひとつのHttpServiceやHandlerインスタンスが複数スレッドから同時に呼ばれるようになっているので、多分大丈夫・・・だろうなーと。というかそのことを理解するまでにまた一手間かかった。</li></ul>

<h3 id="idd5c060">HTTPS Proxyを組み立ててみる（HTTPSは中継するだけ）</h3>

<p class="paragraph">
原理としては、CONNECTメソッドをHTTPで受付たら、以降はCONNECTメソッドで指定されたサーバとひたすらTCPパケットを中継するだけのモードに切り替えます。先に図で示すと、今回のサンプルではこんな構成にしました。
<br />
</p>

<p class="paragraph">
<a href="./../images/https_proxy_exercise/https_proxy_exercise_03.png" title="" target="_blank"><img src="./../images/https_proxy_exercise/https_proxy_exercise_03.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
クラスの紹介は省略し、ポイントとなるソースコードを抜粋で紹介します。
<br />
まずProxyHandlerではCONNECTメソッドの場合に接続先サーバのホスト名とポート番号を取り出し、&quot;switch_to_https&quot; をONにします。
<br />
</p>
<div class="hl-main"><pre><span class="hl-code">@</span><span class="hl-identifier">Override</span><span class="hl-code">
    </span><span class="hl-reserved">public</span><span class="hl-code"> </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">handle</span><span class="hl-brackets">(</span><span class="hl-code">
            </span><span >final</span><span class="hl-code"> </span><span class="hl-identifier">HttpRequest</span><span class="hl-code"> </span><span class="hl-identifier">request</span><span class="hl-code">, 
            </span><span >final</span><span class="hl-code"> </span><span class="hl-identifier">HttpResponse</span><span class="hl-code"> </span><span class="hl-identifier">response</span><span class="hl-code">,
            </span><span >final</span><span class="hl-code"> </span><span class="hl-identifier">HttpContext</span><span class="hl-code"> </span><span class="hl-identifier">context</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-reserved">throws</span><span class="hl-code"> </span><span class="hl-identifier">HttpException</span><span class="hl-code">, </span><span class="hl-identifier">IOException</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
 
        </span><span class="hl-identifier">String</span><span class="hl-code"> </span><span class="hl-identifier">requestMethod</span><span class="hl-code"> = </span><span class="hl-identifier">request</span><span class="hl-code">.</span><span class="hl-identifier">getRequestLine</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">.</span><span class="hl-identifier">getMethod</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">CONNECT</span><span class="hl-quotes">&quot;</span><span class="hl-code">.</span><span class="hl-identifier">equals</span><span class="hl-brackets">(</span><span class="hl-identifier">requestMethod</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-comment">//</span><span class="hl-comment"> ひとまず 200 OKを返す準備</span><span class="hl-comment"></span><span class="hl-code">
            </span><span class="hl-identifier">response</span><span class="hl-code">.</span><span class="hl-identifier">setStatusCode</span><span class="hl-brackets">(</span><span class="hl-identifier">HttpStatus</span><span class="hl-code">.</span><span class="hl-identifier">SC_OK</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-identifier">response</span><span class="hl-code">.</span><span class="hl-identifier">setReasonPhrase</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">Connection established</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-comment">//</span><span class="hl-comment"> HttpContextの switch_to_https (このサンプルが独自に用意)をONにします。</span><span class="hl-comment"></span><span class="hl-code">
            </span><span class="hl-identifier">context</span><span class="hl-code">.</span><span class="hl-identifier">setAttribute</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">switch_to_https</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-reserved">true</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-comment">//</span><span class="hl-comment"> &quot;Host&quot;ヘッダーを取り出し、ホスト名とポート番号を取り出します。</span><span class="hl-comment"></span><span class="hl-code">
            </span><span class="hl-identifier">Header</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-code"> </span><span class="hl-identifier">headers</span><span class="hl-code"> = </span><span class="hl-identifier">request</span><span class="hl-code">.</span><span class="hl-identifier">getHeaders</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">Host</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-identifier">Header</span><span class="hl-code"> </span><span class="hl-identifier">hostHeader</span><span class="hl-code"> = </span><span class="hl-identifier">headers</span><span class="hl-brackets">[</span><span class="hl-number">0</span><span class="hl-brackets">]</span><span class="hl-code">;
            </span><span class="hl-identifier">String</span><span class="hl-code"> </span><span class="hl-identifier">hostValue</span><span class="hl-code"> = </span><span class="hl-identifier">hostHeader</span><span class="hl-code">.</span><span class="hl-identifier">getValue</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-identifier">System</span><span class="hl-code">.</span><span class="hl-identifier">out</span><span class="hl-code">.</span><span class="hl-identifier">println</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">HTTPS Host: </span><span class="hl-quotes">&quot;</span><span class="hl-code"> + </span><span class="hl-identifier">hostValue</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">colon</span><span class="hl-code"> = </span><span class="hl-identifier">hostValue</span><span class="hl-code">.</span><span class="hl-identifier">indexOf</span><span class="hl-brackets">(</span><span class="hl-quotes">'</span><span class="hl-string">:</span><span class="hl-quotes">'</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-comment">//</span><span class="hl-comment"> HttpContextにホスト名とポート番号を設定します。</span><span class="hl-comment"></span><span class="hl-code">
            </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-code"> == </span><span class="hl-identifier">colon</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-identifier">context</span><span class="hl-code">.</span><span class="hl-identifier">setAttribute</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">https.host</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">hostValue</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-identifier">context</span><span class="hl-code">.</span><span class="hl-identifier">setAttribute</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">https.port</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-number">443</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">else</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-identifier">context</span><span class="hl-code">.</span><span class="hl-identifier">setAttribute</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">https.host</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">hostValue</span><span class="hl-code">.</span><span class="hl-identifier">substring</span><span class="hl-brackets">(</span><span class="hl-number">0</span><span class="hl-code">, </span><span class="hl-identifier">colon</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">port</span><span class="hl-code"> = </span><span class="hl-number">443</span><span class="hl-code">;
                </span><span class="hl-reserved">try</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                    </span><span class="hl-identifier">String</span><span class="hl-code"> </span><span class="hl-identifier">port_s</span><span class="hl-code"> = </span><span class="hl-identifier">hostValue</span><span class="hl-code">.</span><span class="hl-identifier">substring</span><span class="hl-brackets">(</span><span class="hl-identifier">colon</span><span class="hl-code"> + </span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
                    </span><span class="hl-identifier">port</span><span class="hl-code"> = </span><span class="hl-identifier">Integer</span><span class="hl-code">.</span><span class="hl-identifier">parseInt</span><span class="hl-brackets">(</span><span class="hl-identifier">port_s</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">catch</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">Exception</span><span class="hl-code"> </span><span class="hl-identifier">ignore</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-identifier">port</span><span class="hl-code"> = </span><span class="hl-number">443</span><span class="hl-code">; </span><span class="hl-brackets">}</span><span class="hl-code">
                </span><span class="hl-identifier">context</span><span class="hl-code">.</span><span class="hl-identifier">setAttribute</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">https.port</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">port</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-brackets">}</span><span class="hl-code">
            </span><span class="hl-reserved">return</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-comment">/*</span><span class="hl-comment"> … </span><span class="hl-comment">*/</span></pre></div>
<p class="paragraph">
なおHttpContextの状態を変化させていますが、こちらはあくまでもhandleメソッドの引数であり、元を辿ればスレッドごとにProxyWorker内でnewされているので、この範囲ではスレッドセーフであると考えられます。
<br />
</p>

<p class="paragraph">
CONNECTメソッドの結果を受けて、TCP中継モードに切り替えるのはProxyWorkerの役目となります。
<br />
</p>
<div class="hl-main"><pre><span class="hl-reserved">public</span><span class="hl-code"> </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">run</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">System</span><span class="hl-code">.</span><span class="hl-identifier">out</span><span class="hl-code">.</span><span class="hl-identifier">println</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">New connection thread</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">HttpContext</span><span class="hl-code"> </span><span class="hl-identifier">context</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">BasicHttpContext</span><span class="hl-brackets">(</span><span class="hl-reserved">null</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-comment">//</span><span class="hl-comment"> HTTPS中継モード関連パラメタの初期化</span><span class="hl-comment"></span><span class="hl-code">
        </span><span >boolean</span><span class="hl-code"> </span><span class="hl-identifier">switchToHttps</span><span class="hl-code"> = </span><span class="hl-reserved">false</span><span class="hl-code">;
        </span><span class="hl-identifier">context</span><span class="hl-code">.</span><span class="hl-identifier">setAttribute</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">switch_to_https</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">switchToHttps</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">context</span><span class="hl-code">.</span><span class="hl-identifier">setAttribute</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">https.host</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">context</span><span class="hl-code">.</span><span class="hl-identifier">setAttribute</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">https.port</span><span class="hl-quotes">&quot;</span><span class="hl-code">, -</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-reserved">try</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-reserved">while</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">!</span><span class="hl-identifier">Thread</span><span class="hl-code">.</span><span class="hl-identifier">interrupted</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> &amp;&amp; </span><span class="hl-identifier">inconn</span><span class="hl-code">.</span><span class="hl-identifier">isOpen</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-identifier">switchToHttps</span><span class="hl-code"> = </span><span class="hl-brackets">(</span><span class="hl-identifier">Boolean</span><span class="hl-brackets">)</span><span class="hl-identifier">context</span><span class="hl-code">.</span><span class="hl-identifier">getAttribute</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">switch_to_https</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">switchToHttps</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                    </span><span class="hl-comment">//</span><span class="hl-comment"> CONNECTメソッドを受けて、HttpService用のループを抜ける。</span><span class="hl-comment"></span><span class="hl-code">
                    </span><span class="hl-identifier">System</span><span class="hl-code">.</span><span class="hl-identifier">out</span><span class="hl-code">.</span><span class="hl-identifier">println</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">Switching HTTPS Tunneling mode...</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
                    </span><span class="hl-reserved">break</span><span class="hl-code">;
                </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">else</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                    </span><span class="hl-identifier">System</span><span class="hl-code">.</span><span class="hl-identifier">out</span><span class="hl-code">.</span><span class="hl-identifier">println</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">handleRequest start</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
                    </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">httpservice</span><span class="hl-code">.</span><span class="hl-identifier">handleRequest</span><span class="hl-brackets">(</span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">inconn</span><span class="hl-code">, </span><span class="hl-identifier">context</span><span class="hl-brackets">)</span><span class="hl-code">;
                    </span><span class="hl-comment">//</span><span class="hl-comment"> HTTPS切り替えの取得（最新の値を取得）</span><span class="hl-comment"></span><span class="hl-code">
                    </span><span class="hl-identifier">switchToHttps</span><span class="hl-code"> = </span><span class="hl-brackets">(</span><span class="hl-identifier">Boolean</span><span class="hl-brackets">)</span><span class="hl-identifier">context</span><span class="hl-code">.</span><span class="hl-identifier">getAttribute</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">switch_to_https</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
                    </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">!</span><span class="hl-identifier">switchToHttps</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                        </span><span class="hl-comment">//</span><span class="hl-comment"> HTTPSでなければclose()により強制flush</span><span class="hl-comment"></span><span class="hl-code">
                        </span><span class="hl-comment">//</span><span class="hl-comment"> (これを入れないとcurlでHTTP Proxyのレスポンスが取得できなかった)</span><span class="hl-comment"></span><span class="hl-code">
                        </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">inconn</span><span class="hl-code">.</span><span class="hl-identifier">close</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
                    </span><span class="hl-brackets">}</span><span class="hl-code">
                    </span><span class="hl-identifier">System</span><span class="hl-code">.</span><span class="hl-identifier">out</span><span class="hl-code">.</span><span class="hl-identifier">println</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">handleRequest end</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-brackets">}</span><span class="hl-code">
            </span><span class="hl-brackets">}</span><span class="hl-code">
            </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">switchToHttps</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-comment">//</span><span class="hl-comment"> HTTPS中継モードで接続先のホスト名とポート番号を取得</span><span class="hl-comment"></span><span class="hl-code">
                </span><span class="hl-identifier">String</span><span class="hl-code"> </span><span class="hl-identifier">targetHost</span><span class="hl-code"> = </span><span class="hl-brackets">(</span><span class="hl-identifier">String</span><span class="hl-brackets">)</span><span class="hl-identifier">context</span><span class="hl-code">.</span><span class="hl-identifier">getAttribute</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">https.host</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">targetPort</span><span class="hl-code"> = </span><span class="hl-brackets">(</span><span class="hl-identifier">Integer</span><span class="hl-brackets">)</span><span class="hl-identifier">context</span><span class="hl-code">.</span><span class="hl-identifier">getAttribute</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">https.port</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-identifier">Socket</span><span class="hl-code"> </span><span class="hl-identifier">targetSocket</span><span class="hl-code"> = </span><span class="hl-reserved">null</span><span class="hl-code">;
                </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">localhost</span><span class="hl-quotes">&quot;</span><span class="hl-code">.</span><span class="hl-identifier">equals</span><span class="hl-brackets">(</span><span class="hl-identifier">targetHost</span><span class="hl-brackets">)</span><span class="hl-code"> &amp;&amp; </span><span class="hl-number">8081</span><span class="hl-code"> == </span><span class="hl-identifier">targetPort</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                    </span><span class="hl-comment">//</span><span class="hl-comment"> redirect to TLS relay server</span><span class="hl-comment"></span><span class="hl-code">
                    </span><span class="hl-comment">//</span><span class="hl-comment"> ここは後述</span><span class="hl-comment"></span><span class="hl-code">
                    </span><span class="hl-identifier">targetSocket</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">Socket</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">localhost</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-number">8889</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">else</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                    </span><span class="hl-comment">//</span><span class="hl-comment"> 中身を覗かないHTTPS中継モードはこちら。</span><span class="hl-comment"></span><span class="hl-code">
                    </span><span class="hl-identifier">targetSocket</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">Socket</span><span class="hl-brackets">(</span><span class="hl-identifier">targetHost</span><span class="hl-code">, </span><span class="hl-identifier">targetPort</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-brackets">}</span><span class="hl-code">
                </span><span class="hl-comment">//</span><span class="hl-comment"> 中継スレッドの作成とstart()</span><span class="hl-comment"></span><span class="hl-code">
                </span><span class="hl-identifier">Thread</span><span class="hl-code"> </span><span class="hl-identifier">in2target</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">TcpRelayWorker</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">in2target</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">insocket</span><span class="hl-code">, </span><span class="hl-identifier">targetSocket</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-identifier">in2target</span><span class="hl-code">.</span><span class="hl-identifier">setDaemon</span><span class="hl-brackets">(</span><span class="hl-reserved">true</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-identifier">in2target</span><span class="hl-code">.</span><span class="hl-identifier">start</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-identifier">Thread</span><span class="hl-code"> </span><span class="hl-identifier">target2in</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">TcpRelayWorker</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">target2in</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">targetSocket</span><span class="hl-code">, </span><span class="hl-identifier">insocket</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-identifier">target2in</span><span class="hl-code">.</span><span class="hl-identifier">setDaemon</span><span class="hl-brackets">(</span><span class="hl-reserved">true</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-identifier">target2in</span><span class="hl-code">.</span><span class="hl-identifier">start</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-brackets">}</span></pre></div>

<p class="paragraph">
もう一点、今回のサンプルの都合上重要なポイントがあります。clientはCONNECTメソッドの後に、そのまま同じTCPセッションを使ってSSL/TLSのハンドシェイクを始めます。ということは、clientとの接続をCONNECTメソッドの後も持続させる必要があります。
<br />
しかし、HttpServiceのhandleRequest()メソッドの中では、最後にKeep-Aliveを律儀にチェックして解釈し、Keep-AliveでなければclientとのSocketのclose処理を行なっています。今回はHTTPヘッダを超手抜きでいい加減に組んでいるため、CONNECTに対する200レスポンスがKeep-Aliveでないと解釈されcloseされてしまいます。
<br />
そこで AlwaysConnectionReuseStrategy というクラスを独自に用意し、常に「これはKeep-Aliveなのでcloseしないでね」とするようにしています。HttpServiceのインスタンスを作成している、IncommingListenerの以下の箇所になります。
<br />
</p>
<div class="hl-main"><pre><span class="hl-comment">//</span><span class="hl-comment"> Set up the HTTP service</span><span class="hl-comment"></span><span class="hl-code">
        </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">httpService</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">HttpService</span><span class="hl-brackets">(</span><span class="hl-code">
                </span><span class="hl-identifier">inhttpproc</span><span class="hl-code">, 
                </span><span class="hl-comment">//</span><span class="hl-comment"> new DefaultConnectionReuseStrategy(), </span><span class="hl-comment"></span><span class="hl-code">
                </span><span class="hl-comment">//</span><span class="hl-comment"> -&gt;</span><span class="hl-comment"></span><span class="hl-code">
                </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">AlwaysConnectionReuseStrategy</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">, 
                </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">DefaultHttpResponseFactory</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">,
                </span><span class="hl-identifier">reqistry</span><span class="hl-code">,
                </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">params</span><span class="hl-brackets">)</span><span class="hl-code">;</span></pre></div>

<p class="paragraph">
その他つまづいた点：
<br />
</p>
<ul><li> やっぱりHttpService#handleRequest()の中でclientとの接続をclose()されていることに気づくまでに時間がかかった。何度も何度も動作確認してみて、どうしてもアプリ側のコードだけではTCP中継モードに切り替わった時点ですでにclientとのSocketがcloseされてしまう原因が分からなくて、HttpCoreのソースコードを読んでようやく理解した。一般的なアプリケーションであればそれくらい「気を利かせて」くれたほうが便利なのだろうけど、Proxyみたいにもう少し低レイヤーを触るアプリの場合は余計なお世話になっちゃってる。</li>
<li> TCPを中継するのに、NIO無しでは2スレッド必要になるのに気が付かず、だいぶ長い時間1スレッドでRead/Write x 2 してたが、どうしても片方のReadで止まってしまい（当たり前の話）、ようやく「あ、2スレッド必要か」と気づいた次第。<ul><li> NIO有りなら1スレッドでいけるかな？でも出来たとしてもかなり読みづらいコードになりそう。</li></ul></li>
<li> 最初、this.inconn.close()をhandleRequest()の後に入れてなかった。それだとcurlで確認した時、今度は強制的にcloseなしになったので、出力がflushされないのか？curlの方にレスポンスが表示されなかった。そのため、とりあえずHTTPS切り替えが無ければ強制的にcloseして出力をflushさせることに。</li></ul>

<h3 id="ida407ae">HTTPS Proxyを組み立ててみる（HTTPSの中にも触れる）</h3>

<p class="paragraph">
いよいよBurpSuiteやDoormanがやっているように、HTTPSの中にもアクセスできるHTTPS Proxyを組み立ててみます。ちなみに今回のサンプルの実装はDoormanのソースをヒントにしています。BurpSuiteについては同じ仕組なのか、それとも別方式なのかは不明。
<br />
</p>

<p class="paragraph">
基本的な考え方としては、TCP中継モードに入るところは同じで、ただし中継先がアプリが用意したHTTPSサーバになります。このHTTPSサーバの中で実際の接続先HTTPSサーバにProxyします。アプリが用意したHTTPSサーバは事実上のMITM Proxyとなり、HTTPSメッセージの中にアクセスすることが可能となります。今回のサンプルでは以下の図のような構成にしました。
<br />
</p>

<p class="paragraph">
<a href="./../images/https_proxy_exercise/https_proxy_exercise_04.png" title="" target="_blank"><img src="./../images/https_proxy_exercise/https_proxy_exercise_04.png" alt="" title=""  /></a>
<br />
</p>

<p class="paragraph">
TlsRequestListenerとTlsWorkerについては、実験用のHTTP/HTTPSサーバを組み立てた時のTlsRequestListenerとWorkerThreadの使い回しになります。注意が必要なのは次の2点です。
<br />
</p>
<ul><li> 内部のMITM Proxyは本来なら実際の接続先ごとにFactoryやManagerなどで管理すべきだが、今回はそこまで組まず、実験用に組み立てた localhost:8081 のHTTPSサーバ専用としている。<ul><li> 実用レベルを考えるなら接続先ごとに証明書を動的に生成してそれを提示するようにすべきだが、今回はそこまで組んでいない。</li></ul></li>
<li> TlsHandlerについては、接続先がInvalidなサーバ証明書を提示してきてもスルーするように組み立てています。特に今回は、実験用に組み立てたHTTPSサーバに接続することを最初から前提としていますので、自己署名の証明書をスルーする必要があることが自明です。</li></ul>

<p class="paragraph">
TlsHandlerは以下のような作りにしました。
<br />
</p>
<div class="hl-main"><pre><span class="hl-reserved">public</span><span class="hl-code"> </span><span class="hl-reserved">class</span><span class="hl-code"> </span><span class="hl-identifier">TlsHandler</span><span class="hl-code"> </span><span class="hl-reserved">implements</span><span class="hl-code"> </span><span class="hl-identifier">HttpRequestHandler</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span class="hl-comment">//</span><span class="hl-comment"> ...</span><span class="hl-comment"></span><span class="hl-code">
    </span><span class="hl-comment">//</span><span class="hl-comment"> サーバ証明書の検証をスルーするためのSSLContextとSSLSocketFactory</span><span class="hl-comment"></span><span class="hl-code">
    </span><span class="hl-reserved">protected</span><span class="hl-code"> </span><span class="hl-identifier">SSLContext</span><span class="hl-code"> </span><span class="hl-identifier">sslContext</span><span class="hl-code">;
    </span><span class="hl-reserved">protected</span><span class="hl-code"> </span><span class="hl-identifier">SSLSocketFactory</span><span class="hl-code"> </span><span class="hl-identifier">sslSocketFactory</span><span class="hl-code">;
 
    </span><span class="hl-reserved">public</span><span class="hl-code"> </span><span class="hl-identifier">TlsHandler</span><span class="hl-brackets">(</span><span class="hl-identifier">String</span><span class="hl-code"> </span><span class="hl-identifier">_targetHost</span><span class="hl-code">, </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">_targetPort</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-reserved">try</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-comment">//</span><span class="hl-comment"> サーバ証明書の検証をスルーするための専用のTrustManagerの準備</span><span class="hl-comment"></span><span class="hl-code">
            </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">sslContext</span><span class="hl-code"> = </span><span class="hl-identifier">SSLContext</span><span class="hl-code">.</span><span class="hl-identifier">getInstance</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">TLSv1</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-identifier">TrustManager</span><span class="hl-code"> </span><span class="hl-identifier">tm</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">X509TrustManager</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-reserved">public</span><span class="hl-code"> </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">checkClientTrusted</span><span class="hl-brackets">(</span><span class="hl-identifier">X509Certificate</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-code"> </span><span class="hl-identifier">chain</span><span class="hl-code">,
                        </span><span class="hl-identifier">String</span><span class="hl-code"> </span><span class="hl-identifier">authType</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-reserved">throws</span><span class="hl-code"> </span><span class="hl-identifier">CertificateException</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-brackets">}</span><span class="hl-code">
 
                </span><span class="hl-reserved">public</span><span class="hl-code"> </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">checkServerTrusted</span><span class="hl-brackets">(</span><span class="hl-identifier">X509Certificate</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-code"> </span><span class="hl-identifier">chain</span><span class="hl-code">,
                        </span><span class="hl-identifier">String</span><span class="hl-code"> </span><span class="hl-identifier">authType</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-reserved">throws</span><span class="hl-code"> </span><span class="hl-identifier">CertificateException</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-brackets">}</span><span class="hl-code">
 
                </span><span class="hl-reserved">public</span><span class="hl-code"> </span><span class="hl-identifier">X509Certificate</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-code"> </span><span class="hl-identifier">getAcceptedIssuers</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                    </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-reserved">null</span><span class="hl-code">;
                </span><span class="hl-brackets">}</span><span class="hl-code">
            </span><span class="hl-brackets">}</span><span class="hl-code">;
            </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">sslContext</span><span class="hl-code">.</span><span class="hl-identifier">init</span><span class="hl-brackets">(</span><span class="hl-reserved">null</span><span class="hl-code">, </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">TrustManager</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code"> </span><span class="hl-identifier">tm</span><span class="hl-code"> </span><span class="hl-brackets">}</span><span class="hl-code">, </span><span class="hl-reserved">null</span><span class="hl-brackets">)</span><span class="hl-code">;
            </span><span class="hl-comment">//</span><span class="hl-comment"> サーバ証明書の検証をスルーする設定のSSLSocketFactoryの生成</span><span class="hl-comment"></span><span class="hl-code">
            </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">sslSocketFactory</span><span class="hl-code"> = </span><span class="hl-identifier">sslContext</span><span class="hl-code">.</span><span class="hl-identifier">getSocketFactory</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">catch</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">Exception</span><span class="hl-code"> </span><span class="hl-identifier">e</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
            </span><span class="hl-identifier">e</span><span class="hl-code">.</span><span class="hl-identifier">printStackTrace</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
    </span><span class="hl-brackets">}</span><span class="hl-code">
 
    @</span><span class="hl-identifier">Override</span><span class="hl-code">
    </span><span class="hl-reserved">public</span><span class="hl-code"> </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">handle</span><span class="hl-brackets">(</span><span class="hl-code">
            </span><span >final</span><span class="hl-code"> </span><span class="hl-identifier">HttpRequest</span><span class="hl-code"> </span><span class="hl-identifier">request</span><span class="hl-code">, 
            </span><span >final</span><span class="hl-code"> </span><span class="hl-identifier">HttpResponse</span><span class="hl-code"> </span><span class="hl-identifier">response</span><span class="hl-code">,
            </span><span >final</span><span class="hl-code"> </span><span class="hl-identifier">HttpContext</span><span class="hl-code"> </span><span class="hl-identifier">context</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-reserved">throws</span><span class="hl-code"> </span><span class="hl-identifier">HttpException</span><span class="hl-code">, </span><span class="hl-identifier">IOException</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
 
        </span><span class="hl-comment">//</span><span class="hl-comment"> サーバ証明書の検証をスルーするSSLSocketFactoryでSocket生成</span><span class="hl-comment"></span><span class="hl-code">
        </span><span class="hl-identifier">Socket</span><span class="hl-code"> </span><span class="hl-identifier">outsocket</span><span class="hl-code"> = </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">sslSocketFactory</span><span class="hl-code">.</span><span class="hl-identifier">createSocket</span><span class="hl-brackets">(</span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">targetHost</span><span class="hl-code">, </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">targetPort</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">DefaultHttpClientConnection</span><span class="hl-code"> </span><span class="hl-identifier">outconn</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">DefaultHttpClientConnection</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">outconn</span><span class="hl-code">.</span><span class="hl-identifier">bind</span><span class="hl-brackets">(</span><span class="hl-identifier">outsocket</span><span class="hl-code">, </span><span class="hl-reserved">this</span><span class="hl-code">.</span><span class="hl-identifier">params</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">System</span><span class="hl-code">.</span><span class="hl-identifier">out</span><span class="hl-code">.</span><span class="hl-identifier">println</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">Outgoing connection to </span><span class="hl-quotes">&quot;</span><span class="hl-code"> + </span><span class="hl-identifier">outsocket</span><span class="hl-code">.</span><span class="hl-identifier">getInetAddress</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">;</span></pre></div>

<p class="paragraph">
実際の接続先については、TlsRequestListenerのコンストラクタに渡した値が、TlsHandlerまで渡されるようにしています。
<br />
今回はServerクラスで予めTlsRequestListenerのスレッドを起動してしまいます。
<br />
Server.java:
<br />
</p>
<div class="hl-main"><pre><span class="hl-reserved">public</span><span class="hl-code"> </span><span class="hl-reserved">class</span><span class="hl-code"> </span><span class="hl-identifier">Server</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
 
    </span><span class="hl-reserved">public</span><span class="hl-code"> </span><span >static</span><span class="hl-code"> </span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span class="hl-identifier">String</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-code"> </span><span class="hl-identifier">args</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-reserved">throws</span><span class="hl-code"> </span><span class="hl-identifier">Exception</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">Thread</span><span class="hl-code"> </span><span class="hl-identifier">t</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">IncommingListener</span><span class="hl-brackets">(</span><span class="hl-number">8888</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">t</span><span class="hl-code">.</span><span class="hl-identifier">setDaemon</span><span class="hl-brackets">(</span><span class="hl-reserved">false</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">t</span><span class="hl-code">.</span><span class="hl-identifier">start</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">Thread</span><span class="hl-code"> </span><span class="hl-identifier">t2</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">TlsRequestListener</span><span class="hl-brackets">(</span><span class="hl-number">8889</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">localhost</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-number">8081</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">t2</span><span class="hl-code">.</span><span class="hl-identifier">setDaemon</span><span class="hl-brackets">(</span><span class="hl-reserved">true</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-identifier">t2</span><span class="hl-code">.</span><span class="hl-identifier">start</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
    </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span class="hl-brackets">}</span></pre></div>

<p class="paragraph">
ProxyHandlerでは以下の箇所で、localhost:8081 への接続についてのみここまでで準備してきたTlsRequestListenerを通すように分岐させています。
<br />
</p>
<div class="hl-main"><pre><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">switchToHttps</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-comment">//</span><span class="hl-comment"> ...</span><span class="hl-comment"></span><span class="hl-code">
                </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">localhost</span><span class="hl-quotes">&quot;</span><span class="hl-code">.</span><span class="hl-identifier">equals</span><span class="hl-brackets">(</span><span class="hl-identifier">targetHost</span><span class="hl-brackets">)</span><span class="hl-code"> &amp;&amp; </span><span class="hl-number">8081</span><span class="hl-code"> == </span><span class="hl-identifier">targetPort</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                    </span><span class="hl-comment">//</span><span class="hl-comment"> 内部のMITM Proxy(TlsRequestListener)に接続</span><span class="hl-comment"></span><span class="hl-code">
                    </span><span class="hl-identifier">targetSocket</span><span class="hl-code"> = </span><span class="hl-reserved">new</span><span class="hl-code"> </span><span class="hl-identifier">Socket</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">localhost</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-number">8889</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">else</span><span class="hl-code"> </span><span class="hl-brackets">{</span></pre></div>

<p class="paragraph">
つまづいた所：
<br />
</p>
<ul><li> SSLSocketFacotryは、&quot;javax.net.ssl.SSLSocketFactory&quot; になります。&quot;org.apache.http.conn.ssl.SSLSocketFactory&quot;はHttpClientを活用した時に使います。今回はHttpCoreのみで、Socketの生成についてはHttpCoreは関与しませんので、JREが提供するjavax.net.ssl.SSLSocketFactoryからのSocket生成になります。<ul><li> HttpsURLConnectionやHttpClientは使いませんので、HostnameVerifierの設定は不要です。ホスト名の検証を行う箇所は今回のサンプルの範囲ではアプリ独自に実装する範囲であり、思いっきりスルーしてます。</li></ul></li></ul>

<h3 id="id7ff36c">curlでの実験</h3>

<p class="paragraph">
最初に実験用のHTTP/HTTPSサーバを起動します。ポート番号はHTTPが8080, HTTPSが8081でハードコードしています。
<br />
以下のcurlコマンドで確認できます。
<br />
</p>
<pre>HTTP:
$ curl http://localhost:8080/
HTTPS: サーバ証明書の検証をスキップするため &quot;-k&quot; オプションを指定
$ curl -k https://localhost:8081/
</pre>

<p class="paragraph">
続いてHTTP/HTTPS Proxyを起動します。ポート番号は8888での待受にハードコードしています。&quot;-x&quot; でProxyのホスト名とポート番号を指定します。
<br />
</p>
<pre>HTTP:
$ curl -x localhost:8888 http://localhost:8080/
HTTPS:
$ curl -k -x localhost:8888 https://localhost:8081/
</pre>

<hr />
<p class="paragraph">
SSLEngineとか、証明書の生成とかはまた後日、体力と気力のあるときに隙を見て実装してみます・・・。
<br />
</p>

<p class="paragraph">
今回はHttpCoreを使ってみたのですが、そもそもHttpCoreの概念、コンセプトの理解（というか復習。以前も軽く触ったことがあったので。）から始まったのが辛かったとです。
<br />
しかも素直にServerを組み分けじゃなくて、ProxyとかHTTPSとのつなぎ込みとかを行ったので、Socketなど低レイヤーの操作との折り合いをつける・・・というか、まずHttpCoreでその辺をどうしてるのか？とかその辺からだったのです。
<br />
ちょっとギャップが大きかったかも・・・。とはいえHTTPメッセージの処理と、ソケット入出力操作の組み合わせについてゼロからコーディングする気力も無かったのでこんなもんでしょうか。
<br />
</p>

<p class="paragraph">
というか図を描くのに5時間以上かかってます。図は・・・本当、読み手の立場から言えばあると助かるんですが、書き手の立場では非常に手間がかかるんですよね・・・。
<br />
あと図を描くのもMacBookAirで試してみたのですが(LibreOfficeのDraw使ってます)、タッチパッドだけだとさすがに辛い。範囲選択とか細かい部品のポイントとか繰り返してると、やっぱりマウスが無いと辛いですわ～。MagicMouse欲しくなっちゃいました。
<br />
</p>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/1077<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2001 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" target="_blank" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>