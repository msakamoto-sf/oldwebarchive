<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>技術/歴史/&quot;WindowsOS内部のアーキテクチャのすべて&quot;読書メモ/1-3章 - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">技術/歴史/&quot;WindowsOS内部のアーキテクチャのすべて&quot;読書メモ/1-3章</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-04-03 00:03:29 &nbsp; / &nbsp; last updated at: 2010-05-19 22:54:16<br>
カテゴリ: <a href="category-48.html">Assembler</a>&nbsp;<a href="category-8.html">Windows</a>&nbsp;<a href="category-46.html">読書</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-641.html" title="技術/歴史">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-634.html" title="技術/歴史/&quot;WindowsOS内部のアーキテクチャのすべて&quot;読書メモ/4章">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-23.html" title="技術">技術</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
&quot;WindowsOS内部のアーキテクチャのすべて&quot;の第１章～第３章の要約、読書メモとなります。
<br />
本記事では以降、&quot;WindowsOS内部のアーキテクチャのすべて&quot; を &quot;Windows OS Internal Architecture&quot; として &quot;WOIA&quot; と略します。
<br />
</p>

<a href="https://www.amazon.co.jp/dp/4886487270" target="_blank">Windows OS内部のアーキテクチャのすべて | 前川 武弘 |本 | 通販 | Amazon</a><br>



<ul><li><a href="#idfd5214">(1章) Intel 4004 (4bit時代, 1971 - )</a></li>
<li><a href="#idf180a7">(2章) Intel 8080 (8bit時代, 1974 - ) と BASIC, CP/M</a><ul><li><a href="#idd722e0">8008 (8bit, 1972 - )</a></li>
<li><a href="#id538859">8080 (8bit, 1974 - )</a></li>
<li><a href="#id3295b2">8080/Z80を搭載したマイコン製品とソフトウェア(BASIC, CP/M)</a></li>
<li><a href="#idb74b16">CP/M-80の構造</a><ul><li><a href="#idf6bd1d">メモリレイアウト(BIOS,BDOS,CCP,TPA および 0h - 100h)</a></li>
<li><a href="#id075f05">0h - 100h の詳細と8080/Z80の割り込み機能</a></li>
<li><a href="#id917acd">参考資料</a></li></ul></li></ul></li>
<li><a href="#idc117ac">(3章) Intel 8086/8088 (16bit時代, 1978 - ) と MS-DOS</a><ul><li><a href="#idd30314">8086/8088の概要</a><ul><li><a href="#id9cf4c1">レジスタ構成</a></li>
<li><a href="#id4947ae">割り込み機能</a></li>
<li><a href="#id30ea3d">メモリレイアウト</a></li>
<li><a href="#id917acd">参考資料</a></li></ul></li>
<li><a href="#id10e3af">86-DOS, IBM PC 5150, MS-DOSの誕生と640KBの壁(1981 - )</a></li>
<li><a href="#idc7fc5b">MS-DOSの構成</a><ul><li><a href="#id32b58b">MS-DOSのブート直前</a></li>
<li><a href="#id041dd0">MS-DOSのブート直後</a></li>
<li><a href="#idc82d23">IO.SYS, MSDOS.SYS, COMMAND.COMについて</a></li>
<li><a href="#id43740c">ソフトウェア割り込みによるシステムコールの仕組み</a></li>
<li><a href="#id917acd">参考資料</a></li></ul></li>
<li><a href="#id94fcad">Windows 1.0 の登場 (1985 - )</a></li>
<li><a href="#id16184e">Windows 2.0 の登場 (1987 - )</a></li></ul></li></ul>
<hr />
<h3 id="idfd5214">(1章) Intel 4004 (4bit時代, 1971 - )</h3>

<p class="paragraph">
1969年、日本のビジコンという会社の電卓用カスタムLSIの開発以来を受け、米Intelは汎用LSIの開発を開始。２年後の1971年、Intelは4004という型番で完成させた。他にROM(4001),RAM(4002),I/O(4003)を含む、一連のファミリーとして販売された。
<br />
</p>

<p class="paragraph">
1971年の時点ではIBMのSystem/360やOS/360、後継のSystem/370, OS/370が存在し、UNIXも既に産声を上げていた。ベル研究所ではKen ThompsonとDennis Ritchieらが 1970年 にはPDP-11/20上で動作するUNIXを開発していた。当時はアセンブラで開発されていたが、1973年にはC言語に移植されることになる。
<br />
</p>

<p class="paragraph">
4004のスペック：
<br />
</p>
<table>
	<tr>
		<td> アドレスバス </td>
		<td> 12bit/8bit </td>
	</tr>
	<tr>
		<td> 汎用レジスタ </td>
		<td> 4bit </td>
	</tr>
	<tr>
		<td> 外部データバス </td>
		<td> 4bit </td>
	</tr>
	<tr>
		<td> 内部データバス </td>
		<td> 4bit </td>
	</tr>
</table>

<p class="paragraph">
※当時はまだレジスタに名前は付いておらず、4bit x 16個のレジスタに対して番号で指定する「インデックス・レジスタ」だった。
<br />
※&quot;WOIA&quot;ではアドレスバス8bitとしているが、正確には<strong>プログラムROM(4001)のアドレス指定は12bit, RAM(4002)のアドレス指定は8bit</strong>として分かれていた。ROMのアドレス指定はA3(4bit) + A2(4bit) + A1(4bit)で12bitだった。
<br />
プログラムを格納するROM(4001)は8bit x 256。つまりアドレス範囲は丁度0h-FFhで8bit。つまり4001一つ分が、A2(4bit) + A1(4bit)で指定出来る範囲になる。アドレスバスは12bitなので4KBまで使える。つまりA3(4bit)で、最大16個の4001を切り替えることができた。
<br />
当時のジャンプ命令には、A3まで指定するジャンプと、A3を指定しない(A2 + A1の8bit指定)、同じ4001内でのジャンプ命令とで分かれていた。
<br />
RAM(4002)のアドレス指定は8bitだったが、先頭4bitはバンク切り替えなどで使われていた。
<br />
</p>

<p class="paragraph">
4004のアドレスバスを何bitと解釈するかは資料やWebサイトによって異なる。そもそも、まだアドレスバスという概念自体が確立していない時代のCPUである。次の資料では&quot;4bit&quot;という表記になっている。
<br />
</p>
<ul><li> cpu-collection.de &gt;&gt; Intel &gt;&gt; 4004<ul><li> <a class="externallink" href="http://www.cpu-collection.de/?tn=0&amp;l0=co&amp;l1=Intel&amp;l2=4004" target="_blank">http://www.cpu-collection.de/?tn=0&amp;l0=co&amp;l1=Intel&amp;l2=4004</a></li></ul></li></ul>

<p class="paragraph">
当時はまだアドレス専用のバスが存在していなかった為、4bitの内部データバスを使って 4bit x 2 or 4bit x 3 として読み取っていた。このため、データバス = アドレスバスと解釈すれば「アドレスバス = 4bit」という考え方も可能である。
<br />
</p>

<p class="paragraph">
また、当時はスタック領域がCPU内部に存在していた。4004では12bitのプログラムカウンタ + 3レベルの12bitスタックポインタで、計48bitの領域がCPU(4004)内部に確保されていた。
<br />
</p>

<h3 id="idf180a7">(2章) Intel 8080 (8bit時代, 1974 - ) と BASIC, CP/M</h3>

<p class="paragraph">
8bitCPUとして広まった8080について見てみる。
<br />
</p>

<h4 id="idd722e0">8008 (8bit, 1972 - )</h4>

<p class="paragraph">
8080 に入る前に、1972年発表の 8008 を見ておく。
<br />
8008のスペック：
<br />
</p>
<table>
	<tr>
		<td> アドレスバス </td>
		<td> 14bit/8bit </td>
	</tr>
	<tr>
		<td> 汎用レジスタ </td>
		<td> 8bit </td>
	</tr>
	<tr>
		<td> 外部データバス </td>
		<td> 8bit </td>
	</tr>
	<tr>
		<td> 内部データバス </td>
		<td> 8bit </td>
	</tr>
</table>

<p class="paragraph">
8008の時点では、まだアドレスバスとデータバスは区別されていない。アドレス自体は 14bit (=16KB) まで指定できたが、データバスは8bitだったため、8bitを二回読み込み、先頭2bitを捨てて14bitとしていた。
<br />
</p>

<p class="paragraph">
汎用レジスタはこの時に A, B, C, D, E, H, L の7つが名付けられた。このうち、HとLレジスタはメモリアドレスの指定に使われた。実際にHとLが関係する命令を見てみる。
<br />
</p>
<table>
	<tr>
		<td> Lr1r2 </td>
		<td> 11 DDD SSS </td>
		<td> 汎用レジスタSSSの値を汎用レジスタDDDに転送する。 </td>
	</tr>
	<tr>
		<td> LrM </td>
		<td> 11 DDD 111 </td>
		<td> メモリアドレス&quot;M&quot;の値を汎用レジスタDDDに転送する。 </td>
	</tr>
	<tr>
		<td> LMr </td>
		<td> 11 111 SSS </td>
		<td> 汎用レジスタSSSの値をメモリアドレス&quot;M&quot;に転送する。 </td>
	</tr>
</table>

<pre>SSS : Source Index Register
DDD : Destination Index Register
A(000), B(001), C(010), D(011), E(100), H(101), L(110)
</pre>

<p class="paragraph">
例えば
<br />
</p>
<pre>LrM : 11 010 111
</pre>
<p class="paragraph">
の場合は
<br />
</p>
<pre>汎用レジスタ H と L で指定されたアドレスの値を、汎用レジスタC(010)に転送する。
</pre>
<p class="paragraph">
となる。
<br />
ここでHとLが以下の値になっていた場合は、Hの上位2bitが捨てられ、Hの6bit + Lの8bitで14bitのアドレス213Fhになる。
<br />
</p>
<pre>H: 1110 0001 : 71h
L: 0011 1111 : 3Fh
→ 1110 0001 0011 1111
→   10 0001 0011 1111 (Hの上位2bitが落とされる)
→ アドレス：213Fh
</pre>

<p class="paragraph">
4004の時と同様、14bitのプログラムカウンタ + 3レベルの14bitスタックポインタで、計52bitの領域がCPU(8008)内部に確保されていた。
<br />
</p>

<p class="paragraph">
8008は日本の精工舎から依頼を受けて、科学技術計算用のLSIとして開発された。4004と比べてCPUのクロックもあまり変わらず、周辺チップの開発も怠った為、後の8080のようにマイコン市場を作り上げるようなことは無かった。
<br />
</p>

<h4 id="id538859">8080 (8bit, 1974 - )</h4>

<p class="paragraph">
8080は1974年発表の8bitCPU。発表年については資料によりばらつきがあり、おおよそ1974年であるが、一部 1973年12月 と表記している資料もある（intel 8080 Microcomputer Systems User&#039;s Manual）。
<br />
8080のスペック：
<br />
</p>
<table>
	<tr>
		<td> アドレスバス </td>
		<td> 16bit </td>
	</tr>
	<tr>
		<td> 汎用レジスタ </td>
		<td> 8bit </td>
	</tr>
	<tr>
		<td> 外部データバス </td>
		<td> 8bit </td>
	</tr>
	<tr>
		<td> 内部データバス </td>
		<td> 8bit </td>
	</tr>
</table>

<p class="paragraph">
8080になり、&quot;アドレスバス&quot;がデータバスとは独立して登場し、16bit = 64KB までのメモリが扱えるようになった。
<br />
汎用レジスタは A, B, C, D, E, H, L, W, Z が導入されている。プログラムカウンタも16bitになっている。
<br />
なお8080のGND配線の設計ミスを修正した 8080<strong>A</strong>という製品が発表されている。こちらの方がヒットしたため、&quot;8080&quot;と呼ぶ時に8080Aも含める場合もある。本記事もそれに従う。8080Aを設計した技術者が、後に独立し、ザイログ社を設立して互換CPU &quot;Z80&quot; を発表している。
<br />
</p>

<h4 id="id3295b2">8080/Z80を搭載したマイコン製品とソフトウェア(BASIC, CP/M)</h4>

<dl>
<dt> Altair8800 </dt>
<dd>1975年、MITSにより発表された8080を搭載したシンプルなマイコンキット。これに使われた&quot;S-100&quot;バスは8080系のミニコン・マイコンで標準装備として広まっていった。</dd>
<dt> Microsoft BASIC </dt>
<dd>1975年、Microsoft創業。Altair8800用のBASICを発売。</dd>
<dt> NEC TK-80 </dt>
<dd>1977年発表のZ80搭載ワンボードマイコン。</dd>
<dt> Tandy TRS-80 </dt>
<dd>1977年発表のZ80搭載マイコン。</dd>
<dt> NEC PC-8001 </dt>
<dd>1979年発表のマイコン。PC-8801, PC-6001, PC-6601と続く。</dd>
<dt> CP/M </dt>
<dd>
<p class="paragraph">
&quot;Control Program/Monitor&quot;, 後に &quot;Control Program for Microcomputers&quot; の略称となる。1973-1974年に Digital Research の Gary Kildall が開発したOS。CP/Mは後に幾つかのCPUに移植されることになり、8080用は&quot;CP/M-80&quot;と呼ばれるようになる。
<br />
CP/Mには&quot;ASM.COM&quot;というアセンブラが添付されているが、初代のCP/M自体はKildall自身が作成した&quot;Programming Language  for Microcomputers&quot;(PL/M)で開発された。
<br />
</p>

<p class="paragraph">
<strong>アドレス100hから始まる &quot;.COM&quot; 実行ファイルフォーマットは、少なくとも初代CP/Mまで遡る事が出来る。</strong>
<br />
</p></dd>
</dl>

<p class="paragraph">
8080/Z80で盛り上がったマイコン市場で、CP/Mもまた大いに広まった。CP/M上で動作するソフトウェアが開発され、Microsoftもまだこの時点ではCP/M上で動作するプログラミング言語(BASIC, COBOL, FORTRAN)の一ベンダでしかなかった。
<br />
</p>

<h4 id="idb74b16">CP/M-80の構造</h4>

<p class="paragraph">
MS-DOSの前身(DOS-86)の前身となったCP/Mの構造を俯瞰していく。
<br />
</p>

<h5 id="idf6bd1d">メモリレイアウト(BIOS,BDOS,CCP,TPA および 0h - 100h)</h5>

<p class="paragraph">
CP/M-80が動作している状態のメモリレイアウトは次のようになっている。
<br />
</p>
<pre class="plugin_pre">
+------------------------------+ FFFFh
| [BIOS]                       |
| Basic Input/Output System    |
| (Hadrware Drivers for BDOS)  |
+------------------------------+ F200h
| [BDOS]                       |
| Basic Disk Operating System  |
| (Operating System Functions) |
+------------------------------+ E400h
| [CCP]                        |
| Console Command Processor    |
| (Command Line Interpreter)   |
+------------------------------+ DC00h
| [TPA]                        |
| Transient Program Area       |
| (Free Memory for Programs)   |
+------------------------------+ 0100h
| CP/M System Area             |
| (System Buffers, Parameters) |
+------------------------------+ 0000h
</pre>

<dl>
<dt> BDOS </dt>
<dd>CP/Mのカーネル部分。CP/Mが提供するサービスルーチンが格納されている。</dd>
<dt> BIOS </dt>
<dd>ハードウェアを動作させる為のプログラムが格納されている。現在のBIOSとは別である。</dd>
<dt> CCP </dt>
<dd>ユーザインターフェイスであるシェルプログラムが格納されている。(MS-DOSのCOMMAND.COMに相当)</dd>
<dt> TPA </dt>
<dd>ユーザープログラムがロードされる領域</dd>
<dt> CP/M System Area </dt>
<dd>ブート用の機械語やBDOSのサービスルーチンを呼び出す為の一覧表（割り込みベクタテーブル）、カーネルの使うバッファ領域など。</dd>
</dl>

<p class="paragraph">
&quot;Basic Disk Operating System&quot; の名前が示すとおり、CP/Mは基本的に磁気ディスクを使うOSだった。
<br />
bootには別途bootloaderを格納したROMが必要で、CPUは最初はそのROMの0000hから起動して周辺機器を初期化、続いて磁気ディスクの先頭を読み込み、上記で示した各CP/MのシステムをRAM上に展開していく。展開が終了するとRAM上の0000hの命令をフェッチするようになっており、この時点でF200hへのJMP命令、つまりBIOSへのJMP命令が格納されていた。これによりBIOSに制御が移り、CP/MのOSの世界へ切り替わる。
<br />
bootloaderを格納したROMが無い場合は、スイッチなどを操作して直接bootloaderに相当する機械語を打ち込んでCP/Mをロードさせていたようだ。
<br />
</p>

<p class="paragraph">
なお、&quot;BIOS&quot;/&quot;BDOS&quot;/&quot;CCP&quot;についてだが<strong>相当する物理的なファイルは存在しない。</strong>CP/Mをロードする過程で磁気ディスクから読み取ったシステムデータをメモリに展開する際に、機能上の理由でこの3種類のモジュールに分類しているだけである。
<br />
上の図では64KB全て搭載されている前提でアドレスを載せているが、実際のマシンでは32KBや48KBなど異なる場合があった。
<br />
CP/Mのドキュメントにはそれぞれのメモリレイアウトに応じて調整可能なbootloaderのアセンブラコードが掲載されており、自分のマシンとそれを見比べつつ、手動でbootloaderを組み上げていったものと思われる。
<br />
</p>

<h5 id="id075f05">0h - 100h の詳細と8080/Z80の割り込み機能</h5>

<pre class="plugin_pre">
+----------------------------+&lt;- 0100h
| File Buffer                |&lt;- 0080h - 00FFh
+----------------------------+
| FCB:                       |
| Default File Control Block |&lt;- 0060h -
+----------------------------+
| Unused (in CP/M 2.2)       |&lt;- 0050h - 
+----------------------------+
| BIOS Work Area             |&lt;- 0040h - 
+----------------------------+
| Restart Vector 7           |&lt;- 0038h - 003Fh
+----------------------------+
| Restart Vector 6           |&lt;- 0030h - 0037h
| Restart Vector 5           |&lt;- 0028h - 002Fh
| Restart Vector 4           |&lt;- 0020h - 0027h
| Restart Vector 3           |&lt;- 0018h - 001Fh
| Restart Vector 2           |&lt;- 0010h - 0017h
| Restart Vector 1           |&lt;- 0008h - 000Fh
+----------------------------+
| &quot;JMP E400h&quot;                |&lt;- 0005h - 0007h
+----------------------------+
| Current Default Drive      |&lt;- 0004h
+----------------------------+
| IO Byte                    |&lt;- 0003h
+----------------------------+
| &quot;JMP F200h&quot;                |&lt;- 0000h - 0002h
+----------------------------+
</pre>

<p class="paragraph">
最初の &quot;JMP F200h&quot; 命令はCPU初期化などで&quot;0000h&quot;の命令がフェッチされた場合に、BIOSコードを実行してメモリをリセットするためにある。
<br />
次のIO Byte, Current Default Drive についての説明は省略する。
<br />
0005hの &quot;JMP E400h&quot; 命令はBDOSコードの先頭へJMPする命令になり、これがOSの機能を呼び出す「システムコール」(DOSでは&quot;ファンクションコール&quot;とも呼ばれる)となる。
<br />
ユーザープログラムでは次のような手順で、0005hの &quot;JMP E400h&quot; 命令を通してOSの機能を呼ぶことが出来る。
<br />
例：&quot;A&quot;という文字を表示したい時
<br />
</p>
<ol><li> 65(ASCIIコード&quot;A&quot;)をAレジスタ(Z80のAccumulator)にセット</li>
<li> 02h(BDOSサービス番号で、文字の出力)をCレジスタにセット</li>
<li> &quot;CALL 0005h&quot;を実行</li></ol>

<p class="paragraph">
&quot;Restart Vector 1 - 7&quot;については、8080の割り込み機能と併せて簡単に紹介する。
<br />
8080における割り込みはハードウェアからのイベントによるハードウェア割り込みしか存在しなかった。
<br />
仕組みとしては、割り込み要求を出した装置がISR(Interrupt Service Routine)をコールする命令を返し、それをフェッチして実行することで割り込みハンドラを実行する仕組みになっていた。
<br />
この「ISRをコールする命令」が&quot;RST&quot;(ReSTart)命令で、実行する割り込みハンドラを8個選択出来るようになっていた。
<br />
</p>
<pre>&quot;RST&quot;(ReSTart) : 11 AAA 1111
</pre>
<p class="paragraph">
この&quot;AAA&quot;の3bit、8つのISRを指すことが出来る。
<br />
ISRのアドレスは、アドレス0000hから始まる8バイトのブロック単位で指定可能になっていた。
<br />
つまり、割り込み要求を出した装置が
<br />
</p>
<pre>11 000 1111
</pre>
<p class="paragraph">
を返すと、
<br />
</p>
<pre>0000h - 0007h
</pre>
<p class="paragraph">
に格納されたアドレスに飛ぶ。
<br />
8バイト毎に8つなので、以下のアドレスに飛び先、つまりISRのアドレスが格納出来る。
<br />
</p>
<pre>0000h - 0007h, 0008h - 000Fh,
0010h - 0017h, 0018h - 001Fh,
0020h - 0027h, 0028h - 002Fh,
0030h - 0037h, 0038h - 003Fh,
</pre>
<p class="paragraph">
このうち最初の 0000h - 0007h はCP/Mに割り込み以外の用途に使われ、最後の一つ0038hはデバッガ用に予約されていた。当時のマシンには「デバッグ」ボタンが存在し、ユーザーがこのボタンを押すとハードウェアで割り込みがかかり、
<br />
</p>
<pre>RST: 11 111 1111
</pre>
<p class="paragraph">
が返されてデバッガが動作するようになっていたらしい。
<br />
残り6つについては、少なくとも初期のCP/Mでは使っていない。ユーザプログラム側で任意のISRアドレスを指定することが可能だった。
<br />
</p>

<p class="paragraph">
ちなみに8008の段階では割り込み機能は搭載されていない。8080と、同1974年リリースの4004強化版である&quot;4040&quot;において、Intel CPUで割り込み機能が搭載された。8080互換であるZ80は、さらに独自の割り込みモードを備え、8080互換(モード0)の他に2つの割り込みモードを使えるように拡張されていた。
<br />
</p>

<p class="paragraph">
OSが提供するサービス(ファンクション)を割り込み機能(あるいは &quot;CALL 0005h&quot; のような特定のゲートウェイ)を通じて呼ぶ仕組みは、x86のOSの歴史ではCP/Mで初登場となる。
<br />
</p>

<ol><li> ユーザプログラムから &quot;CALL 0005h&quot; が呼ばれる、あるいはハードウェア割り込みが発生する。</li>
<li> 0005h番地の &quot;JMP E400h&quot; 命令によりBDOSへジャンプする、あるいはISRを指定するRST命令をフェッチする。</li>
<li> BDOSあるいはISRの処理が実行される。</li></ol>

<pre class="plugin_pre">
+------------------------------+ FFFFh
| [BIOS]                       |
+------------------------------+ F200h
| [BDOS]                    (3)|&lt;-----------+
+------------------------------+ E400h      |
| [CCP]                        |            |
+------------------------------+ DC00h      |
| [TPA]                     (1)|--------+   |
+------------------------------+ 0100h  |   |
| CALL 0005h,            (2)+-&lt;|&lt;-------+   |
| ResetVector 1 - 7         +-&gt;|&gt;-----------+
+------------------------------+ 0000h
</pre>

<p class="paragraph">
このようにユーザプログラムとOSの機能を分けた理由としては、当時はまだ細かいメモリレイアウトやハードウェアの仕様が共通化されて居らず、マイコン・ミニコン毎にROMやRAM、周辺機器の仕様が異なっており、それを全てユーザプログラムでカバーするのが不可能だったからであると考えられる。
<br />
OSの基本機能や周辺機器の差異はBDOS + BIOSが吸収することにより、ユーザプログラムの負担を低減出来る。ユーザプログラムは周辺機器の詳細を考えずに、単にOSのサービスを呼ぶだけでよい。
<br />
もちろんユーザプログラム自身が直接ハードウェアを制御したい場合もあり得るが、この構成にすることでハードウェア周りの処理の多くをOS側に委譲出来たのは確かである。
<br />
</p>

<p class="paragraph">
そしてこの割り込みを使った処理の分離が、その後のMS-DOSやWindowsまで連綿と引き継がれていくことになる。
<br />
</p>

<h5 id="id917acd">参考資料</h5>

<ul><li> 基礎から学ぶコンピュータ<ul><li> <a class="externallink" href="http://rryu.sakura.ne.jp/compfund/" target="_blank">http://rryu.sakura.ne.jp/compfund/</a><ul><li> 「マイクロプロセッサ編」第３８～第４３号の割り込みの記事</li></ul></li></ul></li>
<li> CP/M Main Page<ul><li> <a class="externallink" href="http://www.seasip.demon.co.uk/Cpm/" target="_blank">http://www.seasip.demon.co.uk/Cpm/</a></li></ul></li>
<li> The Unofficial CP/M Web Site<ul><li> <a class="externallink" href="http://www.cpm.z80.de/" target="_blank">http://www.cpm.z80.de/</a></li></ul></li>
<li> CP/M Internals<ul><li> <a class="externallink" href="http://www.dcast.vbox.co.uk/cpm.html" target="_blank">http://www.dcast.vbox.co.uk/cpm.html</a><ul><li> 本章で使ったCP/Mのメモリレイアウトは、このページの図を参考にしました。</li></ul></li></ul></li>
<li> Wikipedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/CP/M" target="_blank">http://en.wikipedia.org/wiki/CP/M</a></li>
<li> <a class="externallink" href="http://ja.wikipedia.org/wiki/CP/M" target="_blank">http://ja.wikipedia.org/wiki/CP/M</a></li></ul></li></ul>

<h3 id="idc117ac">(3章) Intel 8086/8088 (16bit時代, 1978 - ) と MS-DOS</h3>

<p class="paragraph">
8086(1978年)のスペック：
<br />
</p>
<table>
	<tr>
		<td> アドレスバス </td>
		<td> 20bit </td>
	</tr>
	<tr>
		<td> 汎用レジスタ </td>
		<td> 16bit </td>
	</tr>
	<tr>
		<td> 外部データバス </td>
		<td><strong>16bit</strong></td>
	</tr>
	<tr>
		<td> 内部データバス </td>
		<td> 16bit </td>
	</tr>
</table>

<p class="paragraph">
8088(1979年)のスペック：
<br />
</p>
<table>
	<tr>
		<td> アドレスバス </td>
		<td> 20bit </td>
	</tr>
	<tr>
		<td> 汎用レジスタ </td>
		<td> 16bit </td>
	</tr>
	<tr>
		<td> 外部データバス </td>
		<td><strong>8bit</strong></td>
	</tr>
	<tr>
		<td> 内部データバス </td>
		<td> 16bit </td>
	</tr>
</table>

<ul><li> 8086を発表するも、8080時代の外部データバス8bitに合わせた周辺機器がまだ多く出回っていた為、外部データバスを8bitにした8088を1979年に発表している。</li>
<li> アドレスバスについては20bit、1MBまで指定出来るよう拡張されている。汎用レジスタや内部データバスも16bit化された。</li>
<li> 8086/8088こそが、現代のx86(32bit)アーキテクチャの先祖である IBM PC 5150 で採用されたCPU(正確には8088)であり、MS-DOSやWindowsの起点である。</li></ul>

<h4 id="idd30314">8086/8088の概要</h4>

<p class="paragraph">
8086/8088のレジスタ構成、割り込み機能、想定するメモリレイアウトの順に簡単に紹介する。
<br />
</p>

<h5 id="id9cf4c1">レジスタ構成</h5>

<p class="paragraph">
8086/8088のレジスタ群(全て16bit, &quot;xH&quot;, &quot;xL&quot;は上位/下位の8bitでアクセスする時のレジスタ名)
<br />
</p>
<pre class="plugin_pre">
+---------+                     +---------+
| AH | AL |=AX : ACCUMULATOR    |   S P   | STACK POINTER
+---------+                     +---------+
| BH | BL |=BX : BASE           |   B P   | BASE POINTER
+---------+                     +---------+
| CH | CL |=CX : COUNT          |   S I   | SOURCE INDEX
+---------+                     +---------+
| DH | DL |=DX : DATA           |   D I   | DESTINATION INDEX
+---------+                     +---------+

+---------+                     +---------+
|   C S   | CODE SEGMENT        |   I P   | INSTRUCTION POINTER
+---------+                     +---------+
|   D S   | DATA SEGMENT        |   FLAG  | STATUS FLAGS
+---------+                     +---------+
|   S S   | STACK SEGMENT
+---------+
|   E S   | EXTRA SEGMENT
+---------+
</pre>

<p class="paragraph">
アドレスバスが20bitになったにも関わらず、IPやSPなどアドレスを指示するレジスタは16bitのままである。これは8086/8088で導入された「セグメント：オフセット」形式のアドレス換算により20bitに変換出来る。
<br />
8086/8088では、メモリアドレスを16bitのセグメントと、16bitのオフセットを使って指定する。20bitへの変換には、セグメントアドレスを4bit左にずらした上で、オフセットアドレスを加算する。
<br />
</p>
<pre>セグメント：1234h
オフセット：5678h
→ 12340h
 +  5678h
 --------
   179B8h ：これが物理メモリアドレスになる。
</pre>
<p class="paragraph">
SPやIPなどはこのオフセットを指定する事になる。一方のセグメントを指定するのが、CS/DS/SS/ESとなる。種類を分け、命令やスタック領域用にセグメントを分けることが出来るようになっている。
<br />
</p>
<pre>CS : IP → 次にフェッチする機械語の物理メモリアドレス
SS : SP → スタックポインタの物理メモリアドレス
</pre>
<p class="paragraph">
DSやESはその他の機械語命令で使われる。
<br />
</p>

<p class="paragraph">
一つのセグメントで指定可能な範囲はオフセットアドレス16bitの範囲内。<strong>64KBの壁</strong>はこの時誕生した。
<br />
</p>

<h5 id="id4947ae">割り込み機能</h5>

<p class="paragraph">
8080では割り込み要求を出した装置が&quot;RST&quot;(ReSTart)命令を返し、それをフェッチすることでISR(Interrupt Service Routine)を実行していた。また、RST命令ではISRを0-7の番号(3bit)で指定するようになっていて、物理アドレス0000hから8バイト毎に実際のISRのアドレスを格納する、間接的な指定方式を採っていた。
<br />
また、8080ではハードウェアによる割り込みのみ対応していた。
<br />
</p>

<p class="paragraph">
8086/8088になって、&quot;INT&quot;命令によるソフトウェア割り込みが可能になった。ISRの指定方式は8080を継承している。
<br />
ソフトウェア割り込みの場合は、8bitで指定出来る割り込み番号を4倍した値をメモリアドレスとして、そこに格納されている値をISRのアドレスとしてジャンプする。
<br />
ハードウェア割り込みの場合は、割り込みコントローラの返す割り込み番号を同様に4倍し、ソフトウェア割り込みと同様にISRのアドレスを割り出してジャンプする。
<br />
</p>

<pre>例：ハードウェア or ソフトウェア割り込みで割り込み番号が3だった時
3 x 4 = 12 → 0000Ch のアドレスに格納されている値を読み出し、そこにジャンプする。
</pre>
<p class="paragraph">
一つの割り込み番号に対して4バイト確保されており、2バイトで分かれてCS, IPレジスタにセットされることでISRにジャンプしている。
<br />
</p>

<p class="paragraph">
資料によっては、割り込みの発生源に応じて割り込みの呼称を変えている。
<br />
</p>
<ul><li> 例外割り込み<ul><li> トラップ：&quot;INT&quot;命令によるソフトウェア割り込み</li>
<li> フォールト：0除算や無効な値を扱った場合</li>
<li> アボート：致命的なエラー, ダブルフォールトやコプロセッサの異常</li></ul></li>
<li> ハードウェア割り込み：キーボードやタイマーなど周辺機器からの割り込み発生</li></ul>

<p class="paragraph">
割り込み番号 00h - 1Fh まではIntelによる予約となっているが、初期は守られておらず、一部OS固有の割り込みハンドラとして使われた。例えばIBM PC 5150のROM BIOSではROM BASICをロードする機能が INT 18h に割り当てられていたが、当然これはROM BASICを搭載したマシン専用であり、現在は使われていないか、別の機能が割り当てられたりしている。
<br />
</p>

<h5 id="id30ea3d">メモリレイアウト</h5>

<p class="paragraph">
8086/8088がCPUとして想定するメモリレイアウトは次のようになっている。
<br />
</p>
<pre class="plugin_pre">
+--------------------+
| RESET BOOTSTRAP    |
| PROGRAM JUMP       | FFFF0h - FFFFFh
+--------------------+
|                    |
|                    |
|                    |
+--------------------+
| INTERRUPT POINTER  |
| FOR TYPE 255       | 3FCh - 3FFh
+--------------------+
| (...)              |
+--------------------+
| INTERRUPT POINTER  |
| FOR TYPE 1         | 4h - 7h
+--------------------+
| INTERRUPT POINTER  |
| FOR TYPE 0         | 0h - 3h
+--------------------+
</pre>
<p class="paragraph">
先頭から400h(1KB)まではこのように割り込み番号に応じたISRのアドレステーブル(割り込みベクタ)として予約されている。
<br />
&quot;RESET BOOTSTRAP PROGRAM JUMP&quot;の16バイトだが、ここは8086/8088が電源リセットの直後、最初に命令をフェッチするアドレスである。これはMS-DOSやIBM PC 5150 ROM BIOSのメモリレイアウトに関わってくる。
<br />
</p>

<h5 id="id917acd">参考資料</h5>

<p class="paragraph">
割り込み番号：
<br />
</p>
<ul><li> BIOS interrupt call<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/BIOS_interrupt_call" target="_blank">http://en.wikipedia.org/wiki/BIOS_interrupt_call</a></li></ul></li></ul>

<h4 id="id10e3af">86-DOS, IBM PC 5150, MS-DOSの誕生と640KBの壁(1981 - )</h4>

<p class="paragraph">
86-DOS, IBM PC 5150, MS-DOSの流れについては <a href="./view-614.html" >Assembler/なぜx86ではMBRが&quot;0x7C00&quot;にロードされるのか？(完全版)</a> 参照。
<br />
</p>

<p class="paragraph">
640KBの壁については、ROM BIOSの配置やビデオRAMなどの配置の影響で、コンベンショナルメモリが0 - 640KBに制限されたことで生じた。
<br />
コンベンショナルメモリについては <a href="./view-632.html" >技術/歴史/DOS時代のメモリ管理(EMS,XMS周辺)</a> 参照。
<br />
</p>

<h4 id="idc7fc5b">MS-DOSの構成</h4>

<p class="paragraph">
MS-DOSのカーネル構成やメモリレイアウトについて簡単に紹介する。
<br />
</p>

<h5 id="id32b58b">MS-DOSのブート直前</h5>

<p class="paragraph">
<a href="./view-614.html" >Assembler/なぜx86ではMBRが&quot;0x7C00&quot;にロードされるのか？(完全版)</a> より転載。
<br />
ROM BIOSのPOST(Power On Self Test)処理が完了し、BIOS内部でINT 19hが実行され、磁気ディスクの最初のセクタ(MBR)が0x7C00に読み込まれた状態。
<br />
</p>
<pre class="plugin_pre">
+--------------------- 0x0
| Interrupts vectors
+--------------------- 0x400
| BIOS data area
+--------------------- 0x5??
| OS load area
+--------------------- 0x7C00
| Boot sector
+--------------------- 0x7E00
| Boot data/stack
+--------------------- 0x7FFF
| (not used)
+--------------------- (...)
</pre>
<p class="paragraph">
ちなみに、0xFFFF0など物理アドレスの最後尾にはROM BIOS領域が割り当てられている。
<br />
</p>

<p class="paragraph">
この時点で、BIOSの提供する割り込みハンドラについては既に 0h - 3FFh の割り込みベクタにISRのアドレスを登録済になっている。
<br />
INT 20h/INT 21hなど、MS-DOSの提供する割り込みハンドラは、この後、MS-DOSのシステムがロードされる時に登録される。
<br />
</p>

<h5 id="id041dd0">MS-DOSのブート直後</h5>

<p class="paragraph">
MBRからロードされたbootloaderによりシステムがロードされ、 IO.SYS, MSDOS.SYS, COMMAND.COM, およびデバイスドライバが下図のようにメモリ上に展開される。
<br />
</p>
<pre class="plugin_pre">
+-------------------+
| VRAM/ROM BIOS領域 |
+-------------------+ A0000h (640KB)
| ユーザー領域      |
+-------------------+
| COMMAND.COM       |
+-------------------+
| デバイスドライバ/ |
| システム作業領域  |
+-------------------+
| MSDOS.SYS         |
+-------------------+
| IO.SYS            |
+-------------------+ 5??h
| BIOSデータ領域    |
+-------------------+ 400h
| 割り込みベクタ    |
+-------------------+ 0h
</pre>
<p class="paragraph">
&quot;MSDOS.SYS&quot;, &quot;IO.SYS&quot;は隠しファイルになっている。この二つは、実はDOSのバージョンやOEM先によって名前が違う。
<br />
</p>
<table>
	<tr>
		<th> System </th>
		<th> BIOS Extension </th>
		<th> DOS Resident </th>
	</tr>
	<tr>
		<td> MS-DOS </td>
		<td> IO.SYS </td>
		<td> MSDOS.SYS </td>
	</tr>
	<tr>
		<td> PC-DOS </td>
		<td> IBMBIO.COM </td>
		<td> IBMDOS.COM </td>
	</tr>
	<tr>
		<td>Compaq DOS </td>
		<td> IBMBIO.COM </td>
		<td> IBMDOS.COM </td>
	</tr>
	<tr>
		<td> DR DOS before 6.0 </td>
		<td> DRBIOS.SYS </td>
		<td> DRDOS.SYS </td>
	</tr>
	<tr>
		<td> DR DOS 6.0 </td>
		<td> IBMBIO.COM </td>
		<td> IBMDOS.COM </td>
	</tr>
</table>

<p class="paragraph">
また&quot;5??h&quot;のアドレスについては、以下の資料では&quot;5FFh&quot;と明記されている。
<br />
</p>
<ul><li> The DOS Memory Map<ul><li> <a class="externallink" href="http://www.nolm.org/TAE/c016p08.htm" target="_blank">http://www.nolm.org/TAE/c016p08.htm</a></li></ul></li></ul>

<h5 id="idc82d23">IO.SYS, MSDOS.SYS, COMMAND.COMについて</h5>

<p class="paragraph">
CP/Mのモジュールと対比させると分かりやすい。
<br />
</p>
<table>
	<tr>
		<td> CP/M </td>
		<td> MS-DOS </td>
		<td> 機能 </td>
	</tr>
	<tr>
		<td> BDOS </td>
		<td> MSDOS.SYS </td>
		<td> OSカーネル </td>
	</tr>
	<tr>
		<td> BIOS </td>
		<td> IO.SYS </td>
		<td> ハードウェア制御 </td>
	</tr>
	<tr>
		<td> CCP </td>
		<td> COMMAND.COM </td>
		<td> ユーザインターフェイス </td>
	</tr>
	<tr>
		<td> TPA </td>
		<td> ユーザー領域 </td>
		<td> ユーザープログラムがロードされる </td>
	</tr>
</table>

<h5 id="id43740c">ソフトウェア割り込みによるシステムコールの仕組み</h5>

<p class="paragraph">
CP/Mの時と同様、OSの提供する機能を利用するには一度ゲートウェイを通してカーネル(CP/MならBDOS)を呼ぶ必要がある。
<br />
CP/Mでは&quot;CALL 0005h&quot;がその役目を負ったが、MS-DOSの場合は&quot;INT&quot;命令によるソフトウェア割り込みで実現している。
<br />
</p>

<p class="paragraph">
MS-DOSでは、主に20h以降のソフトウェア割り込み番号をMSDOS.SYS内のサービスルーチンに割り当てている。
<br />
一つのサービスルーチン内では、AHレジスタに設定される「ファンクション番号」で更に機能を細分化している。
<br />
例えばコンソールへ文字を直接出力するには、INT 21h, ファンクション番号は06hとなる。
<br />
</p>
<pre>例：&#039;A&#039;を表示
MOV AH, 06h   # ファンクション番号 06h
MOV DL, 41h   # 出力したい文字
INT 21h       # ソフトウェア割り込みによるシステムコール
</pre>

<p class="paragraph">
このように、ユーザープログラムが直接MSDOS.SYSの機能を使うのではなく、INT命令によるシステムコールを介して使うようになっている。
<br />
</p>
<pre>NG : [ユーザープログラム] &lt;-----&gt; [MSDOS.SYS]

OK : [ユーザープログラム] &lt;---&gt; &quot;INT xx&quot; &lt;---&gt; [MSDOS.SYS]
</pre>

<p class="paragraph">
周辺機器を扱う場合など、IO.SYSが関連してくる場合も同様である。ユーザープログラムが直接IO.SYSの機能を使うのではなく、INT命令によるシステムコール、つまりMSDOS.SYSを介するようになっている。
<br />
</p>
<pre>NG : [ユーザープログラム] &lt;-----&gt; [IO.SYS]

OK : [ユーザープログラム] &lt;---&gt; &quot;INT xx&quot; &lt;---&gt; [MSDOS.SYS] &lt;--+
                                                              |
        周辺機器 (&lt;---&gt; [デバイスドライバ]) &lt;---&gt; [IO.SYS] &lt;--+
</pre>

<h5 id="id917acd">参考資料</h5>

<p class="paragraph">
MS-DOSのメモリレイアウト：
<br />
</p>
<ul><li> An Inside Look at MS-DOS<ul><li> <a class="externallink" href="http://www.patersontech.com/dos/Byte/InsideDos.htm" target="_blank">http://www.patersontech.com/dos/Byte/InsideDos.htm</a></li></ul></li>
<li> Hidden DOS Files<ul><li> <a class="externallink" href="http://www.nolm.org/TAE/c016p05.htm" target="_blank">http://www.nolm.org/TAE/c016p05.htm</a></li></ul></li></ul>

<p class="paragraph">
システムコール：
<br />
</p>
<ul><li> Using the INT Instruction<ul><li> <a class="externallink" href="http://www.nolm.org/TAE/c017p02.htm" target="_blank">http://www.nolm.org/TAE/c017p02.htm</a></li></ul></li>
<li> MS-DOS API<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/MS-DOS_API" target="_blank">http://en.wikipedia.org/wiki/MS-DOS_API</a></li></ul></li>
<li> DOS Kernel<ul><li> <a class="externallink" href="http://www.ctyme.com/intr/cat-010.htm" target="_blank">http://www.ctyme.com/intr/cat-010.htm</a></li></ul></li></ul>

<h4 id="id94fcad">Windows 1.0 の登場 (1985 - )</h4>

<p class="paragraph">
1985年、Windows 1.0が発表される。マーケティング上はWindows 1.0だが、実際はWindows 1.01というバージョンになっていた。
<br />
「本当の」Windows 1.0は1983年の時点でアナウンスされていたが、動作段階には至っていなかったらしい。IBMに見せたが、IBMの興味を引くことなく終わってしまったという説もある。1983年説を採用すれば、実際はWindows 1.01だったというバージョン番号にも納得が行く。
<br />
</p>

<p class="paragraph">
ともあれ、多くの、Microsoft公式サイトでも、Windows 1.0 は1985年発表とされている。
<br />
もっとも、Microsoft公式サイトにおいても1983年から開発が始まっていたことは確認出来る。(1983年の段階で動作出来たのか、IBMに見せたのかは確証が得られなかった)
<br />
</p>

<p class="paragraph">
参考資料： <a href="./view-631.html" >技術/歴史/DOS時代,Windows初期のCPUとPC</a> , &quot;Windowsシリーズ&quot;の参考URL参照。
<br />
</p>

<p class="paragraph">
Windows 1.0 はDOS上で動くGUIマネージャであり、リアルモードで動作するプログラムだった。OSというよりはGUIフロントエンドと呼んだ方がふさわしい。
<br />
DOS上で動作するリアルモードプログラムである以上、1セグメント64KBの制限および640KBの壁の制限を受けてしまう。
<br />
</p>

<p class="paragraph">
1984年時点でハードウェアタイプのEMSが利用可能だったが、OSとして公式サポートするまでには至っていなかった。
<br />
</p>

<p class="paragraph">
個人的にWindows 1.0で注目しておきたいポイントは、実行ファイルのフォーマットの一つ、<strong>&quot;new executable&quot;(NE)フォーマットが初登場したのがWindows 1.0</strong>である点。拡張子はMS-DOSと同様に&quot;.EXE&quot;だったが、Windowsのみが取り扱えるヘッダー構造になっていたらしい。
<br />
</p>

<h4 id="id16184e">Windows 2.0 の登場 (1987 - )</h4>

<p class="paragraph">
1987年、Windows 2.0が発表される。
<br />
同年、Lotus, Intel, Microsoft, それに ATSを加えて EMS 4.0 が策定されており、Windows 2.0でサポートされた。
<br />
この時点では8086/8088を搭載したマシンも多く、その場合はハードウェアタイプのExpanded Memoryを利用出来た。(プロテクトモードの1MB超えのメモリ領域を使ったソフトウェアエミュレーションタイプのEMSを利用するには後述の80286が必要だったが、80286自体は1982年に既に発表されている。1987年の時点で &quot;IBM PC AT&quot; や &quot;IBM PC XT 286&quot; など80286が搭載されたマシンも出回っていた。)
<br />
他にも、Windows1.0ではタイル上に配置されたWindowが、WIndows2.0になって新しいWindowが古いWindowの上に重なるようになり、より「デスクトップ」のメタファーに近づいた。
<br />
</p>

<p class="paragraph">
Windows 2.0はEMS4.0に対応したとはいえ、未だにDOS上で動作するリアルモードのプログラムであった。とはいえ、ルックスの改良やExcelやPageMakerなどのキラーアプリケーションの出現によりある程度の成功を収めている。
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-641.html" title="技術/歴史">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-634.html" title="技術/歴史/&quot;WindowsOS内部のアーキテクチャのすべて&quot;読書メモ/4章">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-23.html" title="技術">技術</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/633<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2001 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" target="_blank" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>