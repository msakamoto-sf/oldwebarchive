<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>C言語系/NetBSD1.6における setjmp(), longjmp() の実装 - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">C言語系/NetBSD1.6における setjmp(), longjmp() の実装</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-01-04 01:50:02 &nbsp; / &nbsp; last updated at: 2010-01-04 01:52:31<br>
カテゴリ: <a href="category-48.html">Assembler</a>&nbsp;<a href="category-32.html">BSD</a>&nbsp;<a href="category-10.html">C言語</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-896.html" title="C言語系/C++/R0625 &quot;pure virtual function call&quot; と __purecall">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-536.html" title="C言語系/NetBSD1.6における setjmp(), longjmp() の実装(2)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
引き続き「エキスパートCプログラミング」ネタ。setjmp()とlongjmp()が出てきたので、早速実験。
<br />
ちょうど「デーモン君のソース探検」ようにCVSからソースを落としてきたNetBSD1.6があったので、setjmp()/longjmp()の中身を調べ、動作原理をgdbで追いつめていきたい。
<br />
</p>

<p class="paragraph">
まずは「エキスパートCプログラミング」に載っていたサンプルプログラム。
<br />
test7.c:
<br />
</p>
<div class="hl-main"><pre><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdio.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">setjmp.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
 
</span><span class="hl-identifier">jmp_buf</span><span class="hl-code"> </span><span class="hl-identifier">buf</span><span class="hl-code">;
 
</span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">banana</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">printf</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">in banana()</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> (2) </span><span class="hl-mlcomment">*/</span><span class="hl-code">
        </span><span class="hl-identifier">longjmp</span><span class="hl-brackets">(</span><span class="hl-identifier">buf</span><span class="hl-code">, </span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> NOTREACHED </span><span class="hl-mlcomment">*/</span><span class="hl-code">
        </span><span class="hl-identifier">printf</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">you'll never see this, because I longjmp'd.</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">setjmp</span><span class="hl-brackets">(</span><span class="hl-identifier">buf</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-identifier">printf</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">back in main</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> (3) </span><span class="hl-mlcomment">*/</span><span class="hl-code">
        </span><span class="hl-brackets">}</span><span class="hl-code"> </span><span class="hl-reserved">else</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-identifier">printf</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">first time through...</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> (1) </span><span class="hl-mlcomment">*/</span><span class="hl-code">
                </span><span class="hl-identifier">banana</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">0</span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>
<p class="paragraph">
そのまま動かすと、上の&quot;(1)&quot;,&quot;(2)&quot;,&quot;(3)&quot;の順で処理が進むことが確認出来る。
<br />
</p>
<pre>$ ./test7
first time through...
in banana()
back in main
</pre>

<p class="paragraph">
では早速gdbで追っていきたい。
<br />
</p>


<ul><li><a href="#id3b7ee3">主要なシンボルアドレスのメモ</a></li>
<li><a href="#id60422c">main関数～setjmp(__setjmp14)関数直前迄</a></li>
<li><a href="#id7b788f">setjmp(__setjmp14)関数内部</a></li>
<li><a href="#id3a24fc">longjmp(__longjmp14)関数内部</a></li></ul>
<hr />
<h3 id="id3b7ee3">主要なシンボルアドレスのメモ</h3>

<p class="paragraph">
gdbの前に、nmコマンドで主要なシンボルのアドレスを押さえておく。
<br />
</p>

<pre>$ nm test7
(主要シンボルだけ抽出)
         U __longjmp14
         U __setjmp14
08048974 T banana
08049d60 B buf
080489b0 T main
         U printf
</pre>

<p class="paragraph">
実際に使われるのが__setjmp14, __longjmp14になっている。なぜそうなってしまうのかも謎だが、一旦そちらの謎は置いておいて、とりあえず素直に __setjmp14, __longjmp14のソースコードがどこにあるか確認する。
<br />
</p>
<pre>$ locate setjmp
</pre>
<p class="paragraph">
あらかじめソースをCVSからチェックアウト後、&quot;/etc/weekly&quot;でlocateのデータベースを構築しておいた。アーキテクチャ依存などかなり大量のファイルがヒットするが、i386用のソースファイルは以下に見つかった。
<br />
</p>
<pre>/usr/src/lib/libc/arch/i386/gen/__setjmp14.S
</pre>
<p class="paragraph">
このファイルは後々、すこしだけちら見することになる。実際は、動作原理を把握する分であればgdb上での逆アセンブルだけで大凡分かる。
<br />
</p>

<h3 id="id60422c">main関数～setjmp(__setjmp14)関数直前迄</h3>

<p class="paragraph">
ではgdbを始める。mainにブレークポイントを置き実行する。なお今回は &quot;*main&quot; という風にアスタリスクを頭に置き、インストラクション単位でmainに入った段階で停まるようにした。単に&quot;main&quot;とすると、アセンブリ言語レベルでの関数の先頭ではなく、ソースコードに対応する少し後のアドレスになってしまうからだ。
<br />
</p>
<pre class="plugin_pre">
$ gdb test7
GNU gdb 5.0nb1
...
This GDB was configured as &quot;i386--netbsdelf&quot;...
(gdb) b *main
Breakpoint 1 at 0x80489b0: file test7.c, line 11.
(gdb) run
Starting program: /home/msakamoto/lang.c/test7

Breakpoint 1, 0x80489b0 in main () at test7.c:11
11      }
</pre>
<p class="paragraph">
ここで逆アセンブルしてみる。
<br />
</p>
<pre class="plugin_pre">
(gdb) disas
Dump of assembler code for function main:
0x80489b0 &lt;main&gt;:       push   %ebp
0x80489b1 &lt;main+1&gt;:     mov    %esp,%ebp
0x80489b3 &lt;main+3&gt;:     sub    $0x8,%esp
0x80489b6 &lt;main+6&gt;:     add    $0xfffffff4,%esp
0x80489b9 &lt;main+9&gt;:     push   $0x8049d60
0x80489be &lt;main+14&gt;:    call   0x8048634 &lt;__setjmp14&gt;
0x80489c3 &lt;main+19&gt;:    add    $0x10,%esp
0x80489c6 &lt;main+22&gt;:    mov    %eax,%eax
0x80489c8 &lt;main+24&gt;:    test   %eax,%eax
0x80489ca &lt;main+26&gt;:    je     0x80489e0 &lt;main+48&gt;
0x80489cc &lt;main+28&gt;:    add    $0xfffffff4,%esp
0x80489cf &lt;main+31&gt;:    push   $0x8048bcd
0x80489d4 &lt;main+36&gt;:    call   0x8048644 &lt;printf&gt;
0x80489d9 &lt;main+41&gt;:    add    $0x10,%esp
0x80489dc &lt;main+44&gt;:    jmp    0x80489f5 &lt;main+69&gt;
0x80489de &lt;main+46&gt;:    mov    %esi,%esi
0x80489e0 &lt;main+48&gt;:    add    $0xfffffff4,%esp
0x80489e3 &lt;main+51&gt;:    push   $0x8048bdb
0x80489e8 &lt;main+56&gt;:    call   0x8048644 &lt;printf&gt;
0x80489ed &lt;main+61&gt;:    add    $0x10,%esp
0x80489f0 &lt;main+64&gt;:    call   0x8048974 &lt;banana&gt;
0x80489f5 &lt;main+69&gt;:    xor    %eax,%eax
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---
0x80489f7 &lt;main+71&gt;:    jmp    0x80489fc &lt;main+76&gt;
0x80489f9 &lt;main+73&gt;:    lea    0x0(%esi),%esi
0x80489fc &lt;main+76&gt;:    leave
0x80489fd &lt;main+77&gt;:    ret
End of assembler dump.
(gdb) p/x $pc
$1 = 0x80489b0
</pre>

<p class="paragraph">
ここで&quot;__setjmp14&quot;にブレークポイントを設定する。
<br />
</p>
<pre>(gdb) b *__setjmp14
Breakpoint 2 at 0x4808e24c
</pre>
<p class="paragraph">
0x4808e24cと、上の逆アセンブルでのcall先アドレスとは異なる場所に設定されてしまった。これはダイナミックリンクによるPLTの影響なので、今は無視しても問題ないはず。
<br />
</p>
<pre>(gdb) b *0x80489be
Breakpoint 3 at 0x80489be: file test7.c, line 14.
</pre>
<p class="paragraph">
→アセンブラレベルでの &quot;__setjmp14&quot; のcall命令にもブレークポイントを設置する。
<br />
&quot;info break&quot;コマンドでブレークポイントの設置状況を確認後、&quot;c&quot;でcontinueし、&quot;__setjmp14&quot;のcall命令まで一気に実行する。
<br />
</p>
<pre class="plugin_pre">
(gdb) info break
Num Type           Disp Enb Address    What
1   breakpoint     keep y   0x080489b0 in main at test7.c:11
        breakpoint already hit 1 time
2   breakpoint     keep y   0x4808e24c  &lt;__setjmp14&gt;
3   breakpoint     keep y   0x080489be in main at test7.c:14
(gdb) c
Continuing.

Breakpoint 3, 0x80489be in main () at test7.c:14
14              if (setjmp(buf)) {
(gdb) c
Continuing.

Breakpoint 2, 0x4808e24c in __setjmp14 () from /usr/lib/libc.so.12
</pre>

<h3 id="id7b788f">setjmp(__setjmp14)関数内部</h3>

<p class="paragraph">
__setjmp14の中に到達したので、逆アセンブルする。
<br />
</p>
<pre class="plugin_pre">
(gdb) disas
Dump of assembler code for function __setjmp14:
0x4808e24c &lt;__setjmp14&gt;:        mov    0x4(%esp,1),%ecx
0x4808e250 &lt;__setjmp14+4&gt;:      mov    0x0(%esp,1),%edx
0x4808e254 &lt;__setjmp14+8&gt;:      mov    %edx,0x0(%ecx)
0x4808e257 &lt;__setjmp14+11&gt;:     mov    %ebx,0x4(%ecx)
0x4808e25a &lt;__setjmp14+14&gt;:     mov    %esp,0x8(%ecx)
0x4808e25d &lt;__setjmp14+17&gt;:     mov    %ebp,0xc(%ecx)
0x4808e260 &lt;__setjmp14+20&gt;:     mov    %esi,0x10(%ecx)
0x4808e263 &lt;__setjmp14+23&gt;:     mov    %edi,0x14(%ecx)
0x4808e266 &lt;__setjmp14+26&gt;:     lea    0x18(%ecx),%edx
0x4808e269 &lt;__setjmp14+29&gt;:     push   %ebx
0x4808e26a &lt;__setjmp14+30&gt;:     call   0x4808e26f &lt;__setjmp14+35&gt;
0x4808e26f &lt;__setjmp14+35&gt;:     pop    %ebx
0x4808e270 &lt;__setjmp14+36&gt;:     add    $0x5e305,%ebx
0x4808e276 &lt;__setjmp14+42&gt;:     push   %edx
0x4808e277 &lt;__setjmp14+43&gt;:     push   $0x0
0x4808e279 &lt;__setjmp14+45&gt;:     push   $0x0
0x4808e27b &lt;__setjmp14+47&gt;:     call   0x48072aa4 &lt;_init+3016&gt;
0x4808e280 &lt;__setjmp14+52&gt;:     add    $0xc,%esp
0x4808e283 &lt;__setjmp14+55&gt;:     pop    %ebx
0x4808e284 &lt;__setjmp14+56&gt;:     xor    %eax,%eax
0x4808e286 &lt;__setjmp14+58&gt;:     ret
0x4808e287 &lt;__setjmp14+59&gt;:     nop
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---q
Quit
</pre>
<p class="paragraph">
実際のアセンブラソースも載せておく。(BSDライセンスだから多丈夫なはず。)
<br />
</p>
<pre class="plugin_pre">
ENTRY(__setjmp14)
        movl    4(%esp),%ecx
        movl    0(%esp),%edx
        movl    %edx, 0(%ecx)
        movl    %ebx, 4(%ecx)
        movl    %esp, 8(%ecx)
        movl    %ebp,12(%ecx)
        movl    %esi,16(%ecx)
        movl    %edi,20(%ecx)

        /* Get the signal mask. */
        leal    24(%ecx),%edx

        PIC_PROLOGUE
        pushl   %edx
        pushl   $0
        pushl   $0
#ifdef PIC
        call    PIC_PLT(_C_LABEL(__sigprocmask14))
#else
        call    _C_LABEL(__sigprocmask14)
#endif
        addl    $12,%esp
        PIC_EPILOGUE

        xorl    %eax,%eax
        ret
</pre>
<p class="paragraph">
この時点でESP/EBP, そしてスタックの状況を確認してみる。
<br />
</p>
<pre class="plugin_pre">
(gdb) p/x $esp
$1 = 0xbfbfdb40
(gdb) p/x $ebp
$2 = 0xbfbfdb5c
(gdb) x/40w $esp
0xbfbfdb40:     0x080489c3      0x08049d60      0xbfbfdbcc      0x0804001f
0xbfbfdb50:     0x4804001f      0xbfbfdbcc      0xbfbfdb78      0xbfbfdba8
0xbfbfdb60:     0x08048780      0x00000001      0xbfbfdbcc      0xbfbfdbd4
0xbfbfdb70:     0x00000246      0x48056200      0xbfbfdba8      0x08048769
0xbfbfdb80:     0x08048a34      0x48056200      0x480534a8      0x080486ea
0xbfbfdb90:     0xbfbfdff0      0x00000000      0x00000000      0xbfbfdc24
0xbfbfdba0:     0xbfbfdc1c      0x00000000      0x00000000      0x080486db
0xbfbfdbb0:     0x00000001      0xbfbfdbcc      0xbfbfdbd4      0x4804abc0
0xbfbfdbc0:     0x48056200      0xbfbfdff0      0x00000001      0xbfbfdc5c
0xbfbfdbd0:     0x00000000      0xbfbfdc79      0xbfbfdc94      0xbfbfdc9f
</pre>
<p class="paragraph">
x86ではスタックはアドレスの小さい方に伸びていくので、0xbfbfdb40というのが間違いなくスタックのTOP。スタックフレームのTOP近くを解析してみる。
<br />
</p>
<pre>0xbfbfdb40: 0x080489c3 &lt;= ESP, 戻り先アドレス→setjmp()の直後の命令を指す。
0xbfbfdb44: 0x08049d60 &lt;= 引数, これはソースコードでの &quot;jmp_buf buf&quot;へのアドレス。(nmの結果を復習)
</pre>
<p class="paragraph">
0xbfbfdb48以降は、ここに至るまでのスタックフレームになり、本題から外れるので解析は省略する。
<br />
</p>

<ul><li> ESPが戻り先アドレス = longjmp()で戻ってきて欲しい地点になっていること</li>
<li> ESP+4がjmp_buf型へのポインタ引数であること</li></ul>

<p class="paragraph">
この2点が把握できれば、__setjmp14の次のアセンブラコードの意味も明らかになる。
<br />
</p>
<pre class="plugin_pre">
ENTRY(__setjmp14)
        movl    4(%esp),%ecx
        movl    0(%esp),%edx
        movl    %edx, 0(%ecx)
        movl    %ebx, 4(%ecx)
        movl    %esp, 8(%ecx)
        movl    %ebp,12(%ecx)
        movl    %esi,16(%ecx)
        movl    %edi,20(%ecx)
</pre>
<p class="paragraph">
まずECXに jmp_buf型へのポインタを格納する。
<br />
</p>
<pre>movl    4(%esp),%ecx
</pre>
<p class="paragraph">
続いて ESP の値 = longjmpでの戻り先アドレスをEDXに格納する。
<br />
</p>
<pre>movl    0(%esp),%edx
</pre>
<p class="paragraph">
EDX(戻り先アドレス)に加えて、EBX, ESI, EDI, ESP, EBPを格納している。なお処理の流れ上、元のEAX, ECX, EDXはjmp_bufには保存されないらしい。
<br />
</p>

<p class="paragraph">
ちなみにjmp_buf型は long[JBLEN] というlong型配列がtypedefされたもので、NetBSD1.6のi386ではJBLEN=13となっている。
<br />
</p>
<pre>$ cd /usr/include
$ grep -r jmp_buf *
i386/setjmp.h:#define   _JBLEN  13              /* size, in longs, of a jmp_buf */
machine/setjmp.h:#define        _JBLEN  13              /* size, in longs, of a jmp_buf */
setjmp.h:typedef long sigjmp_buf[_JBLEN + 1] _JB_ATTRIBUTES;
setjmp.h:typedef long jmp_buf[_JBLEN] _JB_ATTRIBUTES;
</pre>

<p class="paragraph">
まとめると、setjmp()ではjmp_bufの中に、longjmpで必要な戻り先アドレスや戻った時点で復元したいレジスタ値を保存していることがわかった。
<br />
</p>

<h3 id="id3a24fc">longjmp(__longjmp14)関数内部</h3>

<p class="paragraph">
setjmp()の原理が分かったところで、longjmp()をデバッグする為、引き続きgdbに戻る。
<br />
</p>
<pre class="plugin_pre">
(gdb) b *__longjmp14
Breakpoint 4 at 0x4808e288
(gdb) c
Continuing.
first time through...
in banana()

Breakpoint 4, 0x4808e288 in __longjmp14 () from /usr/lib/libc.so.12
</pre>
<p class="paragraph">
&quot;__longjmp14()&quot;の中で停まったので、逆アセンブルする。
<br />
</p>
<pre class="plugin_pre">
(gdb) disas
Dump of assembler code for function __longjmp14:
0x4808e288 &lt;__longjmp14&gt;:       mov    0x4(%esp,1),%ecx
0x4808e28c &lt;__longjmp14+4&gt;:     lea    0x18(%ecx),%edx
0x4808e28f &lt;__longjmp14+7&gt;:     push   %ebx
0x4808e290 &lt;__longjmp14+8&gt;:     call   0x4808e295 &lt;__longjmp14+13&gt;
0x4808e295 &lt;__longjmp14+13&gt;:    pop    %ebx
0x4808e296 &lt;__longjmp14+14&gt;:    add    $0x5e2df,%ebx
0x4808e29c &lt;__longjmp14+20&gt;:    push   $0x0
0x4808e29e &lt;__longjmp14+22&gt;:    push   %edx
0x4808e29f &lt;__longjmp14+23&gt;:    push   $0x3
0x4808e2a1 &lt;__longjmp14+25&gt;:    call   0x48072aa4 &lt;_init+3016&gt;
0x4808e2a6 &lt;__longjmp14+30&gt;:    add    $0xc,%esp
0x4808e2a9 &lt;__longjmp14+33&gt;:    pop    %ebx
0x4808e2aa &lt;__longjmp14+34&gt;:    mov    0x4(%esp,1),%edx
0x4808e2ae &lt;__longjmp14+38&gt;:    mov    0x8(%esp,1),%eax
0x4808e2b2 &lt;__longjmp14+42&gt;:    mov    0x0(%edx),%ecx
0x4808e2b5 &lt;__longjmp14+45&gt;:    mov    0x4(%edx),%ebx
0x4808e2b8 &lt;__longjmp14+48&gt;:    mov    0x8(%edx),%esp
0x4808e2bb &lt;__longjmp14+51&gt;:    mov    0xc(%edx),%ebp
0x4808e2be &lt;__longjmp14+54&gt;:    mov    0x10(%edx),%esi
0x4808e2c1 &lt;__longjmp14+57&gt;:    mov    0x14(%edx),%edi
0x4808e2c4 &lt;__longjmp14+60&gt;:    test   %eax,%eax
0x4808e2c6 &lt;__longjmp14+62&gt;:    jne    0x4808e2c9 &lt;__longjmp14+65&gt;
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---
0x4808e2c8 &lt;__longjmp14+64&gt;:    inc    %eax
0x4808e2c9 &lt;__longjmp14+65&gt;:    mov    %ecx,0x0(%esp,1)
0x4808e2cd &lt;__longjmp14+69&gt;:    ret
0x4808e2ce &lt;__longjmp14+70&gt;:    mov    %esi,%esi
End of assembler dump.
</pre>
<p class="paragraph">
対応する実際のアセンブラソースも載せておく。
<br />
</p>
<pre class="plugin_pre">
ENTRY(__longjmp14)
        /* Restore the signal mask. */
        movl    4(%esp),%ecx
        leal    24(%ecx),%edx

        PIC_PROLOGUE
        pushl   $0
        pushl   %edx
        pushl   $3                      /* SIG_SETMASK */
#ifdef PIC
        call    PIC_PLT(_C_LABEL(__sigprocmask14))
#else
        call    _C_LABEL(__sigprocmask14)
#endif
        addl    $12,%esp
        PIC_EPILOGUE

        movl    4(%esp),%edx
        movl    8(%esp),%eax
        movl    0(%edx),%ecx
        movl    4(%edx),%ebx
        movl    8(%edx),%esp
        movl    12(%edx),%ebp
        movl    16(%edx),%esi
        movl    20(%edx),%edi
        testl   %eax,%eax
        jnz     1f
        incl    %eax
1:      movl    %ecx,0(%esp)
        ret
</pre>
<p class="paragraph">
この時点でのESP/EBP/スタックフレーム/バックトレースを確認してみる。
<br />
</p>
<pre class="plugin_pre">
(gdb) p/x $esp
$3 = 0xbfbfdb30
(gdb) p/x $ebp
$4 = 0xbfbfdb4c
(gdb) x/8w $esp
0xbfbfdb30:     0x08048999      0x08049d60      0x00000001      0xbfbfdb5c
0xbfbfdb40:     0x080489ed      0x08048bdb      0xbfbfdbcc      0xbfbfdb5c
(gdb) bt
#0  0x4808e288 in __longjmp14 () from /usr/lib/libc.so.12
#1  0x8048999 in banana () at test7.c:8
#2  0x80489f5 in main () at test7.c:18
#3  0x8048780 in ___start ()
</pre>
<p class="paragraph">
元のC言語のソースを思い出すと、
<br />
</p>
<pre>longjmp(buf, 1);
</pre>
<p class="paragraph">
なので、
<br />
</p>
<pre>(gdb) x/8w $esp
0xbfbfdb30:     0x08048999      0x08049d60      0x00000001      0xbfbfdb5c
</pre>
<p class="paragraph">
のスタックフレームを逆算すると
<br />
</p>
<pre>戻り先(ESP)     : 0x08048999
引数1 (ESP + 4) : 0x08049d60 = &quot;jmp_buf buf&quot;
引数2 (ESP + 8) : 1
</pre>
<p class="paragraph">
となり、C言語のソースと対応していることが分かる。ここまで解析出来れば、本体のアセンブラソースの意味も明らかになる。
<br />
</p>
<pre class="plugin_pre">
        movl    4(%esp),%edx
        movl    8(%esp),%eax
        movl    0(%edx),%ecx
        movl    4(%edx),%ebx
        movl    8(%edx),%esp
        movl    12(%edx),%ebp
        movl    16(%edx),%esi
        movl    20(%edx),%edi
        testl   %eax,%eax
        jnz     1f
        incl    %eax
1:      movl    %ecx,0(%esp)
        ret
</pre>
<p class="paragraph">
まず引数1で渡されたjmp_buf型のポインタをEDXに格納。
<br />
</p>
<pre>movl    4(%esp),%edx
</pre>
<p class="paragraph">
続いて、引数2をEAXに格納。
<br />
</p>
<pre>movl    8(%esp),%eax
</pre>
<p class="paragraph">
setjmp()の中でjmp_bufの中に格納された各レジスタ値を復元。
<br />
</p>
<pre>movl    0(%edx),%ecx
movl    4(%edx),%ebx
movl    8(%edx),%esp
movl    12(%edx),%ebp
movl    16(%edx),%esi
movl    20(%edx),%edi
</pre>
<p class="paragraph">
次は、元のソースではなくgdb上で逆アセンブルしたソースの方が分かりやすい。
<br />
</p>
<pre>testl   %eax,%eax
jnz     1f
incl    %eax
</pre>
<p class="paragraph">
↓
<br />
</p>
<pre>0x4808e2c4 &lt;__longjmp14+60&gt;:    test   %eax,%eax
0x4808e2c6 &lt;__longjmp14+62&gt;:    jne    0x4808e2c9 &lt;__longjmp14+65&gt;
0x4808e2c8 &lt;__longjmp14+64&gt;:    inc    %eax
0x4808e2c9 &lt;__longjmp14+65&gt;:    mov    %ecx,0x0(%esp,1)
0x4808e2cd &lt;__longjmp14+69&gt;:    ret
</pre>

<p class="paragraph">
まずEAX、つまり引数2のANDを行う(test命令)。
<br />
</p>
<pre>0x4808e2c4 &lt;__longjmp14+60&gt;:    test   %eax,%eax
</pre>

<p class="paragraph">
その結果、もし引数2が0以外であればZF=0になるので、次のJNZ命令が実行される。
<br />
</p>
<pre>0x4808e2c6 &lt;__longjmp14+62&gt;:    jne    0x4808e2c9 &lt;__longjmp14+65&gt;
</pre>
<p class="paragraph">
つまり、次の命令に進む。
<br />
</p>
<pre>0x4808e2c9 &lt;__longjmp14+65&gt;:    mov    %ecx,0x0(%esp,1)
</pre>
<p class="paragraph">
さらにこの直後はret命令。
<br />
一方、もし引数2が0の場合はZF=1になるので、JNZ命令は無視され、次のINC命令が実行される。
<br />
</p>
<pre>0x4808e2c8 &lt;__longjmp14+64&gt;:    inc    %eax
</pre>
<p class="paragraph">
つまりEAXは 0 + 1 = 1になる。
<br />
</p>

<p class="paragraph">
まとめると、引数2が0以外の時はEAX=longjmp()の戻り値はその値になり、引数2が0の時は1がlongjmp()の戻り値になる。
<br />
&quot;longjmp()の戻り値&quot;というよりは「戻る時のsetjmp()の戻り値」の方が正しい表記だろう。
<br />
つまり、初回のsetjmp()では0が戻り、longjmp()から戻る時のsetjmp()の戻り値は必ず0以外になり、初回と区別されるようになっている。
<br />
</p>

<p class="paragraph">
肝心の戻り先アドレスは以下の命令でセットされる。
<br />
</p>
<pre>0x4808e2c9 &lt;__longjmp14+65&gt;:    mov    %ecx,0x0(%esp,1)
</pre>
<p class="paragraph">
ECXはこの上でjmp_buf型から復元されている。遡れば、__setjmp14()の中で格納された、setjmp()の直後のアドレス。
<br />
それをESP+0に転送している・・・ということは、戻り先アドレスを上書きしていることになる。
<br />
</p>

<p class="paragraph">
では実際にステップ実行して確認してみる。
<br />
先ほどのtest命令で一旦ブレークポイントで停め、ステップ実行に入る。
<br />
</p>
<pre>(gdb) b *0x4808e2c4
Breakpoint 5 at 0x4808e2c4
(gdb) c
Continuing.

Breakpoint 5, 0x4808e2c4 in __longjmp14 () from /usr/lib/libc.so.12
(gdb) p/x $eax
$6 = 0x1
(gdb) stepi
0x4808e2c6 in __longjmp14 () from /usr/lib/libc.so.12
</pre>
<p class="paragraph">
これでtest命令が終わった。続いてjnz命令を実行する。
<br />
</p>
<pre>(gdb) stepi
0x4808e2c9 in __longjmp14 () from /usr/lib/libc.so.12
</pre>
<p class="paragraph">
EAXが1だったので、ZFも0となり、inc命令は実行されず、mov命令まで進んだ。
<br />
</p>
<pre>(gdb) p/x $ecx
$7 = 0x80489c3
(gdb) stepi
0x4808e2cd in __longjmp14 () from /usr/lib/libc.so.12
</pre>
<p class="paragraph">
ECXには setjmp() の次のアドレス(=0x080489c3)が復元されている。mov命令実行後のスタックフレームを覗いてみる。
<br />
</p>
<pre>(gdb) x/4w $esp
0xbfbfdb40:     0x080489c3      0x08048bdb      0xbfbfdbcc      0xbfbfdb5c
</pre>
<p class="paragraph">
スタックのTOP(=戻り先アドレス)に、ちゃんと0x080489c3が設定されている。あとはret命令へ進めば、無事main関数の中へ戻る。
<br />
</p>
<pre>(gdb) stepi
0x80489c3 in main () at test7.c:14
14              if (setjmp(buf)) {
(gdb) p/x $pc
$8 = 0x80489c3
(gdb) c
Continuing.
back in main

Program exited normally.
</pre>
<p class="paragraph">
以上で、無事setjmp/longjmpの流れをデバッグできた。
<br />
</p>

<p class="paragraph">
まとめると、setjmp/longjmpはアセンブラレベルでスタックフレームやスタックポインタを処理することで、関数の範囲を超えたジャンプを実現していることを確認できた。
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-896.html" title="C言語系/C++/R0625 &quot;pure virtual function call&quot; と __purecall">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-536.html" title="C言語系/NetBSD1.6における setjmp(), longjmp() の実装(2)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">Up</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/535<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2001 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" target="_blank" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>