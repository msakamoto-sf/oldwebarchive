<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>C言語系/「デーモン君のソース探検」読書メモ/05, locate(1) - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">C言語系/「デーモン君のソース探検」読書メモ/05, locate(1)</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-01-09 21:50:23 &nbsp; / &nbsp; last updated at: 2010-01-10 15:48:17<br>
カテゴリ: <a href="category-32.html">BSD</a>&nbsp;<a href="category-10.html">C言語</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-544.html" title="C言語系/「デーモン君のソース探検」読書メモ/04, uuencode(1),uudecode(1)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-547.html" title="C言語系/「デーモン君のソース探検」読書メモ/06, factor(1)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
お題：locate(1)がデータファイルを構築する仕組みを追跡せよ。
<br />
</p>

<p class="paragraph">
先に結末：追跡しきれませんでした。bigramや文字列差分を組み合わせた圧縮そして展開のコード、自分の理解力とソース読解力では太刀打ちできませんでした｡ﾟ(ﾟ´Д｀ﾟ)ﾟ｡
<br />
</p>




<h3 id="id1b8b66">&quot;/etc/weekly&quot;からlocate用データファイル作成処理をkickするところまで</h3>

<p class="paragraph">
&quot;man 1 locate&quot;
<br />
</p>
<pre>SYNOPSIS
     locate [-d dbpath] pattern
...
FILES
     /var/db/locate.database       Default database
     /usr/libexec/locate.updatedb  Script to update database.

SEE ALSO
     find(1), fnmatch(3), weekly.conf(5)
</pre>

<p class="paragraph">
NetBSD1.6の場合、locateによるDB構築自体は &quot;/etc/weekly&quot; で行われる(NetBSD1.6の場合システムのcrontabは/etc/crontabではなく、rootユーザのcrontabとして &quot;/var/cron/tabs/root&quot; に記述されている)。
<br />
&quot;/etc/weekly&quot;より：
<br />
</p>
<pre>if checkyesno rebuild_locatedb; then
        echo &quot;&quot;
        if [ -f /var/db/locate.database ]; then
                echo &quot;Rebuilding locate database:&quot;
                chmod 644 /var/db/locate.database
                chown nobody:nobody /var/db/locate.database
                nice -5 su -m nobody -c /usr/libexec/locate.updatedb 2&gt;/dev/null
                chown root:wheel /var/db/locate.database
        else
                echo &quot;Not rebuilding locate database; no /var/db/locate.database&quot;
        fi
fi
</pre>
<p class="paragraph">
&quot;rebuild_locatedb&quot;については、&quot;/etc/weekly.conf&quot;にて設定する。システムデフォルトは &quot;/etc/defaults/weekly.conf&quot; でYESに設定されている。BSD系の慣習で、&quot;/etc/weekly.conf&quot;の中では &quot;/etc/defaults/weekly.conf&quot; をまず取り込み、その後デフォルト定義を上書きする形で設定する。詳細は &quot;man 5 weekly.conf&quot; 参照。
<br />
とまれ、流れとしては &quot;/etc/weekly&quot; より
<br />
</p>
<pre>nice -5 su -m nobody -c /usr/libexec/locate.updatedb 2&gt;/dev/null
</pre>
<p class="paragraph">
これにより、nobodyユーザにて &quot;/usr/libexec/locate.updatedb&quot; が実行されることが分かる。
<br />
</p>

<p class="paragraph">
&quot;/usr/libexec/locate.updatedb&quot;はシェルスクリプトになっており、主要部分を抜き出すと次のような流れになる。
<br />
</p>
<pre class="plugin_pre">
SRCHPATHS=&quot;/&quot;                           # directories to be put in the database
LIBDIR=&quot;/usr/libexec&quot;                   # for subprograms
FCODES=&quot;/var/db/locate.database&quot;        # the database

FILELIST=`mktemp -t locate.list` || exit 1

find -s $SRCHPATHS \( \
    ...
    \) -a -prune -o -print \
        &gt;&gt; &quot;$FILELIST&quot;

BIGRAMS=`$LIBDIR/locate.bigram &lt;&quot;$FILELIST&quot;`

if [ -z &quot;$BIGRAMS&quot; ]; then
        echo &#039;locate: updatedb failed&#039; &gt;&amp;2
else
        $LIBDIR/locate.code &quot;$BIGRAMS&quot; &lt;&quot;$FILELIST&quot; &gt;&quot;$FCODES&quot;
        chmod 644 &quot;$FCODES&quot;
fi
</pre>
<p class="paragraph">
まずmktempでファイル一覧を保存する一時ファイルを作る。
<br />
</p>
<pre>FILELIST=`mktemp -t locate.list` || exit 1
</pre>
<p class="paragraph">
続いてfindコマンドでシステムのファイル一覧を作成し、FILELISTで指定されたファイル名に出力しておく。
<br />
</p>

<p class="paragraph">
その後、&quot;$LIBDIR/locate.bigram&quot; = &quot;/usr/libexec/locate.bigram&quot; にFILELISTを食わせ、出力をBIGRAMSに保存する。
<br />
</p>
<pre>BIGRAMS=`$LIBDIR/locate.bigram &lt;&quot;$FILELIST&quot;`
</pre>

<p class="paragraph">
BIGRAMSが空でなければ、&quot;$LIBDIR/locate.code&quot; = &quot;/usr/libexec/locate.code&quot; を実行する。
<br />
</p>
<pre>$LIBDIR/locate.code &quot;$BIGRAMS&quot; &lt;&quot;$FILELIST&quot; &gt;&quot;$FCODES&quot;
chmod 644 &quot;$FCODES&quot;
</pre>
<p class="paragraph">
実行結果は&quot;FCODES&quot;、つまり &quot;/var/db/locate.database&quot; に保存される。
<br />
ここで &quot;/usr/libexec/locate.updatedb&quot;は&quot;/etc/weekly&quot;によりnobodyユーザで実行されることを思い出す。
<br />
すると &quot;/var/db/locate.database&quot; もnobodyユーザで操作出来ねばならない。それが、&quot;/etc/weekly&quot; スクリプトでの次の処理で実現されている。
<br />
</p>
<pre>chmod 644 /var/db/locate.database
chown nobody:nobody /var/db/locate.database
nice -5 su -m nobody -c /usr/libexec/locate.updatedb 2&gt;/dev/null
chown root:wheel /var/db/locate.database
</pre>
<p class="paragraph">
つまり一旦所有者とグループをnobodyにchownして locate.updatedb を実行し、終了後rootオーナ, wheelグループに戻している。
<br />
</p>

<p class="paragraph">
ここでlocateのデータベースを作成するプログラムを特定出来たので、ソースコードの探索に進む。
<br />
</p>

<pre>$ locate locate.bigram
/usr/libexec/locate.bigram
/usr/src/usr.bin/locate/bigram/locate.bigram.c
$ locate locate.code
/usr/libexec/locate.code
/usr/src/usr.bin/locate/code/locate.code.c
</pre>

<h3 id="id827093">&quot;locate.bigram&quot;によるファイルリストのbigram上位抽出</h3>

<p class="paragraph">
&quot;/usr/src/usr.bin/locate/&quot; ディレクトリの構成は次のようになっている。
<br />
</p>
<pre>/usr/src/usr.bin/locate/
    Makefile
    Makefile.inc
    bigram/
        Makefile
        locate.bigram.c
    code/
        Makefile
        locate.code.c
    locate/
        Makefile
        locate.1
        locate.c
        locate.h
        pathnames.h
        updatedb.sh
</pre>

<p class="paragraph">
まずは順番通り、locate.bigram.cを見てみる。
<br />
</p>

<p class="paragraph">
・・・ここで詳しく自力で解説を書いてみようとしたが、bigramの処理部分など解説を書くのが大変・・・というか理解し切れたか不安な箇所が多数あるので、ソースコードの解説については「デーモン君のソース探検」にお譲りします。
<br />
</p>

<p class="paragraph">
処理内容としては、
<br />
</p>
<pre>/usr/bin/foobar
/usr/bin/barbaz
/usr/lib/xxxyyy
...
</pre>
<p class="paragraph">
というようなファイル名のリストを一行ずつ読み込み、直前に読んだ行との差分を抽出、そこから2文字ずつ切り出していき、頻出する上位128位までの2文字を標準出力に出力している。
<br />
</p>

<p class="paragraph">
頑張って理解出来た範囲で解説を試みると・・・
<br />
</p>

<pre>char *cp;
char *oldpath = buf1, *path = buf2;
struct bigram *bg;
int i;
</pre>
<p class="paragraph">
メイン関数の冒頭でまずバッファなどを初期化している。buf1, buf2というのはlocate.bigram.c内でのグローバルシンボルで、以下のように定義されている。
<br />
</p>
<pre>static char buf1[MAXPATHLEN] = &quot; &quot;;
static char buf2[MAXPATHLEN];
</pre>
<p class="paragraph">
つまり、初期状態では
<br />
</p>
<pre>char *path = buf2;
char *oldpath = buf1 = &quot; &quot;(空白文字一字の文字列へのポインタ)
</pre>
<p class="paragraph">
となっている。(whileループの中でややこしくなるので、あえて初期状態を整理しておいた。)
<br />
</p>

<pre>struct bigram *bg
</pre>
<p class="paragraph">
についてはbigramを表現する構造体へのポインタ。この辺は本を参照。
<br />
</p>

<p class="paragraph">
メインとなるwhileループを見てみる。
<br />
</p>
<pre class="plugin_pre">
while ( fgets ( path, sizeof(buf2), stdin ) != NULL ) {

    /* skip longest common prefix */
    for ( cp = path; *cp == *oldpath; cp++, oldpath++ )
        if ( *oldpath == &#039;\0&#039; )
            break;

    /*
     * output post-residue bigrams only
     */
    for(; cp[0] != &#039;\0&#039; &amp;&amp; cp[1] != &#039;\0&#039;; cp += 2)
        add_bigram((u_char)cp[0], (u_char)cp[1]);

    if (path == buf1)               /* swap pointers */
        path = buf2, oldpath = buf1;
    else
        path = buf1, oldpath = buf2;
}
</pre>
<p class="paragraph">
まず標準入力から1行読み、pathに格納する。一番最初は、path = buf2なのでbuf2に格納されている。
<br />
続いてこのforループ：、
<br />
</p>
<pre>   for ( cp = path; *cp == *oldpath; cp++, oldpath++ )
       if ( *oldpath == &#039;\0&#039; )
           break;
</pre>
<p class="paragraph">
2回目以降のループでは後述の通り、oldpathは一つ前で読んだバッファへのポインタになる。従って、今回読んだバッファと、前回読んだバッファとを比較し、違う箇所が出てくるまで cp ポインタを進める、という処理になっている。
<br />
</p>
<pre>oldbuf = &quot;ABCDE&quot;
path   = &quot;ABCDEFG&quot;
</pre>
<p class="paragraph">
だったら、&quot;F&quot;の文字までcpが進むことになる。
<br />
</p>

<p class="paragraph">
&quot;locate.bigram.c&quot;独特（？）なのが次のforループ：
<br />
</p>
<pre>for(; cp[0] != &#039;\0&#039; &amp;&amp; cp[1] != &#039;\0&#039;; cp += 2)
    add_bigram((u_char)cp[0], (u_char)cp[1]);
</pre>
<p class="paragraph">
cpは前の行と異なる箇所まで進んでいる。そしてこのNULL文字判定は、異なる箇所から2文字続いていた時にadd_bigram()を呼ぶようになっている。
<br />
</p>
<pre>例1:
oldbuf = &quot;abc&quot;
path   = &quot;abcd&quot;
→ cpは&quot;d&quot;まで進む。cp[0] != &#039;\0&#039;, しかし cp[1] == &#039;\0&#039; になるので、add_bigramは通らない。

例2:
oldbuf = &quot;abc&quot;
path   = &quot;abcde&quot;
→ cpは&quot;d&quot;まで進む。cp[0] != &#039;\0&#039;, cp[1] != &#039;\0&#039; になるので、add_bigramは通る。
</pre>

<p class="paragraph">
最後にバッファの入れ替えとなる。
<br />
</p>
<pre>   if (path == buf1)               /* swap pointers */
       path = buf2, oldpath = buf1;
   else
       path = buf1, oldpath = buf2;
</pre>
<p class="paragraph">
最初は
<br />
</p>
<pre>oldpath = buf1
path    = buf2 (fgetsで読み込んだ最初の行)
</pre>
<p class="paragraph">
なのでelse節を通る。
<br />
</p>
<pre>→ oldpath = buf2 (fgetsで読み込んだ最初の行)
→ path    = buf1
</pre>
<p class="paragraph">
ここでwhileの先頭に戻り、pathに対してfgetsされ、次の状態になる。
<br />
</p>
<pre>oldpath = buf2 (fgetsで読み込んだ最初の行)
path    = buf1 (fgetsで読み込んだ2行目)
</pre>
<p class="paragraph">
２回目はpath == buf1なので、if節を通る。
<br />
</p>
<pre>→ oldpath = buf1 (fgetsで読み込んだ2行目)
→ path    = buf2 (fgetsで読み込んだ最初の行)
</pre>
<p class="paragraph">
そしてwhileの先頭に戻りfgetsされると・・・
<br />
</p>
<pre>oldpath = buf1 (fgetsで読み込んだ2行目)
path    = buf2 (fgetsで読み込んだ3行目)
</pre>
<p class="paragraph">
となり、これによりbuf1/buf2を使い回しつつ、path/oldpathで「現在読み込んだ行」「一つ前に読み込んだ行」にアクセスすることが出来るようになっている。
<br />
</p>

<p class="paragraph">
ここまで解析した時点で、実際にファイル一覧に相当するテキストファイルを手作りして、処理させてみる。
<br />
</p>

<p class="paragraph">
まず、前の行との差分以降が1文字しか異ならない、あるいは前の行より短いデータを用意する。
<br />
</p>
<pre>$ cat nobigram.dat
a
ab
abc
abcd
h
hi
hij
hijk
hijkl
hijk
hij
hi
h
</pre>
<p class="paragraph">
差分以降が2文字以上無いとbigramとして検出されない。よって、予想ではこのデータでは1文字もbigramとして検出されないはずである。
<br />
</p>
<pre>$ /usr/libexec/locate.bigram &lt; nobigram.dat
$ echo $?
0
</pre>
<p class="paragraph">
予想通り1文字も出力されていない=bigramとして検出されていない。念のためプロセスの戻り値も見てみたが、正常である。
<br />
</p>

<p class="paragraph">
続いて差分以降が2文字以上あるデータファイルを用意してみる。
<br />
</p>
<pre>$ cat bigram.dat
a
abc
abcd
abcdefg
abcDE
hi
</pre>
<p class="paragraph">
予想では、&quot;bc&quot;, &quot;ef&quot;, &quot;DE&quot;, さらに&quot;hi&quot;も検出されるはずである。
<br />
</p>
<pre>abcDE
hi
→ 差分の位置は0文字目になるので、そこから2文字 → &quot;hi&quot;が検出されるはず。
</pre>
<p class="paragraph">
実行してみる。
<br />
</p>
<pre>$ /usr/libexec/locate.bigram  &lt; bigram.dat
hiefbcDE
$ echo $?
0
</pre>
<p class="paragraph">
予想通りとなった。なお、&quot;echo&quot;のコマンドプロンプトを改行して表記しているが、実際は改行コードは出力されていない為
<br />
</p>
<pre>hiefbcDE$ echo $?
0
</pre>
<p class="paragraph">
のように表示されている。
<br />
</p>

<p class="paragraph">
locate独自のbigram検出プログラムである locate.bigram.c の解析はここまでにし、続いて locate.code.c の解析に進む。
<br />
</p>

<h3 id="id66b77e">&quot;locate.code&quot;によるファイルリストの圧縮→理解不能、挫折。</h3>

<p class="paragraph">
進む。
<br />
</p>

<p class="paragraph">
すす・・・もうとしたんですが、code/locate.code.cとか、DBを読み込む locate/locate.c は自分の頭では全て理解することができませんでした　｡･ﾟ･(ﾉД`)
<br />
</p>

<p class="paragraph">
細かい所は殆ど解析出来ず、以降は大雑把なメモ兼駄文になります。正確な解説については「デーモン君のソース探検」を参照して下さい。
<br />
</p>

<p class="paragraph">
&quot;bigram/locate.bigram.c&quot; は単純にファイルリストからbigramを抽出するプログラムです。
<br />
実際に、そのbigramのリストとファイルリストからlocate独自のDBファイルを生成するのが &quot;code/locate.code.c&quot; になります。
<br />
&quot;locate/locate.c&quot;が実際のlocate(1)コマンドのソースで、locate独自のDBファイルを探索するプログラムになります。
<br />
</p>

<p class="paragraph">
この&quot;locate独自のDBファイル&quot;というのが、bigramとファイルリストの各行の近似を数値化したデータの組み合わせで構成されています。
<br />
ファイルリストというのは
<br />
</p>
<pre>/usr/src/foobar
/usr/src/barbaz
...
</pre>
<p class="paragraph">
のように、前後行で同じ部分が沢山存在します。なので、同じ部分の文字列長をうまく使えば、データを大幅に圧縮出来ます。・・・それとbigramを組み合わせたりする処理が難しくて理解しきれなかった訳です。
<br />
一応 &quot;code/locate.code.c&quot; の冒頭に、コメントで仕組みが解説されてはいます。
<br />
</p>
<pre class="plugin_pre">
/*
 * PURPOSE:     sorted list compressor (works with a modified &#039;find&#039;
 *              to encode/decode a filename database)
 *
 * USAGE:       bigram &lt; list &gt; bigrams
 *              process bigrams (see updatedb) &gt; common_bigrams
 *              code common_bigrams &lt; list &gt; squozen_list
 *
 * METHOD:      Uses &#039;front compression&#039; (see &quot;;login:&quot;, Volume 8, Number 1
 *              February/March 1983, p. 8).  Output format is, per line, an
 *              offset differential count byte followed by a partially bigram-
 *              encoded ascii residue.  A bigram is a two-character sequence,
 *              the first 128 most common of which are encoded in one byte.
 *
 * EXAMPLE:     For simple front compression with no bigram encoding,
 *              if the input is...              then the output is...
 *
 *              /usr/src                         0 /usr/src
 *              /usr/src/cmd/aardvark.c          8 /cmd/aardvark.c
 *              /usr/src/cmd/armadillo.c        14 armadillo.c
 *              /usr/tmp/zoo                     5 tmp/zoo
 *
 *      The codes are:
 *
 *      0-28    likeliest differential counts + offset to make nonnegative
 *      30      switch code for out-of-range count to follow in next word
 *      128-255 bigram codes (128 most common, as determined by &#039;updatedb&#039;)
 *      32-127  single character (printable) ascii residue (ie, literal)
 *
 * SEE ALSO:    updatedb.csh, bigram.c
 *
 * AUTHOR:      James A. Woods, Informatics General Corp.,
 *              NASA Ames Research Center, 10/82
 */
</pre>
<p class="paragraph">
が、これと実際のコードだけでは自分のオツムでは理解出来ませんでした・・・。
<br />
</p>
<pre>$ cat filelist
/bin/prog1
/bin/prog2
/usr/bin/prog1
/usr/bin/prog2
/usr/bin/prog3abc
/usr/bin/prog4
$ /usr/libexec/locate.bigram &lt; filelist
usror/progn/ing1bibc3a/p/b
$ /usr/libexec/locate.code usror/progn/ing1bibc3a/p/b &lt; filelist &gt; result
$ od -h result
0000000     7375    6f72    2f72    7270    676f    2f6e    6e69    3167
0000020     6962    6362    6133    702f    622f    0000    0000    0000
0000040     0000    0000    0000    0000    0000    0000    0000    0000
*
0000400     8c0e    8b86    8781    3217    8006    8882    8385    3184
0000420     321a    8a0e    0e89    0034
0000427
$ od -a result
0000000    u   s   r   o   r   /   p   r   o   g   n   /   i   n   g   1
0000020    b   i   b   c   3   a   /   p   /   b nul nul nul nul nul nul
0000040  nul nul nul nul nul nul nul nul nul nul nul nul nul nul nul nul
*
0000400   so  8c  86  8b  81  87 etb   2 ack  80  82  88  85  83  84   1
0000420  sub   2  so  8a  89  so   4
0000427
</pre>
<p class="paragraph">
他の実験結果から、先頭256バイトまでが &quot;locate.bigram&quot; が生成したbigramデータ、それ以降が差分長とbigramを組み合わせた圧縮データになっているようです。
<br />
</p>

<p class="paragraph">
このデータを &quot;locate/locate.c&quot; が処理します。細かい処理は分かりませんでしたが、大枠の流れが以下のようになっているところまでは分かりました。
<br />
</p>
<ol><li> データファイルのリストを生成する。(&quot;:&quot;区切りのLOCATE_PATH環境変数、およびコマンドライン引数、locate/pathnames.h中でのハードコード定義をマージする)</li>
<li> コマンドラインで指定された検索キーワード毎に、データファイルのリストを探索していく。データファイルのFILEポインタがfastfind()に渡される。<ol><li> fastfind()の中では、最初にデータファイル先頭のbigramデータが内部バッファにロードされる。</li>
<li> 続いてキーワードにパターンマッチ用の文字が入っていれば、patprep()関数で前処理を行う。</li>
<li> データファイルを1文字ずつ読んでいく。都度復号化し、キーワードまたはパターンにマッチするかチェックしていく。</li></ol></li></ol>

<p class="paragraph">
理解出来たのはここまでで・・・結局一番重要なデータファイルの構築や解析部分はお手上げでした・・・。
<br />
</p>


<p class="paragraph">
今回のお題については、ここまで。
<br />
</p>

<p class="paragraph">
「デーモン君のソース探検」でもデーモンパパの台詞として「昔はディスク容量も小さくて高価だったので、苦労して圧縮を行っていた」とありますが、過去の偉人の苦労が良くわかるソース探検でした。
<br />
</p>

<p class="paragraph">
自分はWebアプリがメインでしたので、HTMLを整えたりRDBに対してSQLを発行したり、あとは共通部分をうまくライブラリ化したりなどに注力してきた為、今回のようなアルゴリズムが全面に出てくるソースは殆ど書いたことが無かったです。
<br />
同じ「プログラマ」でも、住んでる場所・時間により随分と力量差がついてしまうものなんですね・・・。
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-544.html" title="C言語系/「デーモン君のソース探検」読書メモ/04, uuencode(1),uudecode(1)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-547.html" title="C言語系/「デーモン君のソース探検」読書メモ/06, factor(1)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-546.html" title="C言語系/「デーモン君のソース探検」読書メモ">Up</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/545<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2001 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" target="_blank" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>