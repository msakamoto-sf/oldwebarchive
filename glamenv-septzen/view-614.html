<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Assembler/なぜx86ではMBRが&quot;0x7C00&quot;にロードされるのか？(完全版) - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">Assembler/なぜx86ではMBRが&quot;0x7C00&quot;にロードされるのか？(完全版)</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-03-16 12:36:57 &nbsp; / &nbsp; last updated at: 2010-05-13 11:07:47<br>
カテゴリ: <a href="category-48.html">Assembler</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-610.html" title="Assembler/なぜx86ではMBRが&quot;0x7C00&quot;にロードされるのか？">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-410.html" title="Assembler">Assembler</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
English Version: &quot; <a href="./view-en-6.html" target="_blank" >Why BIOS loads MBR into 0x7C00 in x86 ?</a> &quot;
<br />
</p>

<p class="paragraph">
<a href="./view-610.html" >Assembler/なぜx86ではMBRが&quot;0x7C00&quot;にロードされるのか？</a><strong>で調査が不十分だった点を補った完全版です。</strong>
<br />
</p>

<dl>
<dt> 対象読者 </dt>
<dd>x86アーキテクチャとアセンブラの基礎知識があり、MBRからのOSのロードに興味がある人（&quot;割り込みベクタ&quot;や&quot;INT xxx&quot;と言われても「？？？」とならない人）。</dd>
</dl>

<p class="paragraph">
自分がx86アーキテクチャの、特にOSのブートする仕組みやプロテクトモードを学習した時、MBR(Master Boot Record)で最初の一歩を踏み出した。MBRはフロッピーディスク(FDD)やHDDの最初の1セクタ：512バイトブロックである。OSをブートする機械語のプログラムと、ディスクの論理パーティション情報が格納されている。Interlの80x86系列のCPUを採用しているPCは、電源投入後、まずBIOSのPOST(Power On Self Test)が行われ、周辺機器が認識された後、MBRを読み込んでOSのブート処理を開始する。
<br />
</p>

<p class="paragraph">
BIOSはROMチップに書き込まれている為通常は変更出来ない(EEPROMなど、書き換え可能なROMを使っており、BIOSアップデートなどの特殊なソフトウェアを使うことで書き換えることができる)。一方のMBRはFDD/HDDの最初の1セクタということで、プログラマ自身が書き換えることが可能である。
<br />
2010年現在、Bochs, QEMU, VirtualBox, VMwareなどの仮想環境を手軽に活用できる環境が整っている。
<br />
そうした仮想環境を利用すれば、仮想環境用のディスクイメージファイルのMBR部分に好きな機械語を書き込むだけで、手軽に機械語の実験を行うことが可能になる。ホストOS側の現実の物理HDDのMBRを書き換えてOSが立ち上がらなくなる心配も無い。
<br />
</p>

<p class="paragraph">
多くの書籍やWebの記事では次のような流れでMBRのコードが実行される、と説明している。
<br />
</p>
<ol><li> BIOSがPOST(Power On Self Test)を実行</li>
<li> POST後、BIOSはFDD or HDDのMBRを<strong>0x7C00</strong>にロードし、そこから処理を続行する。(もちろんCD/DVDからブートすることも出来るが、本記事ではFDD/HDDからのブートを扱う。)</li>
<li> MBRにはOSのカーネルをロードし、実行する為の機械語が格納されており、OSのブートが始まる。</li></ol>

<p class="paragraph">
MBRから直接OSのカーネルをロードするのではなく、一つ or 二つ程度の中間ローダを介する場合もある。MBRの機械語コード、およびMBRがロード＆実行する中間ローダはOS固有の場合(MicrosoftのNTLDR)もあれば、複数のOSに対応したオープンソースソフトウェアの場合(LILO, GRUB)もある。
<br />
</p>

<p class="paragraph">
ところで、実際にMBRを弄った人は、次の疑問を抱いたことはないだろうか？
<br />
</p>
<pre>「&quot;0x7C00&quot;って、どこの仕様書で決められているんだろうか？」
</pre>

<p class="paragraph">
x86CPUについて学んでいくと、独特の&quot;メモリアドレスのマジックナンバー&quot;がいくつかあることに気づく。
<br />
</p>

<dl>
<dt> 64KBの壁 </dt>
<dd>もちろん、「セグメント16bit:オフセット16bit」の組み合わせによる、1セグメント64KBの制限値である。</dd>
<dt> 0x3FF </dt>
<dd>
<p class="paragraph">
これは割り込みベクタ用のメモリ空間で、
<br />
</p>
<pre>4バイトの割り込みハンドラのアドレス x 256個の割り込みベクタ
= 1024バイト
= 0x400 バイト
</pre>
<p class="paragraph">
で、x86の仕様として割り込みベクタはアドレス0番地から始まる為、一つ分ずらした値となる。
<br />
</p></dd>
<dt> 0xFFFFF(1MB) </dt>
<dd>リアルモードでの最大アドレス値。これは80186以前はアドレスバスが20本、20bit = 指定可能な最大値が0xFFFFFだったことに基づく。</dd>
<dt> 0xFFFF0 </dt>
<dd>IBM PC(5150)の誕生に深く関わる Intel 8086/8088 が、電源投入の初期化後に最初に処理を開始するアドレス。</dd>
</dl>

<p class="paragraph">
・・・ところが、&quot;0x7C00&quot; の意味については、CPU関連を調べても何も分からない。ブートローダやMBR関連の情報を調べても、単に0x7C00にロードされる、と書かれているだけで、なぜこの値なのか？誰が決めたのか？についての情報は皆無にみえる。
<br />
</p>

<p class="paragraph">
前ぶりが長くなったが、<strong>本記事はMBRがロードされる &quot;0x7C00&quot; というアドレスの起源と、その意味について調べた結果をまとめている。</strong>
<br />
</p>

<p class="paragraph">
この記事単体で何かしら「使える」知識を増やすことは出来ないが、もしも読者のあなたが &quot;0x7C00&quot; について喉に魚の骨が刺さったままのような感触を覚えているのであれば、ぜひ一読をお奨めしたい。
<br />
</p>




<ul><li><a href="#id34d57f">IBM PC(5150) 誕生前後の流れの再確認</a></li>
<li><a href="#id32118c">86-DOS → PC-DOS + ROM BIOS</a><ul><li><a href="#ida20496">閑話休題：0xFFFF0(Intel 8086/8088がハードリセット後に最初に実行するアドレス)</a></li>
<li><a href="#id685c86">86-DOS のブートプロセス(MBRを200Hにロード)</a></li>
<li><a href="#id8b84fd">86-DOSがbootstrapを 200H にロードする理由 (From Tim Paterson)</a></li></ul></li>
<li><a href="#id0e0019">IBM PC(5150) ROM BIOS INT19h</a><ul><li><a href="#idd33035">INT 19h までの流れ(MBRを7C00Hにロード)</a></li>
<li><a href="#idfb7752">IBM PC 5150 の ROM BIOS INT 19h が MBR を 7C00H(0x7C00) にロードする理由 (From Dr. David Bradley)</a></li></ul></li>
<li><a href="#id2f6285">参考資料</a><ul><li><a href="#iddbc046">&quot;Personal Computer&quot;の歴史</a><ul><li><a href="#id2ebeaa">Apple関連</a></li>
<li><a href="#idcf607d">NEC勢</a></li>
<li><a href="#idd110b2">CP/M関連</a></li>
<li><a href="#id46fc2a">86-DOS, Tim Paterson 氏, 初期のMS-DOS(PC-DOS)関連</a></li>
<li><a href="#id892d67">初期のMS-DOSの日本語資料</a></li>
<li><a href="#idf8e185">IBM PC 5150 前後の歴史について</a></li>
<li><a href="#id0ade81">David Bradley氏関連</a></li></ul></li>
<li><a href="#id5cef82">BIOS, MBR, アセンブラ関連</a></li>
<li><a href="#id14373b">Intel x86 の初期CPUのWikipedia</a></li></ul></li>
<li><a href="#idc71687">Special Thanks</a></li></ul>
<hr />
<h3 id="id34d57f">IBM PC(5150) 誕生前後の流れの再確認</h3>

<p class="paragraph">
&quot;0x7C00&quot; が<strong>「いつ」</strong>現れたのかについて先に結論を言うと<strong>1981年8月に発表された IBM Personal Computer (PC) 5150の ROM BIOS</strong>で初めて現れた。
<br />
</p>

<p class="paragraph">
IBM PC 5150は16bit/8bit両対応のCPU Intel 8088 を使った、現在に連なるx86アーキテクチャのご先祖様に相当する。短い開発期間と、それまでのIBMのやり方と異なるオープンアーキテクチャの採用など、歴史の転換点にふさわしくその誕生はドラマティックな数々のエピソードに彩られている。
<br />
ここでIBM Personal Computer(PC), モデル番号5150誕生前夜の歴史について簡単に確認しておく。
<br />
</p>

<p class="paragraph">
Intel 4004 に始まる汎用CPUは、8bitの Intel 8080(1974年) でマイクロコンピュータ市場を席巻した。MITS Altair8800(1975年) にも搭載された。Digital Research社のOS、CP/M は1974-1975年前後に誕生したとされているが、8bitマイコン市場の盛り上がりと共に、CP/Mは互換CPUやほかのマイコンシステムへの移植が進んでいった。
<br />
</p>

<p class="paragraph">
当時既にメインフレーム市場で巨人となったIBMも、その流れを無視していたわけではない。
<br />
1975年には &quot;5100 Portable Computer&quot; を発表、1978年には &quot;IBM 5110 Computing System&quot;、1979年には &quot;5520 Administrative System&quot;、1980年2月には &quot;5120 Computer System&quot; と、机の上に載るサイズのコンピュータシステムを発表している。しかしいずれもビジネスオフィス、あるいは科学技術計算用途に使われており、マイコン市場には食い込めていない。
<br />
</p>

<p class="paragraph">
1980年、ドン・エストリッジをリーダーとする12人のチームは、1年という制約期間でIBM初の &quot;Personal Computer&quot; を開発し、マイコン市場に挑戦する事になる。この時に採用されたのが 8bit/16bit両対応の Intel 8088である。
<br />
ソフトウェアでさしあたり必要なのはプログラミング言語とOSで、プログラミング言語はMicrosoft社の開発したBASICをROMに搭載することになった。OSについては、一度Digital Research社のCP/Mを採用しようと商談を進めたようだがうまくまとまらず、こちらも最終的にMicrosoft社に依頼することになった。当時マイコン市場で人気のCP/Mに対応したソフトを動かしたいということで、CP/M互換OSの開発を依頼した。
<br />
</p>

<p class="paragraph">
この辺は有名な話になるが、当時のMicrosoft社にはOSを開発した経験が無かった。どうしたかというと、Seatle Computer Products(SCP)のTim Patersonが開発した8086対応のCP/M互換OS、&quot;86-DOS&quot;(初期には&quot;QDOS : Quick and Dirty Operating System&quot;と呼ばれていた)を買い取り、それをベースにIBM PC 5150用のCP/M互換OSを開発した。
<br />
</p>

<p class="paragraph">
1979年当時は&quot;S-100&quot;というバスを使ったマイコンがAltair8800やIMSAI 8080で主に使われており、SCPもS-100バスに挿せる形で8086CPUボードとそのOSを提供しようとしていた。OSについては当初はDigital Research社により8086に対応したCP/Mが提供されるのを期待していたらしい。
<br />
1979年の11月には、SCPによる8086CPUボードとスタンドアロンで動作するBASICが出荷されたが、中々CP/Mの8086対応が進まないため、自分達で互換OSを開発することを1980年の4月に決定。
<br />
1980年の8月にはQDOS 0.10をリリースし、1980年の年末には &quot;86-DOS&quot; ver 0.3 をリリース、同時にMicrosoft社に提供している。
<br />
これとほぼ同時期に、Digital Research社も8086対応のCP/M-86をリリース。
<br />
1981年の7月にはMicrosoftによりDOSの全権利が買い取られ、1981年の8月、86-DOSと「非常によく似たOS」であるPC-DOSがIBM PC 5150とともに発表される事になる。
<br />
</p>

<h3 id="id32118c">86-DOS → PC-DOS + ROM BIOS</h3>

<p class="paragraph">
2010年現在のPCでは、マザーボード上のROMチップにBIOSが搭載され、OSはHDDなど外部記憶ディスクに保存されるのが常識となっている。この棲み分けは、まさしく IBM PC 5150 が原点となっている。
<br />
</p>

<p class="paragraph">
というのも、<strong>MS-DOSの原型にあたる86-DOS(とCP/M)ではBIOS相当の機能もOSの一部に含まれていた。</strong>
<br />
</p>

<p class="paragraph">
BIOSの機能というのは、
<br />
</p>
<ol><li> メモリやCPUのチェック、周辺機器の認識など現在のPOSTにあたる機能に加え、</li>
<li> CP/M互換OSが使うソフトウェア割り込み処理も含まれる。</li></ol>

<p class="paragraph">
もちろんPOST処理は重要だが、それ以上にOSが使うソフトウェア割り込みも重要で、これにより画面上に文字や図形を描画したり、FDD/HDDにアクセスしてデータを読み出したり、ファイル処理やプログラムをメモリ上にロードしたりしていた。当時はそうした機能が全て&quot;OS&quot;の中に含まれていたことになる。86-DOSのベースとなったCP/Mもそのようになっていた。
<br />
</p>

<p class="paragraph">
これが OS と BIOS に分離された形式になり、以降の流れを決定づけた起点が IBM PC 5150 である。
<br />
</p>

<h4 id="ida20496">閑話休題：0xFFFF0(Intel 8086/8088がハードリセット後に最初に実行するアドレス)</h4>

<p class="paragraph">
ここで、そもそもx86のCPU自身が、ハードリセット(電源投入)後電子回路のレベルで初期化され、最初に命令をフェッチするアドレスについて再確認しておきたい。
<br />
</p>
<table>
	<tr>
		<td> CPU </td>
		<td> CS </td>
		<td> IP </td>
		<td> 物理アドレス </td>
	</tr>
	<tr>
		<td> 8086/8088 </td>
		<td> F000H </td>
		<td> FFF0H </td>
		<td> FFFF0H </td>
	</tr>
	<tr>
		<td> 80286 </td>
		<td> F000H(※1) </td>
		<td> FFF0H </td>
		<td> FFFFF0H </td>
	</tr>
	<tr>
		<td> 80386以降 </td>
		<td> F000H(※2) </td>
		<td> FFF0H </td>
		<td> FFFFFFF0H </td>
	</tr>
</table>

<p class="paragraph">
どの世代でも、当時のマシンに搭載されていた標準的な物理メモリを越えた場所を指している。
<br />
これは割り込みベクタの影響でアドレス0を使えない為と、最初の命令フェッチから始まる初期化プログラムをなるべくアドレスの高位に配置することで、一般的なプログラムの使えるアドレス空間を邪魔しないようにとの意図らしい。
<br />
BIOSが格納されたROMは、電子回路のレベルでこれら高位アドレスにマッピングされるよう調整されている。
<br />
</p>

<p class="paragraph">
IBM PC 5150 ではROM BIOSがFE000以降にロードされるようになっており、丁度 FFFF0H に、BIOSコードの先頭へJMPする機械語コードが配置されている。（後述）
<br />
</p>

<p class="paragraph">
※1 : 80286は24bitのアドレスバスを持つが、リアルモードでは20bitしか使われない。A20-A23はリセット後は1になっている。そのため、CSこそ&quot;F000H&quot;になっているが、もう4bit分全て1のデータが上位に隠れている。
<br />
</p>
<pre>(F)F0000 H(CS) (4bit左シフト)
    FFF0 H(IP)
--------------
 F FFFF0 H
</pre>
<p class="paragraph">
となり、&quot;FFFFF0H&quot;が最初にフェッチされるアドレスとなる。
<br />
</p>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> &quot;M80C286 HIGH PERFORMANCE CHMOS MICROPROCESSOR WITH MEMORY MANAGEMENT AND PROTECTION&quot;<ul><li> &quot;Memory Addressing&quot;, &quot;Reserved Memory Locations&quot; (p10)</li></ul></li></ul>

<p class="paragraph">
※2 : 80386ではアドレスバスが32bitになるが、リアルモードでは20bitしか使われない。A20-A31はリセット後は1になっている。そのため、CSこそ&quot;F000H&quot;になっているが、もう12bit分全て1のデータが上位に隠れている。
<br />
</p>
<pre>(FFF)F0000 H(CS) (4bit左シフト)
      FFF0 H(IP)
--------------
 FFF FFFF0 H
</pre>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> &quot;INTEL 80386 PROGRAMMER&#039;S REFERENCE MANUAL 1986&quot;<ul><li> &quot;10.1 Processor State After Reset&quot; (p174)</li>
<li> &quot;10.2.3 First Instructions&quot; (p176)</li></ul></li></ul>

<h4 id="id685c86">86-DOS のブートプロセス(MBRを200Hにロード)</h4>

<p class="paragraph">
SCPは8086用CPUボードの他に&quot;CPU Support Card&quot;というボードも開発した。&quot;CPU Support Card&quot;にはデバッグ機能とbootstrapローダ機能を備えた、2KBの機械語プログラム(&quot;Monitor&quot;)が搭載されていた。
<br />
Monitorを使うと、マシン起動後はMonitorのコマンドプロンプトが最初に表示される。ここで&quot;B&quot;コマンドを実行することで、ディスクの先頭セクタをbootstrapとして 200H にロードし、bootstrapの先頭にジャンプして処理を続行する。
<br />
</p>

<p class="paragraph">
Monitorプログラムは8086のメモリ空間(1MB)の末尾2KBに位置するようになっている。
<br />
8086が電源投入後に最初にフェッチするアドレス FFFF0H には、Monitorプログラム上で次の機械語が配置されるようになっている。
<br />
</p>
<pre>JMP    0,0FF80H    ;Power-on jump to monitor
</pre>
<p class="paragraph">
セグメント指定のFARジャンプで、
<br />
</p>
<pre>FF80:0000 → FF800 H
</pre>
<p class="paragraph">
にジャンプすることになる。FF800HからはMonitor用のコードが始まる。
<br />
</p>

<p class="paragraph">
MON.ASM:
<br />
</p>
<pre class="plugin_pre">
;Start of Monitor code

	ORG	0
	PUT	PUTBASE ; 無視してOK(恐らく当時のアセンブラ独特の疑似命令)

;One-time initialization

	UP ; 今のアセンブラでは&quot;CLD&quot;
	XOR	AX,AX
	MOV	SS,AX
	(...)
</pre>

<p class="paragraph">
オフセット(ORG)が0になっているが、これは(恐らく)アセンブラの都合とMonitor用のボードの電子回路的な都合によるものだろう。
<br />
</p>

<p class="paragraph">
この時点でのメモリ空間：
<br />
</p>
<pre class="plugin_pre">
+---------------------- FFFFFH
|
+----------------------
| JMP 0,FF80H           FFFF0H
+----------------------
|
|
| Monitor コード        FF800H
+----------------------
|
|
+---------------------- 3FFH
|(割り込みベクタ)
+---------------------- 0H
</pre>

<p class="paragraph">
Monitorのコマンドプロンプトで&quot;B&quot;コマンドを実行すると、FDDの先頭512バイトを200Hにロードする。
<br />
</p>

<p class="paragraph">
MON.ASM:
<br />
</p>
<pre class="plugin_pre">
(...)
LOAD:	EQU	200H
(...)
COMTAB:
	DW	BOOT		;B
	DW	PERR		;C
(...)
BOOT:
	PUSH	DI
(以下、当時のディスクコントローラ毎に200Hにロードするコード)
;Successful read
	MOV	[CSSAVE],0
	MOV	[IPSAVE],LOAD
	POP	DI
	JMP	GO ; GOルーチン内でレジスタ調整後、CS:0000H,IP:200H(LOAD)へJMP
</pre>

<p class="paragraph">
これにより読み込まれるbootstrapのアセンブラが、BOOT.ASMとして86-DOSに同梱されている。
<br />
BOOT.ASMを読んでみると、SS(Stack Segment)に0, SP(Stack Pointer)に200Hをセットしている。bootstrap実行中の一時的なスタック領域は200Hから始まることが分かる。
<br />
</p>

<p class="paragraph">
BOOT.ASM(bootstrap)を200Hへロードした後のメモリ空間：
<br />
</p>
<pre class="plugin_pre">
+---------------------- FFFFFH
|
+----------------------
| JMP 0,FF80H           FFFF0H
+----------------------
|
|
| Monitor コード        FF800H
+----------------------
|
|
+---------------------- 3FFH これ以下↓が8086の割り込みベクタ
| BOOT.ASM
+---------------------- 200H これ以下↓がBOOT.ASMが使うスタック領域
|
+---------------------- 0H
</pre>

<p class="paragraph">
200HにロードされたBOOT.ASM中では引き続きシステムをディスクからロードする処理が続く。BOOT.ASMではOSの基本部分を400H以降にロード後、400HにJMPする。ちょうど400Hから始まるOSの基本部分の一部が、DOSIO.ASMとして86-DOSに同梱されている。
<br />
</p>

<p class="paragraph">
BOOT.ASM:
<br />
</p>
<pre class="plugin_pre">
	ORG	BOOTER
	(...)
	MOV	DI,LOAD   ; LOAD equ 400H
	(...)
READ:
	(...)
DONE:
	(...)
	JMP	0,SEG ; SEG equ 40H
</pre>

<p class="paragraph">
最後のJMPはfarジャンプとなり、CS:40H, IP:0H → 400Hにジャンプする。
<br />
</p>

<p class="paragraph">
ちなみに、まだこの時点では割り込みベクタは初期化されていない。MON.ASMやBOOT.ASMを読んでみるとINT命令が全く使われていないことに驚く。
<br />
</p>

<p class="paragraph">
OSの基本部分を400Hへロードした後のメモリ空間：
<br />
</p>
<pre class="plugin_pre">
+---------------------- FFFFFH
|
+----------------------
| JMP 0,FF80H           FFFF0H
+----------------------
|
|
| Monitor コード        FF800H
+----------------------
|
| DOSIO.ASM + その他OS
| の基本部分
+---------------------- 400H以上↑領域
+---------------------- 3FFH これ以下↓が8086の割り込みベクタ
| BOOT.ASM
+---------------------- 200H これ以下↓がBOOT.ASMが使うスタック領域
|
+---------------------- 0H
</pre>

<p class="paragraph">
いよいよOSの初期化処理が始まる。400HにJMP後、SSは0にクリアされ、SPも400Hに変更される。BOOT.ASMはもう使わないので、直前までBOOT.ASMがロードされていた 200H - 3FFH のメモリ空間をOSの初期化処理用のスタック領域に使うことを意味する。
<br />
SS, SP調整後、この時点でロード済のメモリ 800H 以降のルーチンをCALLする。
<br />
</p>

<p class="paragraph">
DOSIO.ASM:
<br />
</p>
<pre class="plugin_pre">
	(...)
DOSSEG:	EQU	80H
	ORG	0
	(...)
	JMP	INIT
	(...)
INIT:
	(...)
	XOR	AX,AX	; AXが0クリア
	MOV	SS,AX	; SSが0Hに。
	MOV	SP,400H		;Set stack just below I/O system
	(...)
	CALL	0,DOSSEG	; 80H:0Hのサブルーチン呼び出し
	MOV	DX,100H
	MOV	AH,26		;Set DMA address
	INT	21H
	(以下、COMMAND.COMの起動へ続く)
</pre>

<p class="paragraph">
この 800H のルーチンCALLにより、INT20h以降のソフトウェア割り込みベクタが調整され、OSの提供するINT機能が使えるようになる。
<br />
800Hより戻ってきたら、引き続きCOMMAND.COMの起動に入り、OSのユーザに対するインターフェイスである、コマンドプロンプトを開始する。(COMMAND.COM起動時にはSS,SPも再調整される)
<br />
</p>

<p class="paragraph">
COMMAND.COM起動後のメモリ空間：
<br />
</p>
<pre class="plugin_pre">
+---------------------- FFFFFH
|
+----------------------
| JMP 0,FF80H           FFFF0H
+----------------------
|
|
| Monitor コード        FF800H
+----------------------
|
| OS + COMMAND.COM
| + ユーザープログラム
|
+---------------------- 400H
+---------------------- 3FFH
|(割り込みベクタ)
+---------------------- 0H
</pre>

<p class="paragraph">
以上が86-DOSのブートの流れである。
<br />
</p>

<p class="paragraph">
参考：
<br />
</p>
<ul><li> 86-DOS Resource Website<ul><li> <a class="externallink" href="http://www.86dos.org/index.htm" target="_blank">http://www.86dos.org/index.htm</a><ul><li> &quot;86DOS_FILES.ZIP&quot;中のMON.ASM, BOOT.ASM, DOSIO.ASM</li></ul></li></ul></li>
<li> Early DOS Manuals<ul><li> <a class="externallink" href="http://www.patersontech.com/dos/manuals.aspx" target="_blank">http://www.patersontech.com/dos/manuals.aspx</a><ul><li> &quot;First Advertisement for the 8086 Computer&quot;</li>
<li> &quot;8086 Monitor Instruction Manual&quot;</li>
<li> &quot;86-DOS Instruction Manual&quot;</li>
<li> &quot;86-DOS Programmer&#039;s Manual&quot;</li></ul></li></ul></li></ul>

<h4 id="id8b84fd">86-DOSがbootstrapを 200H にロードする理由 (From Tim Paterson)</h4>

<p class="paragraph">
86-DOS ではディスクの先頭に配置されているbootstrapを 200H にロードしている。
<br />
この &quot;200H&quot; という値は、8086の割り込みベクタ(0H - 3FFH)の内部である。
<br />
Tim Paterson によれば、CPUの割り込みベクタ内であり仕様的には「予約済」であることと、そのためにOS自身は0H-3FFH内には絶対にロードされない「安全地帯」であることが、200Hを選択した理由とのこと。
<br />
</p>

<p class="paragraph">
From Tim Paterson:
<br />
</p>
<blockquote><p class="paragraph">
At SCP, I chose 0x200 because it was in the interrupt vector space (0 -
<br />
3FFH). This means it needed to be reserved and couldn&#039;t be in the way of
<br />
an OS, no matter where it wanted to load.
<br />
</p></blockquote>

<p class="paragraph">
まとめると
<br />
</p>
<ol><li> 0x0 - 0x3FF は8086の仕様上、割り込みベクタに使われていた。</li>
<li> 0x400 以降に86-DOSのシステムがロードされる。</li>
<li> 0x200 - 0x3FF の間の割り込みベクタは86-DOSの時点では特に使っていなかった。</li></ol>

<p class="paragraph">
以上の理由で 200H - 3FFH の間の隙間が使われた。ちなみに、100H - 200H の間も、レジスタの退避やMonitor/bootstrapなどの初期処理が使うスタック領域として利用されていたらしい。
<br />
</p>

<h3 id="id0e0019">IBM PC(5150) ROM BIOS INT19h</h3>

<p class="paragraph">
86-DOSやCP/Mでは、bootstrapのロードや割り込みベクタの調整と対応するハンドラなどが全て&quot;OS&quot;の中に含まれていた。
<br />
これが、IBM PC 5150において次のように分裂した。
<br />
</p>
<ul><li> ROM BIOS<ul><li> IBMが開発</li>
<li> OSに関わらず最低限度必要な機能(bootstrapのロードや基本的な割り込みハンドラ、POST処理)</li></ul></li>
<li> OS本体 + MBR<ul><li> Microsoftが開発</li>
<li> bootstrap(MBR)やOS固有の初期化処理、割り込みハンドラ、COMMAND.COM</li></ul></li></ul>

<p class="paragraph">
86-DOSやCP/Mが厳密にMS-DOSの祖先かというと議論が必要なようだが(例：メモリレイアウトの設計コンセプトが大幅に変更されている。86-DOSでは&quot;640KBの壁&quot;という制限は無かった。)、とにかく、IBMとMicrosoftの二社協同で分担したことが、現在に至るBIOSとOSの役割分担の起源であることは間違いないだろう。
<br />
</p>

<p class="paragraph">
IBM PC 5150 の ROM BIOS でMBRを 7C00H にロードするのは INT 19h というソフトウェア割り込みハンドラである。
<br />
これは ROM BIOS により割り込みベクタに登録されると共に、POST後に INT 命令で呼ばれる。
<br />
ちなみに5150ではROM BASICを起動する INT 18h というソフトウェア割り込みも存在し、INT 19hでMBRのロードに失敗した場合に INT 18h が呼ばれるようになっていた。
<br />
</p>

<h4 id="idd33035">INT 19h までの流れ(MBRを7C00Hにロード)</h4>

<p class="paragraph">
5150のROM BIOSのアセンブラリストは、&quot;IBM Personal Computer Technical Reference manual&quot;に掲載されている。
<br />
実際にBIOSのアセンブラコードを追いつつ、INT 19hまでの流れを簡単に追ってみる。
<br />
</p>

<p class="paragraph">
line.6199 - :
<br />
</p>
<pre class="plugin_pre">
VECTOR SEGMENT AT 0FFFFH
	JMP RESET
	DB &#039;10/27/82&#039; ; RELEASE MARKER
VECTOR ENDS
</pre>
<p class="paragraph">
&quot;SEGMENT&quot; - &quot;ENDS&quot; はコードの配置を決定する擬似コード。セグメントが &quot;0FFFFH&quot; で先頭がJMP命令と言うことは、物理アドレス上は
<br />
</p>
<pre>FFFFH:0000H = FFFF0H : JMP RESET
</pre>
<p class="paragraph">
ということになる。つまり、CPUのハードリセット直後にフェッチされる命令は&quot;RESET&quot;ラベルへのJMPとなる。
<br />
ちなみに&quot;RELEASE MARKER&quot;が1982年になっているが、入手出来たドキュメントのバージョンが1983年4月の改訂版なので、その影響だろう。
<br />
RESETラベルは308行に存在し、8088CPUのテストコードが始まる。以降、現在のPOSTに相当するCPU/メモリ/HWのチェックコードが続く。
<br />
</p>

<p class="paragraph">
line.306 - :
<br />
</p>
<pre class="plugin_pre">
	ASSUME CS:CODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
	ORG 0E05BH
RESET LABEL FAR
START:
	CLI			; DISABLE INTERRUPTS
	MOV AH,0D5H
	SAHF
	(...)
</pre>

<p class="paragraph">
気になるのが、
<br />
</p>
<pre>ASSUME CS:CODE,...
</pre>
<p class="paragraph">
と
<br />
</p>
<pre>ORG 0E05BH
</pre>
<p class="paragraph">
の二行。なぜ初期化コードが中途半端な場所から始まるのか？
<br />
まず &quot;CODE&quot; については224行目で次のようにSEGMENT 0F000H が指定されている。
<br />
</p>

<p class="paragraph">
line. 224 - :
<br />
</p>
<pre>CODE SEGMENT AT 0F000H
</pre>

<p class="paragraph">
その直後、56KB分データ領域(?)を確保している。
<br />
line. 225 - :
<br />
</p>
<pre>    DB 57344 DUP(?)   ; FILL LOWEST 56K
</pre>

<pre>57344 = E000 H
</pre>
<p class="paragraph">
となり、さらにE000Hから暫くはデータやストレージのR/Wテスト用サブルーチンが配置されており、結果としてRESETラベルは &quot;0E05BH&quot; から始まる。
<br />
</p>

<p class="paragraph">
RESETラベルから始まる初期処理に戻ると、1132行目からDISKETTE(FDD)のテストに入り、OKであればINT 19hを呼ぶ。
<br />
line. 1132 - :
<br />
</p>
<pre class="plugin_pre">
;-----------------------------------------------------------------------;
;       DISKETTE ATTACHMENT TEST                                        ;
; DESCRIPTION                                                           ;
;       CHECK IF IPL DISKETTE DRIVE IS ATTACHED TO SYSTEM. IF ATTACHED, ;
;       VERIFY STATUS OF NEC FDC AFTER A RESET. ISSUE A RECAL AND SEEK  ;
;       CMD TO FDC AND CHECK STATUS. COMPLETE SYSTEM INITIALIZATION     ;
;       THEN PASS CONTROL TO THE BOOT LOADER PROGRAM.                   ;
;-----------------------------------------------------------------------;
F9:
	MOV AL, BYTE PTR EQUIP_FLAG
	(...)
(line. 1261)
;----- ENABLE NMI INTERRUPTS
	MOV AL,80H ; ENABLE NMI INTERRUPTS
	OUT 0A0H,AL
	CMP MFG_TST,1 ; MFG MODE?
	JE F21 ; LOAD BOOT_STRAP
	MOV DX,1
	CALL ERR_BEEP ; BEEP 1 SHORT TONE

F21:            ; LOAD_BOOT_STRAP:
	INT 19H     ; BOOTSTRAP
</pre>

<p class="paragraph">
割り込みベクタはいつ初期化されたのか？E05Bから始まる初期処理の途中、595行目からBIOS用の割り込みベクタの初期化が行われている。line. 595 - :
<br />
</p>
<pre class="plugin_pre">
;----- SET UP THE BIOS INTERRUPT VECTORS TO TEMP INTERRUPT
	MOV CX, 32          ; FILL ALL 32 INTERRUPTS
	SUB DI,DI           ; FIRST INTERRUPT LOCATION
D3:
	MOV AX,OFFSET D11   ; MOVE ADDR OF INTR PROC TO TBL
	STOSW
	MOV AX, CS          ; GET ADDR OF INTR PROC SEG
	STOSW
	LOOP D3             ; VECTBL0

;----- SET UP OTHER INTERRUPTS AS NECESSARY
	MOV NMI_PTR,OFFSET NMI_INT       ; NMI INTERRUPT
	MOV INT5_PTR,OFFSET PRINT_SCREEN ; PRINT SCREEN
	MOV BASIC_PTR+2,0F600H           ; SEGMENT FOR CASETTE BASIC
</pre>
<p class="paragraph">
（すみません、この辺はきちんと読み切れてません。この直ぐ上の592行目で既に INT 3EH が呼ばれていたりするので、割り込みの種類毎に何段階かにわけて初期化しているのかもしれません。あるいは途中の分岐を読み飛ばしている、など。少なくとも INT 19h の読み出しまでに、割り込みベクタが初期化されていることは確かです。でないとINT 19hをそもそも呼べないので。）
<br />
</p>

<p class="paragraph">
INT 19h の割り込みハンドラは1493行目から始まる。
<br />
line. 1493 - :
<br />
</p>
<pre class="plugin_pre">
;--- INT 19 ------------------------------------------------------
; BOOT STRAP LOADER                                              ;
;       IF A 5 1/4&quot; DISKETTE DRIVE IS AVAILABLE ON THE SYSTEM,   ;
;       TRACK 0, SECTOR 1 IS READ INTO THE BOOT LOCATION         ;
;       (SEGMENT 0, OFFSET 7C00) AND CONTROL IS TRANSFERRED      ;
;       THERE.                                                   ;
;                                                                ;
;       IF THERE IS NO DISKETTE DRIVE, OR IF THERE IS A          ;
;       HARDWARE ERROR CONTROL IS TRANSFERRED TO THE RESIDENT    ;
;       BASIC ENTRY POINT.                                       ;
;                                                                ;
; IPL ASSUMPTIONS;                                               ;
;       8255 PORT 60H BIT 0 = 1 IF IPL FROM DISKETTE             ;
;-----------------------------------------------------------------
		ASSUME CS:CODE,DS:ABS0

;----- IPL HAS SUCCESSFUL
H4:
	JMP     BOOT_LOCN
	ORG     0E6F2H
BOOT_STRAP  PROC NEAR
	STI                            ; ENABLE INTERRUPTS
	(...)

;----- MUST LOAD SYSTEM FROM DISKETTE -- CX HAS RETRY COUNT
	MOV     CX,4                   ; SET RETRY COUNT
H1:                                ; IPL_SYSTEM
	PUSH    CX                     ; SAVE RETRY COUNT
	MOV     AH,0                   ; RESET THE DISKETTE SYSTEM
	INT     13H                    ; DISKETTE_IO
	JC      H2                     ; IF ERROR, TRY AGAIN
	MOV     AX,201H
	SUB     DX,DX
	MOV     ES,DX
	MOV     BX,OFFSET BOOT_LOCN
	MOV     CX,1                   ; SECTOR 1, TRACK 0
	INT     13H                    ; DISKETTE_IO
H2: POP     CX                     ; RECOVER RETRY COUNT
	JNC     H4                     ; CF SET BY UNSUCCESSFUL READ
	LOOP    H1                     ; DO IT FOR RETRY TIMES

;----- UNABLE TO IPL FROM THE DISKETTE
H3:                                ; CASSETE_JUMP:
	INT     18H                    ; USE INTERRUPT VECTOR TO GET TO BASIC
BOOT_STRAP  ENDP
</pre>

<p class="paragraph">
&quot;H4&quot;ラベルがなぜ&quot;BOOT_STRAP&quot;の前に位置しているのかが謎だが、とにかく、&quot;H2&quot;ラベルで読み出し成功と判断されると&quot;JNC H4&quot;でH4にジャンプし、そのまま &quot;BOOT_LOCN&quot; にジャンプするようになっている。
<br />
&quot;BOOT_LOCN&quot;はROM BIOSのアセンブラリストの冒頭で<strong>7C00H</strong>にEQU(equate)されている。
<br />
</p>

<p class="paragraph">
line. 34 - :
<br />
</p>
<pre class="plugin_pre">
;---------------------------------
;    8088 INTERRUPT LOCATIONS    ;
;---------------------------------
ABS0          SEGMENT   AT 0
STG_LOC0      LABEL     BYTE
              ORG       2*4
NMI_PTR       LABEL     WORD
              ORG       5*4
INT5_PTR      LABEL     WORD
(...)
              ORG       7C00H
BOOT_LOCN     LABEL     FAR
ABS0          ENDS
</pre>

<p class="paragraph">
ここで、
<br />
</p>
<pre>JMP BOOT_LOCN
</pre>
<p class="paragraph">
がセグメント内のNEARジャンプになってしまうのでは？と疑問に思った人もいるだろう。
<br />
ROM BIOSのアセンブラリストには、対応する機械語も掲載されている。このJMPに対応する機械語を見てみると、次のようになっている。
<br />
</p>
<pre>EA007C0000
=
E    A    00 7C        00 00
1110 1010 (offset L-H) (segment L-H)
</pre>
<p class="paragraph">
よって、これはセグメント指定のFARジャンプであり、ジャンプ後は
<br />
</p>
<pre>CS:0000H, IP:7C00H
</pre>
<p class="paragraph">
となる。よって問題なく、0000:7C00HにJMPできる。
<br />
</p>

<h4 id="idfb7752">IBM PC 5150 の ROM BIOS INT 19h が MBR を 7C00H(0x7C00) にロードする理由 (From Dr. David Bradley)</h4>

<p class="paragraph">
いよいよ 7C00H の謎が解かれる。
<br />
が、その前に 7C00H のそもそもの謎について再確認したい。
<br />
</p>

<p class="paragraph">
まず 7C00H というのは
<br />
</p>
<pre>32KB(8000H) - 1024B
</pre>
<p class="paragraph">
である。先頭から32KB、その丁度1024バイト手前が、7C00Hである。まず一点目、この&quot;32KB - 1024 = 7C00&quot;というのがいかにも意味ありげであり、なぜこの場所にしたのか？というのが謎の一つめ。
<br />
</p>

<p class="paragraph">
謎の２つ目が、IBM PC 5150 発表時の最小メモリモデルが<strong>16KB(4000H) のRAMしか積んでいない</strong>こと。つまり、16KBのRAMでは当然7C00にMBRをロードすることは出来ない。よって16KBモデルではDOSを起動出来なかったのではないか？
<br />
</p>

<p class="paragraph">
まとめると：
<br />
</p>
<ul><li> &quot;0x7C00&quot; は 32KB - 1024Bに位置する。なぜこの位置なのか？</li>
<li> 5150の最小メモリモデルは16KBしかRAMを搭載していない。 → 16KBのモデルではOSを起動出来なかったのではないか？(0x7C00にアクセス出来ない)</li></ul>

<p class="paragraph">
この２点について、IBM PC 5150 の ROM BIOS の開発者、David Bradley氏にメールで質問してみた。同氏は&quot;Ctrl-Alt-Delete&quot;によるリセット機能を実装したことで知られている。
<br />
</p>

<p class="paragraph">
なお質問で「86-DOSは200Hにロードするが、なぜ変更したのか？」というのも含めたが、
<br />
</p>
<blockquote><p class="paragraph">
I don&#039;t know anything about 86-DOS.
<br />
</p></blockquote>
<p class="paragraph">
と回答している。つまり同氏は 86-DOS のコードは見ずに、つまり &quot;86-DOSは200Hにbootstrapをロードする&quot; 事実は知らないまま、ROM BIOSを開発した。
<br />
</p>

<p class="paragraph">
ではDavid Bradley氏からの回答で、まずは16KBモデルについての回答から。
<br />
</p>
<blockquote><p class="paragraph">
It had to boot on a 32KB machine.
<br />
DOS 1.0 required a minimum of 32KB, so we weren&#039;t concerned about attempting a boot in 16KB.
<br />
</p></blockquote>
<p class="paragraph">
DOS 1.0 は最小で32KBを必要としていた為、16KBのメモリモデルについては考慮しなかったとのこと。
<br />
</p>

<p class="paragraph">
続いていよいよ、「なぜ32KB-1024Bなのか？」に対する回答：
<br />
</p>
<blockquote><p class="paragraph">
We wanted to leave as much room as possible for the OS 
<br />
to load itself within the 32KB.  The 808x Intel architecture 
<br />
used up the first portion of the memory range for software 
<br />
interrupts, and the BIOS data area was after it.  So we put 
<br />
the bootstrap load at 0x7C00 (32KB-1KB) to leave all the room 
<br />
in between for the OS to load.  The boot sector was 512 bytes, 
<br />
and when it executes it&#039;ll need some room for data and a stack, 
<br />
so that&#039;s the other 512 bytes.  So the memory map looks like 
<br />
this after INT 19H executes:
<br />
</p></blockquote>

<ol><li> OSの必要とする最小メモリ、32KBをなるべく空けておきたかった。</li>
<li> アドレス0から始まる 0H - 3FFH までは割り込みベクタとして予約されているので使えない。</li>
<li> なので、32KBの末尾にロードするようにした。</li>
<li> MBR中のbootstrap自身が使うデータやスタック用に、もう512バイト確保した。</li>
<li> よって、32KB - 512B(MBR) - 512B(データとスタック) で、7C00H とした。</li></ol>

<p class="paragraph">
同氏によれば、INT 19h実行後のメモリレイアウトは次のようになる：
<br />
</p>
<pre class="plugin_pre">
+--------------------- 0x0
| Interrupts vectors
+--------------------- 0x400
| BIOS data area
+--------------------- 0x5??
| OS load area
+--------------------- 0x7C00
| Boot sector
+--------------------- 0x7E00
| Boot data/stack
+--------------------- 0x7FFF
| (not used)
+--------------------- (...)
</pre>

<p class="paragraph">
以上が、四半世紀を越えて x86 IBM PC/AT互換機上のOSのbootstrapを支配してきた &quot;0x7C00&quot;, &quot;7C00H&quot; の出自である。
<br />
</p>

<h3 id="id2f6285">参考資料</h3>

<p class="paragraph">
86-DOS関連PDF資料：
<br />
</p>
<ul><li> &quot;8086 Monitor Instruction Manual&quot;(MON 86 - V1.4)</li>
<li> &quot;86-DOS(TM) User&#039;s Manual Version 0.3&quot;</li>
<li> &quot;86-DOS(TM) Programmer&#039;s Manual Version 0.3&quot;</li>
<li> &quot;86-DOS(TM) Instruction Manual Version ??&quot;</li></ul>

<p class="paragraph">
IBM PC 5150 関連PDF資料：
<br />
</p>
<ul><li> &quot;IBM Personal Computer Hardware Reference Library&quot;, &quot;Technical Reference&quot; (IBM Personal Computer Technical Reference manual)</li>
<li> &quot;IBM Personal Computer XT Hardware Reference Library&quot;, &quot;Technical Reference&quot; (IBM Personal Computer XT Technical Reference manual)</li></ul>

<p class="paragraph">
Intel CPU データシートPDF：
<br />
</p>
<ul><li> &quot;8086 16-BIT HMOS MICROPROCESSOR&quot;</li>
<li> &quot;M80C86/M80C86-2 16-BIT CHMOS MICROPROCESSOR&quot;</li>
<li> &quot;8088 8-BIT HMOS MICROPROCESSOR&quot;</li></ul>

<p class="paragraph">
書籍：
<br />
</p>
<a href="https://www.amazon.co.jp/dp/4756102131" target="_blank">はじめて読む486 | 蒲地 輝尚 |本 | 通販 | Amazon</a><br>
<a href="https://www.amazon.co.jp/dp/4798022543" target="_blank">作りながら学ぶOSカーネル保護モードプログラミングの基本と実践 | 金 凡峻 |本 | 通販 | Amazon</a><br>
<a href="https://www.amazon.co.jp/dp/4886487270" target="_blank">Windows OS内部のアーキテクチャのすべて | 前川 武弘 |本 | 通販 | Amazon</a><br>

<p class="paragraph">
以下、参考URL。
<br />
</p>

<h4 id="iddbc046">&quot;Personal Computer&quot;の歴史</h4>

<ul><li> Xerox Alto - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Alto_%28computer%29" target="_blank">http://en.wikipedia.org/wiki/Alto_%28computer%29</a><ul><li> 初期の &quot;Personal Computer&quot;, 1973年</li></ul></li></ul></li>
<li> Altair 8800 - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Altair_8800" target="_blank">http://en.wikipedia.org/wiki/Altair_8800</a><ul><li> Intel 8080 搭載のマイクロコンピュータ, 1975年</li></ul></li></ul></li></ul>

<h5 id="id2ebeaa">Apple関連</h5>

<ul><li> Apple (disambiguation) - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Apple_%28disambiguation%29" target="_blank">http://en.wikipedia.org/wiki/Apple_%28disambiguation%29</a></li></ul></li>
<li> Apple I - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Apple_I" target="_blank">http://en.wikipedia.org/wiki/Apple_I</a></li></ul></li>
<li> Apple II series - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Apple_II_series" target="_blank">http://en.wikipedia.org/wiki/Apple_II_series</a></li></ul></li>
<li> Apple III - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Apple_III" target="_blank">http://en.wikipedia.org/wiki/Apple_III</a></li></ul></li>
<li> List of products discontinued by Apple Inc. - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/List_of_products_discontinued_by_Apple_Inc." target="_blank">http://en.wikipedia.org/wiki/List_of_products_discontinued_by_Apple_Inc.</a></li></ul></li>
<li> TK-80 - Wikipedia<ul><li> <a class="externallink" href="http://ja.wikipedia.org/wiki/TK-80" target="_blank">http://ja.wikipedia.org/wiki/TK-80</a></li></ul></li></ul>

<h5 id="idcf607d">NEC勢</h5>

<ul><li> PC-8000シリーズ - Wikipedia<ul><li> <a class="externallink" href="http://ja.wikipedia.org/wiki/PC-8000%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA" target="_blank">http://ja.wikipedia.org/wiki/PC-8000%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA</a></li></ul></li>
<li> PC-8800シリーズ - Wikipedia<ul><li> <a class="externallink" href="http://ja.wikipedia.org/wiki/PC-8800%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA" target="_blank">http://ja.wikipedia.org/wiki/PC-8800%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA</a></li></ul></li>
<li> PC-6000シリーズ - Wikipedia<ul><li> <a class="externallink" href="http://ja.wikipedia.org/wiki/PC-6000%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA" target="_blank">http://ja.wikipedia.org/wiki/PC-6000%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA</a></li></ul></li>
<li> PC-9800シリーズ - Wikipedia<ul><li> <a class="externallink" href="http://ja.wikipedia.org/wiki/PC-9801" target="_blank">http://ja.wikipedia.org/wiki/PC-9801</a></li></ul></li></ul>

<h5 id="idd110b2">CP/M関連</h5>

<ul><li> CP/M - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/CP/M" target="_blank">http://en.wikipedia.org/wiki/CP/M</a></li></ul></li>
<li> Gary Kildall - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Gary_Kildall" target="_blank">http://en.wikipedia.org/wiki/Gary_Kildall</a></li></ul></li>
<li> The Unofficial CP/M Web Site<ul><li> <a class="externallink" href="http://www.cpm.z80.de/" target="_blank">http://www.cpm.z80.de/</a></li></ul></li>
<li> CP/M Internals : Oscar Vermeulen Personal Web Site<ul><li> <a class="externallink" href="http://www.dcast.vbox.co.uk/cpm.html" target="_blank">http://www.dcast.vbox.co.uk/cpm.html</a><ul><li> メモリレイアウトやブートコードなど、マニアック。</li></ul></li></ul></li>
<li> Digital Research - CP/M<ul><li> <a class="externallink" href="http://www.digitalresearch.biz/CPM.HTM" target="_blank">http://www.digitalresearch.biz/CPM.HTM</a><ul><li> Digital Research社本家のCP/Mページ</li></ul></li></ul></li>
<li> CP/M Main Page<ul><li> <a class="externallink" href="http://www.seasip.demon.co.uk/Cpm/" target="_blank">http://www.seasip.demon.co.uk/Cpm/</a></li></ul></li>
<li> CP/M-86 - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/CP/M-86" target="_blank">http://en.wikipedia.org/wiki/CP/M-86</a><ul><li> 8086対応のCP/M。これが1年でも早くリリースされていたら、PCは別の道を歩んでいたかも知れない。</li></ul></li></ul></li></ul>

<h5 id="id46fc2a">86-DOS, Tim Paterson 氏, 初期のMS-DOS(PC-DOS)関連</h5>

<ul><li> QDOS - Wikipedia<ul><li> <a class="externallink" href="http://ja.wikipedia.org/wiki/QDOS" target="_blank">http://ja.wikipedia.org/wiki/QDOS</a></li></ul></li>
<li> 86-DOS - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/86-DOS" target="_blank">http://en.wikipedia.org/wiki/86-DOS</a></li></ul></li>
<li> 86-DOS Resource Website<ul><li> <a class="externallink" href="http://www.86dos.org/index.htm" target="_blank">http://www.86dos.org/index.htm</a><ul><li> Altair8800のシミュレータおよびその86-DOSイメージのリンクがある。</li>
<li> 86-DOSのファイルセットがzipで入手可能。</li></ul></li></ul></li></ul>

<ul><li> Tim Paterson - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Tim_Paterson" target="_blank">http://en.wikipedia.org/wiki/Tim_Paterson</a></li></ul></li></ul>

<p class="paragraph">
Tim Paterson 氏のサイト：
<br />
</p>

<ul><li> Early DOS Manuals<ul><li> <a class="externallink" href="http://www.patersontech.com/dos/manuals.aspx" target="_blank">http://www.patersontech.com/dos/manuals.aspx</a><ul><li> 86-DOSの各種マニュアルがDL可能。</li></ul></li></ul></li>
<li> An Inside Look at MS-DOS<ul><li> <a class="externallink" href="http://www.patersontech.com/dos/Byte/InsideDos.htm" target="_blank">http://www.patersontech.com/dos/Byte/InsideDos.htm</a><ul><li> 初期のDOSの設計思想、初期FATファイルシステムの解説</li></ul></li></ul></li>
<li> A Short History of MS-DOS<ul><li> <a class="externallink" href="http://www.patersontech.com/dos/Byte/History.html" target="_blank">http://www.patersontech.com/dos/Byte/History.html</a><ul><li> CP/M → SCP QDOS → SCP 86-DOS → IBM PC 5150 PC-DOS への転換点の当事者による記録</li></ul></li></ul></li></ul>

<ul><li> DosMan Drivel<ul><li> <a class="externallink" href="http://dosmandrivel.blogspot.com/" target="_blank">http://dosmandrivel.blogspot.com/</a><ul><li> Tim Paterson 氏による初期DOSの詳しい歴史や解説Blog</li></ul></li></ul></li></ul>

<ul><li> MS-DOS - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/MS-DOS" target="_blank">http://en.wikipedia.org/wiki/MS-DOS</a></li></ul></li>
<li> The DOS Memory Map<ul><li> <a class="externallink" href="http://www.nolm.org/TAE/c016p08.htm" target="_blank">http://www.nolm.org/TAE/c016p08.htm</a><ul><li> DOSのメモリレイアウト</li></ul></li></ul></li></ul>

<h5 id="id892d67">初期のMS-DOSの日本語資料</h5>

<ul><li> MS-DOS - Wikipedia<ul><li> <a class="externallink" href="http://ja.wikipedia.org/wiki/MS-DOS" target="_blank">http://ja.wikipedia.org/wiki/MS-DOS</a></li></ul></li>
<li> DOSの歴史セミナ<ul><li> <a class="externallink" href="http://hp.vector.co.jp/authors/VA000199/history.html" target="_blank">http://hp.vector.co.jp/authors/VA000199/history.html</a></li></ul></li>
<li> Software Design 1998.6 MS-DOS HISTORY -colors of Peole<ul><li> <a class="externallink" href="http://www.os.rim.or.jp/~ppp/msdos/SD/" target="_blank">http://www.os.rim.or.jp/~ppp/msdos/SD/</a></li></ul></li></ul>

<h5 id="idf8e185">IBM PC 5150 前後の歴史について</h5>

<ul><li> PC History: The PC at 20<ul><li> <a class="externallink" href="http://pcworld.about.com/magazine/1908p133id52503.htm" target="_blank">http://pcworld.about.com/magazine/1908p133id52503.htm</a></li></ul></li></ul>

<ul><li> PCの歴史関連URL(日本語資料)<ul><li> <a class="externallink" href="http://www.sanosemi.com/history_of_PC_refURL.htm" target="_blank">http://www.sanosemi.com/history_of_PC_refURL.htm</a></li></ul></li></ul>

<ul><li> 図書カード：パソコン創世記<ul><li> <a class="externallink" href="http://www.aozora.gr.jp/cards/000055/card365.html" target="_blank">http://www.aozora.gr.jp/cards/000055/card365.html</a></li></ul></li></ul>

<ul><li> IBM 5100 computer, 1975年<ul><li> <a class="externallink" href="http://oldcomputers.net/ibm5100.html" target="_blank">http://oldcomputers.net/ibm5100.html</a></li></ul></li></ul>

<ul><li> Welcome to the Retrocomputing Archive<ul><li> <a class="externallink" href="http://www.retroarchive.org/dos/docs/" target="_blank">http://www.retroarchive.org/dos/docs/</a><ul><li> 各種PDF資料</li></ul></li></ul></li></ul>

<ul><li> PC Technical Reference Manual -- by Jalkanen Art &amp; Science<ul><li> <a class="externallink" href="http://www.tec.sci.fi/tecref/" target="_blank">http://www.tec.sci.fi/tecref/</a><ul><li> Technical Reference manualのHW/メモリレイアウトを見やすくまとめ直したCheatSheet</li></ul></li></ul></li></ul>

<ul><li> IBM提供のIBM PCの歴史関連資料<ul><li> IBM Archives: Exhibits<ul><li> <a class="externallink" href="http://www-03.ibm.com/ibm/history/exhibits/index.html" target="_blank">http://www-03.ibm.com/ibm/history/exhibits/index.html</a></li></ul></li>
<li> IBM Archives: The IBM Personal Computer<ul><li> <a class="externallink" href="http://www-03.ibm.com/ibm/history/exhibits/pc25/pc25_intro.html" target="_blank">http://www-03.ibm.com/ibm/history/exhibits/pc25/pc25_intro.html</a></li></ul></li>
<li> IBM Archives: IBM Personal Computer<ul><li> <a class="externallink" href="http://www-03.ibm.com/ibm/history/exhibits/pc/pc_1.html" target="_blank">http://www-03.ibm.com/ibm/history/exhibits/pc/pc_1.html</a></li></ul></li>
<li> IBM Archives: The birth of the IBM PC<ul><li> <a class="externallink" href="http://www-03.ibm.com/ibm/history/exhibits/pc25/pc25_birth.html" target="_blank">http://www-03.ibm.com/ibm/history/exhibits/pc25/pc25_birth.html</a></li></ul></li></ul></li></ul>

<ul><li> Vintage IBM 5150 Documentation Page<ul><li> <a class="externallink" href="http://www.ibm5150.net/docs.html" target="_blank">http://www.ibm5150.net/docs.html</a><ul><li> 当時のBASICやTechnical Reference manualがDL可能。</li></ul></li></ul></li></ul>

<p class="paragraph">
その他IBM PC関連のWikipage：
<br />
</p>
<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/IBM_Personal_Computer" target="_blank">http://en.wikipedia.org/wiki/IBM_Personal_Computer</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/IBM_Personal_Computer_XT" target="_blank">http://en.wikipedia.org/wiki/IBM_Personal_Computer_XT</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/IBM_PCjr" target="_blank">http://en.wikipedia.org/wiki/IBM_PCjr</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/IBM_Personal_Computer/AT" target="_blank">http://en.wikipedia.org/wiki/IBM_Personal_Computer/AT</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/IBM_Personal_System/2" target="_blank">http://en.wikipedia.org/wiki/IBM_Personal_System/2</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/IBM_PC_compatible" target="_blank">http://en.wikipedia.org/wiki/IBM_PC_compatible</a></li></ul>

<h5 id="id0ade81">David Bradley氏関連</h5>

<ul><li> David Bradley (engineer) - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/David_Bradley_%28engineer%29" target="_blank">http://en.wikipedia.org/wiki/David_Bradley_%28engineer%29</a></li></ul></li>
<li> Inventor of the Week: Archive<ul><li> <a class="externallink" href="http://web.mit.edu/invent/iow/bradley.html" target="_blank">http://web.mit.edu/invent/iow/bradley.html</a></li></ul></li>
<li> USATODAY.com - Man who invented Ctrl-Alt-Del key combo retiring<ul><li> <a class="externallink" href="http://www.usatoday.com/tech/news/2004-01-29-david-bradley-retires_x.htm" target="_blank">http://www.usatoday.com/tech/news/2004-01-29-david-bradley-retires_x.htm</a></li></ul></li>
<li> Dr. David Bradley - Adjunct Faculty - Department of Electrical and Computer Engineering<ul><li> <a class="externallink" href="http://www.ece.ncsu.edu/people/dbradley" target="_blank">http://www.ece.ncsu.edu/people/dbradley</a></li></ul></li>
<li> Dr. David J. Bradley Retires from IBM - Newsroom - Department of Electrical and Computer Engineering<ul><li> <a class="externallink" href="http://www.ece.ncsu.edu/news/387" target="_blank">http://www.ece.ncsu.edu/news/387</a></li></ul></li></ul>

<h4 id="id5cef82">BIOS, MBR, アセンブラ関連</h4>

<ul><li> Programming MS-DOS with Power<ul><li> <a class="externallink" href="http://www.fysnet.net/index.htm" target="_blank">http://www.fysnet.net/index.htm</a><ul><li> MS-DOSのプログラミングに関する、ひたすら「濃い」コンテンツ。</li>
<li> ROM BIOSのメモリレイアウトなど、機械語 - BIOS - DOSの境界線をひた走る。</li></ul></li></ul></li></ul>

<ul><li> ATA-ATAPI.COM -- HIW: How It Works Documents<ul><li> <a class="externallink" href="http://www.ata-atapi.com/hiw.html" target="_blank">http://www.ata-atapi.com/hiw.html</a><ul><li> MBRやCHSの変換など、ATA-ATAPI技術の内容が濃い。</li></ul></li></ul></li></ul>

<ul><li> MBR and Windows Boot Sectors<ul><li> <a class="externallink" href="http://home.att.net/~rayknights/pc_boot/pc_boot.htm" target="_blank">http://home.att.net/~rayknights/pc_boot/pc_boot.htm</a><ul><li> Win95/98/2000のMBRをdisassmbleして解説している。とにかく、濃い。</li></ul></li></ul></li></ul>

<ul><li> Dump a BIOS using debug.com [MESS]<ul><li> <a class="externallink" href="http://mess.redump.net/dumping:dump_bios_using_debug/" target="_blank">http://mess.redump.net/dumping:dump_bios_using_debug/</a><ul><li> &quot;DEBUG&quot;コマンドでBIOSのダンプイメージを取得する手法</li></ul></li></ul></li></ul>

<ul><li> BIM PC 5150 のROM BIOSダンプイメージファイル<ul><li> <a class="externallink" href="http://www.vintagecomputer.net/ibm/5150/BIOS_dumps/" target="_blank">http://www.vintagecomputer.net/ibm/5150/BIOS_dumps/</a></li></ul></li></ul>

<ul><li> IBM Personal Computer Assembly Language Tutorial | Simon Steed&#039;s Blog About Stuff!<ul><li> <a class="externallink" href="http://blog.xploiter.com/programming-related-content/ibm-personal-computer-assembly-language-tutorial/" target="_blank">http://blog.xploiter.com/programming-related-content/ibm-personal-computer-assembly-language-tutorial/</a><ul><li> IBM PC 5150当時の MACRO アセンブラのチュートリアル。</li></ul></li></ul></li></ul>

<ul><li> The Segment:Offset Addressing Scheme<ul><li> <a class="externallink" href="http://thestarman.pcministry.com/asm/debug/Segments.html" target="_blank">http://thestarman.pcministry.com/asm/debug/Segments.html</a><ul><li> SEGMENT:OFFSET形式のアドレス指定の解説</li></ul></li></ul></li></ul>

<ul><li> PCのbootstrap(MBR)や呼び出し規約の、GCCを使った講義ノート<ul><li> <a class="externallink" href="http://pdos.csail.mit.edu/6.828/2003/labs/lab1.html" target="_blank">http://pdos.csail.mit.edu/6.828/2003/labs/lab1.html</a></li>
<li> <a class="externallink" href="http://zoo.cs.yale.edu/classes/cs422/2010/lec/l3-hw" target="_blank">http://zoo.cs.yale.edu/classes/cs422/2010/lec/l3-hw</a></li>
<li> <a class="externallink" href="http://flint.cs.yale.edu/cs422/precepts/bochs.html" target="_blank">http://flint.cs.yale.edu/cs422/precepts/bochs.html</a></li></ul></li></ul>

<ul><li> I/O Ports and Controllers on IBM Compatibles and PS/2<ul><li> <a class="externallink" href="http://www.os2site.com/sw/info/memory/ports.txt" target="_blank">http://www.os2site.com/sw/info/memory/ports.txt</a><ul><li> I/Oポートアドレス一覧</li></ul></li></ul></li></ul>

<ul><li> CMOS Memory Map<ul><li> <a class="externallink" href="http://bochs.sourceforge.net/techspec/CMOS-reference.txt" target="_blank">http://bochs.sourceforge.net/techspec/CMOS-reference.txt</a><ul><li> CMOSの内部メモリレイアウト</li></ul></li></ul></li></ul>

<ul><li> その他BIOS, bootstrap関連Wikipedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Initial_program_load" target="_blank">http://en.wikipedia.org/wiki/Initial_program_load</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Booting" target="_blank">http://en.wikipedia.org/wiki/Booting</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Nonvolatile_BIOS_memory" target="_blank">http://en.wikipedia.org/wiki/Nonvolatile_BIOS_memory</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Input/Output_Base_Address" target="_blank">http://en.wikipedia.org/wiki/Input/Output_Base_Address</a></li></ul></li></ul>

<h4 id="id14373b">Intel x86 の初期CPUのWikipedia</h4>

<ul><li> 4bit<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Intel_4004" target="_blank">http://en.wikipedia.org/wiki/Intel_4004</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Intel_4040" target="_blank">http://en.wikipedia.org/wiki/Intel_4040</a></li></ul></li></ul>

<ul><li> 8bit<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Intel_8008" target="_blank">http://en.wikipedia.org/wiki/Intel_8008</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Intel_8080" target="_blank">http://en.wikipedia.org/wiki/Intel_8080</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Intel_8085" target="_blank">http://en.wikipedia.org/wiki/Intel_8085</a></li></ul></li></ul>

<ul><li> 8/16bit<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Intel_8086" target="_blank">http://en.wikipedia.org/wiki/Intel_8086</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Intel_8088" target="_blank">http://en.wikipedia.org/wiki/Intel_8088</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Intel_80186" target="_blank">http://en.wikipedia.org/wiki/Intel_80186</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Intel_80188" target="_blank">http://en.wikipedia.org/wiki/Intel_80188</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Intel_80286" target="_blank">http://en.wikipedia.org/wiki/Intel_80286</a></li></ul></li></ul>

<ul><li> 32bit<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Intel_80386" target="_blank">http://en.wikipedia.org/wiki/Intel_80386</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Intel_80486" target="_blank">http://en.wikipedia.org/wiki/Intel_80486</a></li></ul></li></ul>

<h3 id="idc71687">Special Thanks</h3>

<p class="paragraph">
下手くそな英語で突然質問してきたmsakamoto-sfに対して、親切に回答してくれた
<br />
</p>
<pre>Tim Peterson
David Bradley
</pre>
<p class="paragraph">
両氏に対してSpecial Thanksです。
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-610.html" title="Assembler/なぜx86ではMBRが&quot;0x7C00&quot;にロードされるのか？">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-410.html" title="Assembler">Up</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-410.html" title="Assembler">Assembler</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/614<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2007 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>