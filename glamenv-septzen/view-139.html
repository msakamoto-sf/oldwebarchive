<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Perl/codepiece/my_and_locals1 - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">Perl/codepiece/my_and_locals1</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2007-03-15 17:34:43 &nbsp; / &nbsp; last updated at: 2008-12-29 17:44:54<br>
カテゴリ: <a href="category-21.html">Perl</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-135.html" title="Perl/codepiece/manupilate_INC_by_FindBin">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-119.html" title="Perl/codepiece/pseudo_block">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-109.html" title="Perl">Perl</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
&quot;Effective Perl&quot;(Joseph N.Hall/Randal L.Schwartz, 吉川邦夫訳, アスキー出版局)にmyとlocalの説明が載っていたので、改めで実際に動かし、確認する。
<br />
</p>




<ul><li><a href="#id7b980c">先に結論を。</a></li>
<li><a href="#idaceaf2">グローバル変数（パッケージのシンボルテーブルとソフトリファレンス）</a></li>
<li><a href="#id7df84b">myによる字句解析的(lexical)なスコープ決定</a><ul><li><a href="#ideef3e3">コードピース(1)</a></li>
<li><a href="#id4436c2">コードピース(2)</a></li></ul></li>
<li><a href="#idccf0c9">大量のtry&amp;errorの果てに。</a><ul><li><a href="#id6dee30">コードピース (1) : グローバル変数は何度代入してもメモリ上同じ位置か？</a></li>
<li><a href="#id1327e7">コードピース (2) : my変数は何度代入してもメモリ上同じ位置か？</a></li>
<li><a href="#idc7e0a4">コードピース (3) : my 宣言したものはシンボルテーブル(%&lt;package&gt;::)からアクセスできないか？</a></li>
<li><a href="#id97c9c5">コードピース (4) : package宣言でグローバル変数はどうなるか？</a></li>
<li><a href="#id2fa29c">コードピース (5) : 同じファイル中で、パッケージを切り替えてmyをするとどうなるか。</a></li>
<li><a href="#id863f2f">コードピース (6) : 多段のbrace(&quot;{</a>&quot;)の中でも同名のmy宣言を行うとどうなる？}</li>
<li><a href="#id48db6a">コードピース (7) : 多段のbrace(&quot;{</a>&quot;)の中でmy宣言を行わないとどうなる？}</li>
<li><a href="#id2e574e">コードピース (8) : lexical変数のスコープの一つに、ファイルの終わりまでとあるが本当か？</a></li>
<li><a href="#id614424">コードピース (9) : lexical変数をパッケージ名をつけてアクセスしても、ちゃんと無意味になるか？</a></li>
<li><a href="#id644a8a">コードピース (10) : lexical変数は本当にファイルスコープか？その２</a></li>
<li><a href="#id28de28">コードピース (11) : グローバル変数とlexical変数名がかぶったら？</a></li>
<li><a href="#ida7e989">コードピース (12) : ourについて - 1</a></li>
<li><a href="#id946212">コードピース (13) : ourについて - 2</a></li>
<li><a href="#id22f322">コードピース (14) : ourについて(同じファイル中で、パッケージを異にして二回呼ぶ) - 3</a></li>
<li><a href="#id1a47a2">コードピース (15) : ourについて - lexcal変数と同じく、ファイルが異なれば参照不可を確認</a></li>
<li><a href="#id1f624b">コードピース (16) : use vars</a></li>
<li><a href="#id237a14">コードピース (17) : とりあえずのまとめ</a></li></ul></li>
<li><a href="#idab811b">参考URL [#k0d79c00]</a></li></ul>
<hr />
<h3 id="id7b980c">先に結論を。</h3>

<p class="paragraph">
このコードピースは長い為、先に結論を述べる。
<br />
</p>

<p class="paragraph">
Perlの変数は、スコープの観点から次の二種類がある。
<br />
</p>
<ol><li> グローバル変数(別名、パッケージ変数) → %(パッケージ名):: でアクセス可能なシンボルテーブルに載る変数</li>
<li> lexical(字句解析的)変数(別名、scoped変数) → ファイル全体, &quot;{}&quot;, eval()のスコープを持つ変数</li></ol>

<p class="paragraph">
この二つのスコープ間は相互干渉しない。<strong>どんなにファイル内でパッケージが切り替わろうとも、myとして宣言された変数はそのファイル内でしかスコープを持たず、そのファイル内であればいかなる場所でもその変数を参照できるし、参照を強制される。</strong>
<br />
</p>

<p class="paragraph">
この、ファイル全体にかかるスコープが厄介である。通常は1ファイル1パッケージである為疑問に思うことは少ないが、実験などで一つのファイル内に複数のpackage宣言を混ぜて、いろいろ実験する場合、当惑する遠因となる。<strong>packageをスコープの様に考えているのであれば、それは間違いである。</strong>
<br />
</p>

<p class="paragraph">
package宣言は現在のパッケージを変更する為のステートメント<span class="hidden">(</span><a class="footnote" href="#footnote_139_1" id="footnote_139_1_r"  title="本当にこれで正鵠か否かは調査が必要だが、ここでの文脈に限って言えばこれで正しいと思う。">*1</a><span class="hidden">)</span>でしかない。確かにpackageはパッケージのシンボルテーブルを利用する為に必要であるが、<strong>myは通常のシンボルテーブルとは別の機構で管理されている。package宣言による影響とは何の関係も無い。</strong>
<br />
</p>

<p class="paragraph">
<strong>myはmyだけのスコーピング機構に従う。それは、ファイル末尾まで &gt; &quot;{}&quot; &gt; eval() の順で定められている。それが全てである。</strong>
<br />
</p>

<p class="paragraph">
基本的に全てperldocに書かれている通りでしか動かない。それがPerlの仕様だからだ。しかし、プログラマーがバックグラウンドにC/Java/PHP<span class="hidden">(</span><a class="footnote" href="#footnote_139_2" id="footnote_139_2_r"  title="自分のことである。">*2</a><span class="hidden">)</span>を持っている場合、<strong>頭がPerlのスコーピング機構について行けず、知らない間にC/Java/PHPのスコーピングで変数を利用している</strong>という状況になる。
<br />
</p>
<ol><li> 変数が思った通りの値にならない。</li>
<li> perldocや書籍を読む限りにおいては正しい動作をしているようだ。</li>
<li><strong>なぜそれが正しい動作かがわからない。</strong>（頭の中ではC/Java/PHPの動作を無意識に期待しているため）</li></ol>

<p class="paragraph">
つまり、正しい動作を説明している記述、それ自体が理解できなくなってしまう。これでは「正しい」変数の宣言と利用は覚束ない。
<br />
</p>

<p class="paragraph">
PerlにはC/Java/PHPでの「ローカル変数」と正対するものは無い、と自分は考えている。シンボルテーブルで参照されるパッケージ変数か、独自のスコーピング機構で管理されるmy/our変数か の二択である。そう割り切った方が、C/Java/PHPの呪縛から抜け出せる。<strong>Perlは昔からPerlでしかなく</strong>、だからこそ微妙で奇妙に珍妙ながらも絶妙に面白く、好きになってしまった。
<br />
</p>

<p class="paragraph">
今回、my/our/シンボルテーブル、これを理解する為に丸一日使ってこのコードピース群を書いては動かし、確認していった。
<br />
</p>

<p class="paragraph">
結局local迄は到達し得なかった。localと型グロブ、そしてtieも、これがまた、C/Java/PHPを背景に持つ自分にとってはまだまだ理解しきれていない概念である。また折りを見てそれらの壁によじ登ってみたい。
<br />
</p>

<h3 id="idaceaf2">グローバル変数（パッケージのシンボルテーブルとソフトリファレンス）</h3>

<ul><li> いわゆるグローバル変数を作成する。この場合はデフォルトのmainパッケージのシンボルテーブルに、コンパイル時に登録される。<ul><li> シンボルテーブルへは&quot;%(パッケージ名)::&quot;でアクセスできる。</li></ul></li>
<li> ソフトリファレンスの場合は、そのソフトリファレンスの使用箇所を実行時にシンボルテーブルに追加される。</li>
<li> コードピース</li></ul>
<pre>#!/usr/bin/perl

print join &quot; &quot;, keys(%::);
print &quot;\n-------------\n&quot;;
$compile_time;

${&quot;run_time&quot;};
$$runt_time2;
print join &quot; &quot;, keys(%::);
print &quot;\n&quot;;
</pre>

<ul><li> 出力</li></ul>
<pre>/ stderr utf8:: &quot; CORE:: DynaLoader:: stdout compile_time attributes::  
                                             ^^^^^^^^^^^^
stdin ARGV INC ENV Regexp:: UNIVERSAL:: $ _&lt;perlio.c main:: - _&lt;perlmain.c 
PerlIO:: _&lt;universal.c 0 @ _&lt;xsutils.c STDOUT IO::  _ + STDERR Internals:: 
STDIN DB:: &lt;none&gt;::
-------------
/ stderr utf8:: &quot; run_time CORE:: DynaLoader:: stdout compile_time runt_time2 
                  ^^^^^^^^                                         ^^^^^^^^^^
attributes::  stdin ARGV INC ENV Regexp:: UNIVERSAL:: $ _&lt;perlio.c main:: - 
_&lt;perlmain.c PerlIO:: _&lt;universal.c 0 @ _&lt;xsutils.c STDOUT IO::  _ + STDERR 
Internals:: STDIN DB:: &lt;none&gt;::
</pre>

<ul><li> 一度目のシンボルテーブル出力時：ソース上、$compile_timeの評価前にシンボルテーブルにアクセスしているが、コンパイル時に組み込まれる為、既にシンボルが存在する。</li>
<li> 二度目のシンボルテーブル出力時：ソフトリファレンスの評価後であるため、run_time, run_time2のシンボルが新たに追加されている。</li>
<li> 以上より、ソフトリファレンスではないグローバル変数についてはコンパイル時にシンボルテーブルに登録されることが確認できた。</li></ul>

<h3 id="id7df84b">myによる字句解析的(lexical)なスコープ決定</h3>

<p class="paragraph">
myを用いると、文法に従って(=字句解析的:lexical)スコープが決定される。<strong>一組のブレース&quot;{}&quot;、ファイル、eval文字列</strong>がスコープとなる。myの宣言箇所から、当該スコープの末尾までがmyの有効範囲となる。
<br />
</p>

<h4 id="ideef3e3">コードピース(1)</h4>

<p class="paragraph">
myを使用したシンボルは、コンパイル時にはパッケージのシンボルテーブルに配置されるものの、実行時には当該パッケージのシンボルとしてはアクセスできなくなる。
<br />
</p>

<ul><li> コードピース</li></ul>
<pre>#!/usr/bin/perl

my $compile_time = 123;
$compile_time = 456;

print join &quot; &quot;, keys(%::);
print &quot;\n----------\n&quot;;
print &quot;main::compile_time = [&quot;, $main::compile_time, &quot;]\n&quot;;
print &quot;::compile_time = [&quot;, $::compile_time, &quot;]\n&quot;;
print &quot;compile_time = [&quot;, $compile_time, &quot;]\n&quot;;
</pre>

<ul><li> 出力</li></ul>
<pre>/ stderr utf8:: &quot; CORE:: DynaLoader:: stdout compile_time attributes::  
                                             ^^^^^^^^^^^^
stdin ARGV INC ENV Regexp:: UNIVERSAL::  $ _&lt;perlio.c main:: - 
_&lt;perlmain.c PerlIO:: _&lt;universal.c 0 @ _&lt;xsutils.c STDOUT IO::  _ 
+ STDERR Internals:: STDIN DB:: &lt;none&gt;::
----------
main::compile_time = [] &lt;&lt;&lt;&lt; シンボルテーブルには存在するのにアクセスできない。
::compile_time = [] &lt;&lt;&lt;&lt; (同上)
compile_time = [456]
</pre>

<h4 id="id4436c2">コードピース(2)</h4>

<p class="paragraph">
コードピース(1)でmyの順番を入れ替えてみると、シンボルにアクセスする時のパッケージ名によるスコーピング<span class="hidden">(</span><a class="footnote" href="#footnote_139_3" id="footnote_139_3_r"  title="この呼び名であっているのか？">*3</a><span class="hidden">)</span>が有効になる。
<br />
</p>

<ul><li> コードピース</li></ul>
<pre>#!/usr/bin/perl

$compile_time = 456;
my $compile_time = 123;

print join &quot; &quot;, keys(%main::);
print &quot;\n----------\n&quot;;
print &quot;main::compile_time = [&quot;, $main::compile_time, &quot;]\n&quot;;
print &quot;::compile_time = [&quot;, $::compile_time, &quot;]\n&quot;;
print &quot;compile_time = [&quot;, $compile_time, &quot;]\n&quot;;
</pre>

<ul><li> 出力</li></ul>
<pre>/ stderr utf8:: &quot; CORE:: DynaLoader:: stdout compile_time attributes::  
                                             ^^^^^^^^^^^^
stdin ARGV INC ENV Regexp:: UNIVERSAL::  $ _&lt;perlio.c main:: - 
_&lt;perlmain.c PerlIO:: _&lt;universal.c 0 @ _&lt;xsutils.c STDOUT IO::  _ 
+ STDERR Internals:: STDIN DB:: &lt;none&gt;::
----------
main::compile_time = [456] &lt;&lt;&lt;&lt; mainパッケージのシンボルテーブルにアクセスできている。
::compile_time = [456]
compile_time = [123] &lt;&lt;&lt;&lt; パッケージ名が無い場合、myでスコーピングされたシンボルにアクセスしに行っている？
</pre>

<p class="paragraph">
この辺りになると大分混沌としてくる。シンボルテーブルとの絡みで、my とシンボルの管理が教科書通りにはなってないのではないのか？とも思えてくる。
<br />
</p>

<p class="paragraph">
そこで、数時間の調査と、try&amp;errorの末、より明確にグローバル変数アクセス、my、そしてPerl5.6以降で使えるour、さらにパッケージ名完全指定時の変数アクセスのかなり正確な処理が追えるようになった。
<br />
</p>

<h3 id="idccf0c9">大量のtry&amp;errorの果てに。</h3>

<p class="paragraph">
個人がまとめた言語のリファレンス系記事を読んでいて時々感じるのは、言語特有の壁に相当する部分が、非常に教科書的、理論的に書かれている点である。確かにプログラミング言語は理論的に動くものなので、リファレンスとしてはその通りに書いて良いのだが、しかし、記述漏れは有る。また、サンプルも「こんなときどうなのよ？」といったIFの記述が不足していることが多い。
<br />
</p>

<p class="paragraph">
恐らく、大量のtry&amp;errorの果てに、結局は仕様書通りであるからこそそうした記述になると思われる。しかし、そこに至るまでの試行の中で、教科書には載っていない事象も発生したはずである。もちろんそうした事象の原因を突き詰めていくと、教科書に書かれているとおりに動いていたことになるわけであるが、しかし、理論だけ学んで実践ができるのであれば誰も苦労はしない。
<br />
</p>

<p class="paragraph">
事象を見て、その裏側で動いている理論を追跡できるようになるには、理論と実際をマッピングするための知識・経験・直感が必要であり、そしてそれは経験を積むほか無いであろう。直感も経験の一つにはいるし、知識は定着させるのに経験が必要であるからだ。
<br />
</p>

<p class="paragraph">
以下に続くのは、率直に言っていかなるサンプルにもなり得ないコードピース群である。しかし、言語のシンボルの取り扱いという、中枢レベルのテーマを扱うには仕様を疑ってかかるほどの愚かしいtry&amp;errorが欠かせないことを自分はPHPより学んでいる<span class="hidden">(</span><a class="footnote" href="#footnote_139_4" id="footnote_139_4_r"  title="シンボルの取り扱いの癖の強さは、特にLLに顕著だと思う。">*4</a><span class="hidden">)</span>。
<br />
よって、敢えて自分の辿った膨大な無駄で愚かしく自明なものをわざわざ再確認するようなコードをここに載せ、辿った道のりを残しておく。
<br />
</p>

<h4 id="id6dee30">コードピース (1) : グローバル変数は何度代入してもメモリ上同じ位置か？</h4>

<p class="paragraph">
まず、グローバル変数は何度代入しても同じメモリ上であることを確認したい。
<br />
</p>

<ul><li> コードピース</li></ul>
<pre>#!/usr/bin/perl

$var1 = &quot;abc&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;

$var1 = &quot;def&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
</pre>

<ul><li> 出力</li></ul>
<pre>$ ./hoge.pl
$var1 = abc
\$var1 = SCALAR(0x8164460)
$var1 = def
\$var1 = SCALAR(0x8164460)
</pre>

<p class="paragraph">
特に常識と異なる点はない。
<br />
</p>

<h4 id="id1327e7">コードピース (2) : my変数は何度代入してもメモリ上同じ位置か？</h4>

<p class="paragraph">
my宣言した変数を確認する。
<br />
</p>

<ul><li> コードピース</li></ul>
<pre>#!/usr/bin/perl

my $var1;
$var1 = &quot;abc&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
$var1 = &quot;def&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;

my $var1;
$var1 = &quot;ghi&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
$var1 = &quot;jkl&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
</pre>

<ul><li> 出力</li></ul>
<pre>$ ./test1.pl
$var1 = abc
\$var1 = SCALAR(0x8164450)
$var1 = def
\$var1 = SCALAR(0x8164450)
$var1 = ghi
\$var1 = SCALAR(0x8164504) &lt;&lt;&lt;&lt; ここから2番目のmy宣言以降
$var1 = jkl
\$var1 = SCALAR(0x8164504)
</pre>

<p class="paragraph">
<strong>2番目のmy宣言により、アドレスが変わる=新しい領域がとられている点に注意したい。</strong>
<br />
</p>

<p class="paragraph">
<strong>myは、変数を作ってしまうのだ。</strong>
<br />
</p>

<h4 id="idc7e0a4">コードピース (3) : my 宣言したものはシンボルテーブル(%&lt;package&gt;::)からアクセスできないか？</h4>

<p class="paragraph">
冒頭の方の実験では、my宣言した変数名と、グローバル変数名を同じにしていた為、シンボルテーブルにある変数名が本当にグローバル変数のものか確証が採れなかった。
<br />
</p>

<ul><li> コードピース</li></ul>
<pre>#!/usr/bin/perl

$var1;     # &quot;グローバル&quot;または&quot;パッケージ&quot;変数
my $var2;  # &quot;字句解析的(lexical)&quot;または&quot;スコープ&quot;変数

print join &quot; &quot;, keys(%::);
print &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
print &#039;\$var2 = &#039;, \$var2, &quot;\n&quot;;
</pre>

<ul><li> 出力</li></ul>
<pre>$ ./test1.pl
/ stderr utf8:: &quot; CORE:: DynaLoader:: stdout attributes::  stdin 
ARGV INC ENV Regexp:: UNIVERSAL:: $ _&lt;perlio.c main:: - _&lt;perlmain.c 
PerlIO:: _&lt;universal.c 0 @ _&lt;xsutils.c var1 STDOUT IO::  _ + 
                                       ^^^^
STDERR Internals:: STDIN DB:: &lt;none&gt;::
\$var1 = SCALAR(0x8164468)
\$var2 = SCALAR(0x8164450)
</pre>

<p class="paragraph">
<strong>こちらも教科書通り、my 宣言された変数はシンボルテーブルには載らないことが確認できた。</strong>
<br />
</p>

<h4 id="id97c9c5">コードピース (4) : package宣言でグローバル変数はどうなるか？</h4>

<p class="paragraph">
パッケージ名を指定しないでグローバル変数を扱うとき、package宣言をするだけで本当に切り替わるのか？
<br />
</p>

<ul><li> コードピース</li></ul>
<pre>#!/usr/bin/perl

print &quot;package=[&quot;, __PACKAGE__, &quot;]\n&quot;;
print &#039;%:: = &#039;, join(&quot; &quot;, keys(%::)), &quot;\n&quot;;
print &#039;%hoge:: = &#039;, join(&quot; &quot;, keys(%hoge::)), &quot;\n&quot;;

$var1 = &quot;abc&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
print &#039;$hoge::var1 = &#039;, $hoge::var1, &quot;\n&quot;;
print &#039;\$hoge::var1 = &#039;, \$hoge::var1, &quot;\n&quot;;

package hoge;
print &quot;package=[&quot;, __PACKAGE__, &quot;]\n&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
print &#039;$hoge::var1 = &#039;, $hoge::var1, &quot;\n&quot;;
print &#039;\$hoge::var1 = &#039;, \$hoge::var1, &quot;\n&quot;;

$var1 = &quot;def&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
print &#039;$hoge::var1 = &#039;, $hoge::var1, &quot;\n&quot;;
print &#039;\$hoge::var1 = &#039;, \$hoge::var1, &quot;\n&quot;;

package main;
print &quot;package=[&quot;, __PACKAGE__, &quot;]\n&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
print &#039;$hoge::var1 = &#039;, $hoge::var1, &quot;\n&quot;;
print &#039;\$hoge::var1 = &#039;, \$hoge::var1, &quot;\n&quot;;
</pre>

<ul><li> 出力</li></ul>
<pre>package=[main]
%:: = ... var1 ...
%hoge:: = var1
$var1 = abc
\$var1 = SCALAR(0x8168e10)
$hoge::var1 =                     &lt;&lt;&lt; defined()を確認してみた結果、hogeパッケージのvar1は、undef。
\$hoge::var1 = SCALAR(0x8168e88)

package=[hoge]
$var1 =
\$var1 = SCALAR(0x8168e88)        &lt;&lt;&lt; package宣言直後、デフォルトパッケージがhogeに切り替わった為、
$hoge::var1 =                         アドレスもhoge::var1と同一になる。
\$hoge::var1 = SCALAR(0x8168e88)

$var1 = def
\$var1 = SCALAR(0x8168e88)        &lt;&lt;&lt; 代入後、予想された通り。
$hoge::var1 = def
\$hoge::var1 = SCALAR(0x8168e88)

package=[main]
$var1 = abc                       &lt;&lt;&lt; mainパッケージの戻ってみると、デフォルトパッケージがmain
\$var1 = SCALAR(0x8168e10)            に戻るので、最初に代入した値が取得できている。
$hoge::var1 = def
\$hoge::var1 = SCALAR(0x8168e88)
</pre>

<p class="paragraph">
<strong>これも、教科書通りの動きであることを確認できた。</strong>
<br />
</p>

<h4 id="id2fa29c">コードピース (5) : 同じファイル中で、パッケージを切り替えてmyをするとどうなるか。</h4>

<p class="paragraph">
見出しでは分かりづらいと思われるので、コードピースを参照。
<br />
</p>

<ul><li> コードピース</li></ul>
<pre>#!/usr/bin/perl

print &quot;package=[&quot;, __PACKAGE__, &quot;]\n&quot;;
print &#039;%:: = &#039;, join(&quot; &quot;, keys(%::)), &quot;\n&quot;;
print &#039;%hoge:: = &#039;, join(&quot; &quot;, keys(%hoge::)), &quot;\n&quot;;

my $var1;
$var1 = &quot;abc&quot;;

$var1 = &quot;abc&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;

package hoge;
print &quot;package=[&quot;, __PACKAGE__, &quot;]\n&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;

$var1 = &quot;def&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;

package main;
print &quot;package=[&quot;, __PACKAGE__, &quot;]\n&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
</pre>

<ul><li> 出力</li></ul>
<pre>package=[main]
%:: = ... &lt;&lt;&lt;&lt; 当然、var1はシンボルテーブルには存在しない。
%hoge:: = &lt;&lt;&lt;&lt; 同上
$var1 = abc
\$var1 = SCALAR(0x8168ca4)
package=[hoge]              &lt;&lt;&lt;&lt; hogeパッケージに切り替わっても、myされた変数のアドレス・値は一緒。
$var1 = abc
\$var1 = SCALAR(0x8168ca4)
$var1 = def
\$var1 = SCALAR(0x8168ca4)
package=[main]
$var1 = def
\$var1 = SCALAR(0x8168ca4)
</pre>

<p class="paragraph">
<strong>教科書通りである。</strong>ただし、殆どのサイトではこうした、一つのファイルに複数のパッケージが入り乱れたケースを取り扱っていない。1ファイル1パッケージが通常であるが、それだけで例を挙げていると、あまり深く考えずに雰囲気だけで判断する自分のような人間は、<strong>見た目にだまされて、package後にmyすればパッケージ変数になると思ってしまう。</strong>
<br />
</p>

<p class="paragraph">
人間は理論をそのまま覚えることはできないので、正常形の理論通りではなく、ELSEの理論通りも掲示しないと覚えられないのではないか。
<br />
</p>

<p class="paragraph">
とにもかくにも、どうやら、教科書通り、<strong>my宣言とpackageは何の関係もない</strong>ことが分かった。そう、<strong>myのスコープにはpackageの範囲は含まれていない、関与していない</strong>のだ。
<br />
</p>

<h4 id="id863f2f">コードピース (6) : 多段のbrace(&quot;{}&quot;)の中でも同名のmy宣言を行うとどうなる？</h4>

<ul><li> コードピース</li></ul>
<pre>#!/usr/bin/perl
my $var1;
$var1 = &quot;abc&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
{
    my $var1;
    $var1 = &quot;def&quot;;
    print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
    print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
    {
        my $var1;
        $var1 = &quot;ghi&quot;;
        print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
        print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
    }
    print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
    print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
}
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
</pre>

<ul><li> 出力</li></ul>
<pre>$var1 = abc
\$var1 = SCALAR(0x8164450)
$var1 = def                  &lt;&lt;&lt;&lt; 1段目の{}、アドレスが変わっている以上、別の変数実体。
\$var1 = SCALAR(0x81644b0)
$var1 = ghi                  &lt;&lt;&lt;&lt; 2段目の{}、同上。
\$var1 = SCALAR(0x816451c)
$var1 = def                   &lt;&lt;&lt;&lt; 1段目の{}に戻ると、1段目のmyにアクセスできている。
\$var1 = SCALAR(0x81644b0)
$var1 = abc                  &lt;&lt;&lt;&lt; mainに戻ると、main側のmyにアクセスできている。
\$var1 = SCALAR(0x8164450)
</pre>

<p class="paragraph">
これはあまり見かけない例ではある。この様に、入れ子になっていても、都度myを行うことで、その{}の範囲で変数を取り扱えるようになる。
<br />
</p>

<p class="paragraph">
では、myをしなければどうなるか？もしエラーにならなければどうなるのか？
<br />
</p>

<h4 id="id48db6a">コードピース (7) : 多段のbrace(&quot;{}&quot;)の中でmy宣言を行わないとどうなる？</h4>

<ul><li> コードピース</li></ul>
<pre>#!/usr/bin/perl
use strict;   &lt;&lt;&lt; もしbrace&quot;{}&quot;毎に区切られてしまうのであれば、myが無いbraceでエラーになるはずである。
my $var1;
$var1 = &quot;abc&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
{
    $var1;
    $var1 = &quot;def&quot;;
    print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
    print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
    {
        $var1;
        $var1 = &quot;ghi&quot;;
        print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
        print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
    }
    print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
    print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
}
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
</pre>

<ul><li> 出力</li></ul>
<pre>$var1 = abc
\$var1 = SCALAR(0x8164450)
$var1 = def
\$var1 = SCALAR(0x8164450)   &lt;&lt;&lt;&lt; {}の中に入ってもアドレスが同じ。
$var1 = ghi
\$var1 = SCALAR(0x8164450)
$var1 = ghi                  &lt;&lt;&lt;&lt; {}を抜けても、中で代入した値が保持される。
\$var1 = SCALAR(0x8164450)
$var1 = ghi
\$var1 = SCALAR(0x8164450)
</pre>

<p class="paragraph">
これも、言われてみれば確かに教科書通りではあるが、コードピース (6) の結果も踏まえないと頭の整理が難しい。<strong>自分の場合、CやJavaで育ったせいか、何となく、感覚的に受け入れるのに時間がかかった。</strong>
<br />
</p>

<p class="paragraph">
→<strong>結局、変数の確保されているアドレスに相当する値をデバッグできなければ頭で納得できない様である。</strong>
<br />
</p>

<h4 id="id2e574e">コードピース (8) : lexical変数のスコープの一つに、ファイルの終わりまでとあるが本当か？</h4>

<p class="paragraph">
パッケージでファイルを分割し、同じ名前のグローバル変数とmy宣言を切り、細かく見ていく。
<br />
</p>

<ul><li> コードピース (長くなってきたので、mainパッケージにおいては出力内容をコメントして包括する。)<ul><li> test2.pm</li></ul></li></ul>
<pre>package test2;
$var1 = 123;
my $var2 = 456;
sub test {
print &quot;package=[&quot;, __PACKAGE__, &quot;]\n&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
print &#039;$var2 = &#039;, $var2, &quot;\n&quot;;
print &#039;\$var2 = &#039;, \$var2, &quot;\n&quot;;
}
1;
</pre>
<ul><li><ul><li> test.pl (mainパッケージ)</li></ul></li></ul>
<pre>#!/usr/bin/perl
use test2;    &lt;&lt;&lt;&lt; この段階でtest2.pmが評価される。
print &#039;%:: = &#039;, join(&quot; &quot;, keys(%::)), &quot;\n&quot;;
print &#039;%test2:: = &#039;, join(&quot; &quot;, keys(%test2::)), &quot;\n&quot;;
# 出力：
# %:: = ... var1 ...
# %test2:: = test var1 import

$var1 = &quot;abc&quot;;
my $var2 = &quot;def&quot;;
&amp;main::test;
&amp;test2::test;
# 出力：
# package=[main]             &lt;&lt;&lt;&lt; それぞれ、mainパッケージの/test2パッケージの変数を参照できている。
# $var1 = abc
# \$var1 = SCALAR(0x8168e10)
# $var2 = def
# \$var2 = SCALAR(0x8164504)
# package=[test2]
# $var1 = 123
# \$var1 = SCALAR(0x8168c9c)
# $var2 = 456
# \$var2 = SCALAR(0x8168ca8)

$var1 = &quot;ghi&quot;;              &lt;&lt;&lt;&lt; $var1はデフォルトパッケージのmain側になるはず。
$var2 = &quot;jkl&quot;;              &lt;&lt;&lt;&lt; 本当にmyのスコープがファイル終端までであれば、
&amp;main::test;                     &amp;test2::testでは、別ファイルにあるので影響が無い筈。
&amp;test2::test;
# 出力：
# package=[main]
# $var1 = ghi
# \$var1 = SCALAR(0x8168e10)
# $var2 = jkl
# \$var2 = SCALAR(0x8164504) &lt;&lt;&lt;&lt; mainパッケージが変更されているのは教科書通り。
# package=[test2]
# $var1 = 123
# \$var1 = SCALAR(0x8168c9c)
# $var2 = 456
# \$var2 = SCALAR(0x8168ca8) &lt;&lt;&lt;&lt; test2パッケージの内容は変化無し。これも教科書通り。

package test2;               &lt;&lt;&lt;&lt; 一時的にtest2パッケージに切り替える。
$var1 = 789;                      $var1の方はtest2のデフォルトパッケージを参照するが、
$var2 = 321;                      lexicalであるvar2はあくまでも物理的なファイル終端
&amp;main::test;                      に束縛される為、ここでのvar2は test.pl のvar2であり、
&amp;test2::test;                     test2.pm のvar2では無いはず。
# 出力：
# package=[main]
# $var1 = ghi
# \$var1 = SCALAR(0x8168e10)
# $var2 = 321
# \$var2 = SCALAR(0x8164504)  &lt;&lt;&lt;&lt; mainのvar2が変更されている。教科書通り。
# package=[test2]
# $var1 = 789                 &lt;&lt;&lt;&lt; var1はtest2側が変更されている。教科書通り。
# \$var1 = SCALAR(0x8168c9c)
# $var2 = 456
# \$var2 = SCALAR(0x8168ca8)  &lt;&lt;&lt;&lt; test2側のvar2は変更されていない。教科書通り。

package main;                 &lt;&lt;&lt;&lt; パッケージをmainに切り替えても問題ないことを確認する。
&amp;main::test;
&amp;test2::test;
# 出力：                      &lt;&lt;&lt;&lt; 直前の状態と変化しないことが確認できた。
# package=[main]
# $var1 = ghi
# \$var1 = SCALAR(0x8168e10)
# $var2 = 321
# \$var2 = SCALAR(0x8164504)
# package=[test2]
# $var1 = 789
# \$var1 = SCALAR(0x8168c9c)
# $var2 = 456
# \$var2 = SCALAR(0x8168ca8)

sub test {
print &quot;package=[&quot;, __PACKAGE__, &quot;]\n&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
print &#039;$var2 = &#039;, $var2, &quot;\n&quot;;
print &#039;\$var2 = &#039;, \$var2, &quot;\n&quot;;
}
</pre>

<p class="paragraph">
以上より、<strong>my 宣言された変数はファイルスコープに束縛されるのであり、package; には束縛されない</strong>事を改めて確認できた。
<br />
</p>

<h4 id="id614424">コードピース (9) : lexical変数をパッケージ名をつけてアクセスしても、ちゃんと無意味になるか？</h4>

<p class="paragraph">
lexical変数はパッケージのシンボルテーブルには載らない。従って、他のファイルに存在するからといって、そのファイル中のmy変数に対して、外部パッケージからパッケージ名付きでアクセスしても無意味なはずである。
<br />
</p>

<p class="paragraph">
→コンパイル時に、パッケージのシンボルテーブルにundefでシンボルが載ってしまう筈である。
<br />
</p>

<ul><li> コードピース<ul><li> test2.pm</li></ul></li></ul>
<pre>package test2;
my $var1 = 456;
print &quot;package=[&quot;, __PACKAGE__, &quot;]\n&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
1;
</pre>
<ul><li><ul><li> test.pl</li></ul></li></ul>
<pre>#!/usr/bin/perl
use strict;
use test2;
print &#039;%:: = &#039;, join(&quot; &quot;, keys(%::)), &quot;\n&quot;;
print &#039;%test2:: = &#039;, join(&quot; &quot;, keys(%test2::)), &quot;\n&quot;;

my $var1 = 123;

print &quot;package=[&quot;, __PACKAGE__, &quot;]\n&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
print &#039;$test2::var1 = &#039;, $test2::var1, &quot;\n&quot;;
print &#039;\$test2::var1 = &#039;, \$test2::var1, &quot;\n&quot;;
</pre>

<ul><li> 出力：</li></ul>
<pre>package=[test2]            &lt;&lt;&lt;&lt; test2.pm がuseされたときに実行されたコード
$var1 = 456
\$var1 = SCALAR(0x816e148)
 
%:: = ... test2:: ...      &lt;&lt;&lt;&lt; 当然、myなのでvar1のシンボルはmainシンボルテーブルに無い。
%test2:: = var1 import     &lt;&lt;&lt;&lt; test2.pmについては、test.pl中でアクセスしてしまっているので、
                                undefでシンボルが入ってしまっている。
package=[main]
$var1 = 123
\$var1 = SCALAR(0x8168ffc)
$test2::var1 =
\$test2::var1 = SCALAR(0x816e1e4)  &lt;&lt;&lt;&lt; 当然、冒頭の出力とは異なる。
</pre>

<h4 id="id644a8a">コードピース (10) : lexical変数は本当にファイルスコープか？その２</h4>

<p class="paragraph">
きわめて変則的な例だが、パッケージのファイルとは別のファイルに、そのパッケージのメソッドがあるような場合など。
<br />
何を言っているのか意味不明なので、コードピースをご覧になられたほうが早い。
<br />
</p>

<ul><li> コードピース<ul><li> test2.pm</li></ul></li></ul>
<pre>package test2;
my $var1 = 456;
sub func1 {
print &quot;package=[&quot;, __PACKAGE__, &quot;]\n&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
}
1;
</pre>
<ul><li><ul><li> test.pl</li></ul></li></ul>
<pre>#!/usr/bin/perl
use strict;
use test2;
print &#039;%:: = &#039;, join(&quot; &quot;, keys(%::)), &quot;\n&quot;;
print &#039;%test2:: = &#039;, join(&quot; &quot;, keys(%test2::)), &quot;\n&quot;;

my $var1 = 123;
print &quot;package=[&quot;, __PACKAGE__, &quot;]\n&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;

package test2;                         &lt;&lt;&lt;&lt; test2.pmとは別ファイルで、test2パッケージにサブルーチンを追加。
sub func2 {
print &quot;package=[&quot;, __PACKAGE__, &quot;]\n&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;         &lt;&lt;&lt;&lt; この中でvar1を参照する。本当にmy宣言がpackageと無関係であれば、
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;            test2.pmの $var1 = 456 ではなく、このファイルの $var1 になるはず。
}

package main;
$var1 = 789;
&amp;test2::func1;
&amp;test2::func2;
</pre>

<ul><li> 出力：</li></ul>
<pre>%:: = ... test2:: ...          &lt;&lt;&lt;&lt; 当然lexical変数なので、var1はmainにもtest2にも、シンボルテーブルに存在しない。
%test2:: = func1 func2 import
package=[main]                 &lt;&lt;&lt;&lt; mainでの my $var1 を参照。
$var1 = 123
\$var1 = SCALAR(0x816905c)
package=[test2]                &lt;&lt;&lt;&lt; test2.pmで定義されているサブルーチンを実行すれば、当然、test2.pm
$var1 = 456                         中の my $var1 = 456 が参照される。
\$var1 = SCALAR(0x816e1a8)
package=[test2]                &lt;&lt;&lt;&lt; test.plで定義されているサブルーチンを実行。test2.pmではなく
$var1 = 789                         test.pl側の、変更された $var = 789 が参照されている。 
\$var1 = SCALAR(0x816905c)
</pre>

<p class="paragraph">
以上より、<strong>my 宣言のスコープはpackageとは全く関係ない</strong>ことが確実に判明した。
<br />
</p>

<h4 id="id28de28">コードピース (11) : グローバル変数とlexical変数名がかぶったら？</h4>

<p class="paragraph">
冒頭のコードピースに対するリベンジである。変数名がかぶった場合、myが先か否かでどう変数の実体割り当てが変化するか、再度確認してみる。
<br />
</p>

<ul><li> コードピース</li></ul>
<pre>#!/usr/bin/perl
print &#039;%:: = &#039;, join(&quot; &quot;, keys(%::)), &quot;\n&quot;;

my $var1 = 123;                               &lt;&lt;&lt;&lt; my 宣言が先の場合。グローバル変数はどうなるか？
$var1 = &quot;abc&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
print &#039;$main::var1 = &#039;, $main::var1, &quot;\n&quot;;
print &#039;\$main::var1 = &#039;, \$main::var1, &quot;\n&quot;;
print &#039;$main::var1 is undef&#039;, &quot;\n&quot; if !defined($main::var1);
^ &lt;&lt;&lt;&lt;&lt;&lt; ソースコード中で参照されている以上、コンパイル時にシンボル自体はシンボルテーブルに
         載るはず。但し、中身はundefになるのではないか？

$var2 = 456;   &lt;&lt;&lt;&lt; my 宣言が後の場合。グローバル変数は正常に参照可能？
my $var2 = &quot;def&quot;;
print &#039;$var2 = &#039;, $var2, &quot;\n&quot;;
print &#039;\$var2 = &#039;, \$var2, &quot;\n&quot;;
print &#039;$main::var2 = &#039;, $main::var2, &quot;\n&quot;;
print &#039;\$main::var2 = &#039;, \$main::var2, &quot;\n&quot;;
</pre>

<ul><li> 出力：</li></ul>
<pre>%:: = ... var2 ... var1 ...
$var1 = abc
\$var1 = SCALAR(0x8164498)
$main::var1 =
\$main::var1 = SCALAR(0x8168eec)
$main::var1 is undef               &lt;&lt;&lt;&lt; やはり、シンボルテーブルにはあるがundefになっている。

$var2 = def                        &lt;&lt;&lt;&lt; 予想通り、グローバル変数も正常に参照できている。
\$var2 = SCALAR(0x8168f70)
$main::var2 = 456
\$main::var2 = SCALAR(0x8168f64)
</pre>

<p class="paragraph">
グローバル変数とlexical変数で同名のものがかぶってしまった場合、先にlexical変数として登録済か判断しているのかもしれない。登録済であればそちらを参照し、登録されていなければ、そこで初めて、現在のパッケージのシンボルテーブルを参照するのかもしれない。
<br />
</p>

<p class="paragraph">
いずれにせよ、これで冒頭のコードピースに対して抱いた謎は解けた。
<br />
</p>

<h4 id="ida7e989">コードピース (12) : ourについて - 1</h4>

<p class="paragraph">
my がシンボルテーブルと独立した名前空間と実体を提供するのに対し、our はシンボルテーブルをグローバル変数に見せかける(bindする)ために使われているようである。
<br />
また、ourは実体を作成しない（パッケージのシンボルテーブルをルックアップしているだけ？）ため、何度呼んでも同じ変数を参照できる。
<br />
</p>

<ul><li> コードピース</li></ul>
<pre>#!/usr/bin/perl
use 5.006;
print &#039;%:: = &#039;, join(&quot; &quot;, keys(%::)), &quot;\n&quot;;

our $var1;
$var1 = &quot;abc&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
print &#039;$main::var1 = &#039;, $main::var1, &quot;\n&quot;;
print &#039;\$main::var1 = &#039;, \$main::var1, &quot;\n&quot;;

our $var1;
$var1 = &quot;def&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
print &#039;$main::var1 = &#039;, $main::var1, &quot;\n&quot;;
print &#039;\$main::var1 = &#039;, \$main::var1, &quot;\n&quot;;

$main::var1 = &quot;ghi&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
print &#039;$main::var1 = &#039;, $main::var1, &quot;\n&quot;;
print &#039;\$main::var1 = &#039;, \$main::var1, &quot;\n&quot;;
</pre>

<ul><li> 出力：</li></ul>
<pre>%:: = ... var1 ...

$var1 = abc
\$var1 = SCALAR(0x81644f8)
$main::var1 = abc                  &lt;&lt;&lt;&lt; パッケージのシンボルテーブルにもちゃんと値が入る。
\$main::var1 = SCALAR(0x81644f8)        アドレスも同じところを参照している。

$var1 = def                        &lt;&lt;&lt;&lt; 二回呼んでも同じ場所を参照できる。
\$var1 = SCALAR(0x81644f8)
$main::var1 = def                  &lt;&lt;&lt;&lt; 片方を変更すれば、もう片方も変わる。
\$main::var1 = SCALAR(0x81644f8)

$var1 = ghi
\$var1 = SCALAR(0x81644f8)
$main::var1 = ghi                  &lt;&lt;&lt;&lt; 片方を変更すれば、もう片方も変わる。
\$main::var1 = SCALAR(0x81644f8)
</pre>

<p class="paragraph">
教科書通りの動きであることを確認できた。
<br />
</p>

<h4 id="id946212">コードピース (13) : ourについて - 2</h4>

<p class="paragraph">
our自体のスコープはmyと変わらない。同一ファイル中でパッケージが切り替わっても、元のパッケージのシンボルを参照できることを確認する。
<br />
</p>

<ul><li> コードピース (出力も織り交ぜる。)</li></ul>
<pre>#!/usr/bin/perl
use 5.006;
print &#039;%:: = &#039;, join(&quot; &quot;, keys(%::)), &quot;\n&quot;;
print &#039;%hoge:: = &#039;, join(&quot; &quot;, keys(%hoge::)), &quot;\n&quot;;
# 出力：
# %:: = .. var1 ...
# %hoge:: = var1

our $var1;
$var1 = &quot;abc&quot;;
# ダンプ出力：                     &lt;&lt;&lt;&lt; main::var1はourでbindされているが、hoge::var1は
# $var1 = abc                           undef。
# \$var1 = SCALAR(0x816957c)
# $main::var1 = abc
# \$main::var1 = SCALAR(0x816957c)
# $hoge::var1 =
# \$hoge::var1 = SCALAR(0x816963c)

package hoge;
# ダンプ出力：                     &lt;&lt;&lt;&lt; 現在パッケージが切り替わっても、our宣言された$var1は変わらず
# $var1 = abc                           mainパッケージの内容を参照できる。
# \$var1 = SCALAR(0x816957c)
# $main::var1 = abc
# \$main::var1 = SCALAR(0x816957c)
# $hoge::var1 =
# \$hoge::var1 = SCALAR(0x816963c)

$var1 = &quot;def&quot;;
# ダンプ出力：                     &lt;&lt;&lt;&lt; hogeパッケージないでも、ourのスコープ内なので、mainパッケージを
# $var1 = def                           参照している。
# \$var1 = SCALAR(0x816957c)
# $main::var1 = def
# \$main::var1 = SCALAR(0x816957c)
# $hoge::var1 =
# \$hoge::var1 = SCALAR(0x816963c)

$hoge::var1 = 123;
# ダンプ出力：                     &lt;&lt;&lt;&lt; パッケージ名指定でようやく値が設定される。
# $var1 = def
# \$var1 = SCALAR(0x816957c)
# $main::var1 = def
# \$main::var1 = SCALAR(0x816957c)
# $hoge::var1 = 123
# \$hoge::var1 = SCALAR(0x816963c)

package main;
# ダンプ出力：                     &lt;&lt;&lt;&lt; mainパッケージに戻っても、変わらず。
# $var1 = def
# \$var1 = SCALAR(0x816957c)
# $main::var1 = def
# \$main::var1 = SCALAR(0x816957c)
# $hoge::var1 = 123
# \$hoge::var1 = SCALAR(0x816963c)
</pre>

<p class="paragraph">
教科書通りである。
<br />
</p>

<h4 id="id22f322">コードピース (14) : ourについて(同じファイル中で、パッケージを異にして二回呼ぶ) - 3</h4>

<p class="paragraph">
コードピース(13)で、もしpackage hoge; に続いてourを使用したらどうなるのか？$var1が、$hoge::var1にバインドされるのではないか？
<br />
</p>
<ul><li> コードピース (出力も織り交ぜる。)</li></ul>
<pre>#!/usr/bin/perl
use 5.006;
print &#039;%:: = &#039;, join(&quot; &quot;, keys(%::)), &quot;\n&quot;;
print &#039;%hoge:: = &#039;, join(&quot; &quot;, keys(%hoge::)), &quot;\n&quot;;
# 出力：
# %:: = .. var1 ...
# %hoge:: = var1

our $var1;
$var1 = &quot;abc&quot;;

package hoge;
# ダンプ出力：                     &lt;&lt;&lt;&lt; この時点では、$var1は$main::var1にバインドされている。
# $var1 = abc
# \$var1 = SCALAR(0x8169584)
# $main::var1 = abc
# \$main::var1 = SCALAR(0x8169584)
# $hoge::var1 =
# \$hoge::var1 = SCALAR(0x8169644)

our $var1 = &quot;def&quot;;
# ダンプ出力：                     &lt;&lt;&lt;&lt; バインド先が$hoge::var1切り替わっている。
# $var1 = def
# \$var1 = SCALAR(0x8169644)
# $main::var1 = abc
# \$main::var1 = SCALAR(0x8169584)
# $hoge::var1 = def
# \$hoge::var1 = SCALAR(0x8169644)

$hoge::var1 = 123;
# ダンプ出力：                     &lt;&lt;&lt;&lt; $hoge::var1を変更すれば、bindしている$var1も連動する。
# $var1 = 123
# \$var1 = SCALAR(0x8169644)
# $main::var1 = abc
# \$main::var1 = SCALAR(0x8169584)
# $hoge::var1 = 123
# \$hoge::var1 = SCALAR(0x8169644)

package main;
# ダンプ出力：                     &lt;&lt;&lt;&lt; mainパッケージに戻っても、$var1は$hoge::var1にbindしている。
# $var1 = 123
# \$var1 = SCALAR(0x8169644)
# $main::var1 = abc
# \$main::var1 = SCALAR(0x8169584)
# $hoge::var1 = 123
# \$hoge::var1 = SCALAR(0x8169644)
</pre>

<p class="paragraph">
教科書通りであるが、こういった形で使用することは殆ど無いと思われる。
<br />
</p>

<h4 id="id1a47a2">コードピース (15) : ourについて - lexcal変数と同じく、ファイルが異なれば参照不可を確認</h4>

<p class="paragraph">
パッケージAからパッケージBの変数にアクセスするには、パッケージBのシンボルテーブルに対象の変数が載っていなければならない。
<br />
スペルミスを防ぐ為、use strict 機能を使用すると、下記のコードで &quot;Global symbol &quot;$pkg_global&quot; requires explicit package name&quot; が発生し、コンパイルエラーとなる。
<br />
</p>
<pre>package pkgA;
$pkg_global = 123;
</pre>
<p class="paragraph">
この対策として、5.6より前は use vars, 5.6以降はourが使えるようになっている。
<br />
</p>

<p class="paragraph">
<strong>→上記記述は、誤解を含んでいた。</strong>パッケージBのシンボルテーブルの変数を、パッケージA上から普通にアクセスするにはourを使う必要があると、混乱していた。
<br />
</p>

<p class="paragraph">
ourのperldoc( <a class="externallink" href="http://perldoc.perl.org/functions/our.html" target="_blank">http://perldoc.perl.org/functions/our.html</a> )を見ても分かるとおり、ourはパッケージのシンボルテーブル上の変数を、lexical変数と同じスコープでパッケージ名を省略できるようにしているだけである。
<br />
従って、コードピース(14)の場合は、<strong>同じファイル中なので</strong>、当然パッケージAでourを使っていれば、ファイル中の後ろに続くパッケージBでも、同じ変数を参照できる。逆に下記に示すコードピースの場合、<strong>ファイルが異なるため</strong>、当然 &quot;package test2&quot; でourしているvar1は、&quot;package test1&quot;からはパッケージ名を省略して参照することはできない。
<br />
</p>

<p class="paragraph">
モジュールを使用するに当たり、もっともよく使うであろうパターンの動作を確認してみる。
<br />
</p>
<ul><li> コードピース<ul><li> test2.pm</li></ul></li></ul>
<pre>package test2;
our $var1 = 123;
sub func {
print &quot;package=[&quot;, __PACKAGE__, &quot;]\n&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
}
1;
</pre>
<ul><li><ul><li> test.pl</li></ul></li></ul>
<pre>#!/usr/bin/perl
use 5.006;
use test2;
print &#039;%:: = &#039;, join(&quot; &quot;, keys(%::)), &quot;\n&quot;;
print &#039;%test2:: = &#039;, join(&quot; &quot;, keys(%test2::)), &quot;\n&quot;;

our $var1;
$var1 = &quot;abc&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
print &#039;$main::var1 = &#039;, $main::var1, &quot;\n&quot;;
print &#039;\$main::var1 = &#039;, \$main::var1, &quot;\n&quot;;
&amp;test2::func;

$test2::var1 = 456;

print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
print &#039;$main::var1 = &#039;, $main::var1, &quot;\n&quot;;
print &#039;\$main::var1 = &#039;, \$main::var1, &quot;\n&quot;;
&amp;test2::func;
</pre>

<ul><li> 出力：</li></ul>
<pre>%:: = ... var1 ...
%test2:: = var1 func import

$var1 = abc                       &lt;&lt;&lt;&lt; 初期状態
\$var1 = SCALAR(0x81691c0)
$main::var1 = abc
\$main::var1 = SCALAR(0x81691c0)
package=[test2]
$var1 = 123
\$var1 = SCALAR(0x81690ac)

$var1 = abc                       &lt;&lt;&lt;&lt; $test2::var1更新後。
\$var1 = SCALAR(0x81691c0)             mainパッケージは変化がないが、test2パッケージのvar1
$main::var1 = abc                      は確実に更新されている。
\$main::var1 = SCALAR(0x81691c0)
package=[test2]
$var1 = 456
\$var1 = SCALAR(0x81690ac)
</pre>

<p class="paragraph">
これも、教科書通りの動きとなった。<strong>ourはlexical変数と同じスコープになる為、同じ名前の変数をourしていても、ファイルが異なれば異なる変数実体にbindする。</strong>
<br />
</p>

<h4 id="id1f624b">コードピース (16) : use vars</h4>

<p class="paragraph">
これはPerl5.6より前の機能である為、それほど突っ込まない。
<br />
</p>

<p class="paragraph">
コードピース (15)でも述べたが、use strict を有効化すると、パッケージ変数を書くのが面倒くさくなる。
<br />
</p>
<pre>package pkgA;
use strict;

$pkg_global = 123; &lt;&lt;&lt;&lt; コンパイルエラー。
$pkgA::pkg_global = 123; &lt;&lt;&lt;&lt; セーフ。
</pre>

<p class="paragraph">
これに対処する為のプラグマ(pragma)が &quot;use vars&quot; である。コードピース(13)のtest2.pmを、use vars に直してみる。
<br />
</p>

<ul><li> コードピース<ul><li> test2.pm</li></ul></li></ul>
<pre>package test2;
use strict;
use vars qw($var1);
$var1 = 123;
sub func {
print &quot;package=[&quot;, __PACKAGE__, &quot;]\n&quot;;
print &#039;$var1 = &#039;, $var1, &quot;\n&quot;;
print &#039;\$var1 = &#039;, \$var1, &quot;\n&quot;;
}
1;
</pre>
<ul><li><ul><li> test.pl</li></ul></li></ul>
<pre>#!/usr/bin/perl
use test2;
print &#039;%test2:: = &#039;, join(&quot; &quot;, keys(%test2::)), &quot;\n&quot;;
&amp;test2::func;
$test2::var1 = 456;
&amp;test2::func;
</pre>

<ul><li> 出力：</li></ul>
<pre>%test2:: = var1 BEGIN func import
package=[test2]
$var1 = 123
\$var1 = SCALAR(0x819e82c)
package=[test2]
$var1 = 456
\$var1 = SCALAR(0x819e82c)
</pre>

<p class="paragraph">
ourを使用したときと同じであることを確認できた。
<br />
</p>

<h4 id="id237a14">コードピース (17) : とりあえずのまとめ</h4>

<p class="paragraph">
本節のコードピース(1) - (16)は、実は最初からその順にtry&amp;errorしていったわけではない。最初、冒頭でmyの順番を逆にしたりしていたときに、どうしても教科書通りの説明だけでは納得いかなくなり、&quot;参照&quot;で示したURLを参照したり、何度か試行錯誤した。そして次のコードにtryした結果、漸く靄が晴れた。その後、頭で結実したロジックを一個一個確認していくためにコードピース(1) - (16)を順次試していった。
<br />
</p>

<p class="paragraph">
自分はCからプログラミングに入っていった為、シンボル管理についてはどうしても、メモリアドレスと結びつかないと理解できない頭になってしまったようである<span class="hidden">(</span><a class="footnote" href="#footnote_139_5" id="footnote_139_5_r"  title="PHPはこのための関数が無いから辛い・・・。xdebugにも無いんだもの。">*5</a><span class="hidden">)</span>。思い切って、リファレンスのアドレスを表示させてみたのが幸いした。
<br />
</p>

<p class="paragraph">
自分も含めて、もしシンボルテーブル・my・ourの区別があやふやになった場合は、以下のコードピースで、パッケージの切り替えや変数への代入・4種類の変数内容の動きをoutputと合わせてじっくり眺めて欲しい。
<br />
</p>

<ul><li> コードピース：出力を織り込む。</li></ul>
<pre>#!/usr/bin/perl

$var1 = &quot;in_main&quot;;
my $var2 = &quot;in_main&quot;;
our $var3 = &quot;in_main&quot;;
$hoge::var4 = &quot;in_main&quot;;
# &gt;&gt;&gt;&gt; output:
(var1, main::var1, hoge::var1) = (in_main, in_main, )
(\var1, \main::var1, \hoge::var1) = (SCALAR(0x18242fc), SCALAR(0x18242fc), SCALAR(0x182d524))
(var2, main::var2, hoge::var2) = (in_main, , )
(\var2, \main::var2, \hoge::var2) = (SCALAR(0x18242e4), SCALAR(0x182d5d8), SCALAR(0x182d614))
(var3, main::var3, hoge::var3) = (in_main, in_main, )
(\var3, \main::var3, \hoge::var3) = (SCALAR(0x182435c), SCALAR(0x182435c), SCALAR(0x182d6ec))
(var4, main::var4, hoge::var4) = (, , in_main)
(\var4, \main::var4, \hoge::var4) = (SCALAR(0x182d77c), SCALAR(0x182d77c), SCALAR(0x18243a4))
# &lt;&lt;&lt;&lt;

package hoge;
# &gt;&gt;&gt;&gt; output:
(var1, main::var1, hoge::var1) = (, in_main, )
(\var1, \main::var1, \hoge::var1) = (SCALAR(0x182d524), SCALAR(0x18242fc), SCALAR(0x182d524))
(var2, main::var2, hoge::var2) = (in_main, , )
(\var2, \main::var2, \hoge::var2) = (SCALAR(0x18242e4), SCALAR(0x182d5d8), SCALAR(0x182d614))
(var3, main::var3, hoge::var3) = (in_main, in_main, )
(\var3, \main::var3, \hoge::var3) = (SCALAR(0x182435c), SCALAR(0x182435c), SCALAR(0x182d6ec))
(var4, main::var4, hoge::var4) = (in_main, , in_main)
(\var4, \main::var4, \hoge::var4) = (SCALAR(0x18243a4), SCALAR(0x182d77c), SCALAR(0x18243a4))
# &lt;&lt;&lt;&lt;

$var1 = &quot;in_hoge&quot;;
my $var2 = &quot;in_hoge&quot;;
our $var3 = &quot;in_hoge&quot;;
$hoge::var4 = &quot;in_hoge&quot;;
# &gt;&gt;&gt;&gt; output:
(\var1, \main::var1, \hoge::var1) = (SCALAR(0x182d524), SCALAR(0x18242fc), SCALAR(0x182d524))
(var2, main::var2, hoge::var2) = (in_hoge, , )
(\var2, \main::var2, \hoge::var2) = (SCALAR(0x1830db0), SCALAR(0x182d5d8), SCALAR(0x182d614))
(var3, main::var3, hoge::var3) = (in_hoge, in_main, in_hoge)
(\var3, \main::var3, \hoge::var3) = (SCALAR(0x182d6ec), SCALAR(0x182435c), SCALAR(0x182d6ec))
(var4, main::var4, hoge::var4) = (in_hoge, , in_hoge)
(\var4, \main::var4, \hoge::var4) = (SCALAR(0x18243a4), SCALAR(0x182d77c), SCALAR(0x18243a4))
# &lt;&lt;&lt;&lt;

package main;
# &gt;&gt;&gt;&gt; output:
(var1, main::var1, hoge::var1) = (in_main, in_main, in_hoge)
(\var1, \main::var1, \hoge::var1) = (SCALAR(0x18242fc), SCALAR(0x18242fc), SCALAR(0x182d524))
(var2, main::var2, hoge::var2) = (in_hoge, , )
(\var2, \main::var2, \hoge::var2) = (SCALAR(0x1830db0), SCALAR(0x182d5d8), SCALAR(0x182d614))
(var3, main::var3, hoge::var3) = (in_hoge, in_main, in_hoge)
(\var3, \main::var3, \hoge::var3) = (SCALAR(0x182d6ec), SCALAR(0x182435c), SCALAR(0x182d6ec))
(var4, main::var4, hoge::var4) = (, , in_hoge)
(\var4, \main::var4, \hoge::var4) = (SCALAR(0x182d77c), SCALAR(0x182d77c), SCALAR(0x18243a4))
# &lt;&lt;&lt;&lt;
</pre>

<h3 id="idab811b">参考URL [#k0d79c00]</h3>
<ul><li> perldoc, &quot;vars&quot; : <a class="externallink" href="http://perldoc.perl.org/vars.html" target="_blank">http://perldoc.perl.org/vars.html</a></li>
<li> perldoc, &quot;our&quot; : <a class="externallink" href="http://perldoc.perl.org/functions/our.html" target="_blank">http://perldoc.perl.org/functions/our.html</a></li>
<li> perldoc, &quot;my&quot; : <a class="externallink" href="http://perldoc.perl.org/functions/my.html" target="_blank">http://perldoc.perl.org/functions/my.html</a></li>
<li> perldoc, &quot;strict&quot; : <a class="externallink" href="http://perldoc.perl.org/strict.html" target="_blank">http://perldoc.perl.org/strict.html</a></li>
<li> perldoc, &quot;faq7&quot; : <a class="externallink" href="http://perldoc.perl.org/perlfaq7.html" target="_blank">http://perldoc.perl.org/perlfaq7.html</a></li>
<li> perl-beginner ML : &quot;my, our, local?&quot;<ul><li> <a class="externallink" href="http://tech.groups.yahoo.com/group/perl-beginner/messages/16382?threaded=1&amp;m=e&amp;var=1&amp;tidx=1" target="_blank">http://tech.groups.yahoo.com/group/perl-beginner/messages/16382?threaded=1&amp;m=e&amp;var=1&amp;tidx=1</a></li></ul></li></ul>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-135.html" title="Perl/codepiece/manupilate_INC_by_FindBin">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-119.html" title="Perl/codepiece/pseudo_block">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-109.html" title="Perl">Perl</a>&nbsp;]</li>
</ul><div class="footnote">
<a id="footnote_139_1" href="#footnote_139_1_r">*1</a>: 本当にこれで正鵠か否かは調査が必要だが、ここでの文脈に限って言えばこれで正しいと思う。<br />
<a id="footnote_139_2" href="#footnote_139_2_r">*2</a>: 自分のことである。<br />
<a id="footnote_139_3" href="#footnote_139_3_r">*3</a>: この呼び名であっているのか？<br />
<a id="footnote_139_4" href="#footnote_139_4_r">*4</a>: シンボルの取り扱いの癖の強さは、特にLLに顕著だと思う。<br />
<a id="footnote_139_5" href="#footnote_139_5_r">*5</a>: PHPはこのための関数が無いから辛い・・・。xdebugにも無いんだもの。
</div>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/139<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2007 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>