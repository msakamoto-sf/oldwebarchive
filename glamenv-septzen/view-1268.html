<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>技術/Socketプログラミング/Java (Groovy) の Socketプログラミングを strace と Wireshark で覗く - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">技術/Socketプログラミング/Java (Groovy) の Socketプログラミングを strace と Wireshark で覗く</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2014-02-15 22:53:28 &nbsp; / &nbsp; last updated at: 2014-02-15 23:04:50<br>
カテゴリ: <a href="category-68.html">Groovy</a>&nbsp;<a href="category-11.html">Java</a>&nbsp;<a href="category-38.html">UNIX</a>&nbsp;<a href="category-30.html">ネットワーク</a>&nbsp;<a href="category-12.html">プログラミング</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-1421.html" title="技術/Security/testssl.sh">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-1371.html" title="技術/Socketプログラミング/Wiresharkの使い方メモ">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-23.html" title="技術">技術</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
JavaのSocketプログラミングでTCP通信を勉強し始めてから10年近く、ずっと気になっていた点として、socket周りのシステムコールとTCPパケットレベルでの挙動観察をしてみようと思います。
<br />
</p>



<ul><li><a href="#id67a51e">実験環境とサンプルコード</a></li>
<li><a href="#idf12042">動かし方</a></li>
<li><a href="#id8da126">SocketプログラミングとTCPフロー</a></li>
<li><a href="#id8f9893">サーバサイドのスレッドのシステムコール</a></li>
<li><a href="#id326d4a">&quot;UNIX Network Programming&quot; からのメモ</a><ul><li><a href="#id0d86c1">listen(2)の第二引数の&quot;int backlog&quot;って何？</a></li>
<li><a href="#ide4db03">blockingモードのソケットを使ったconnect(2)は、POSIXレベルでは「接続タイムアウト」を指定できない。</a></li>
<li><a href="#id6ca32e">アプリケーションレイヤー(ユーザーランド)でaccept(2)を使うとき、サーバ側のプログラムで「接続タイムアウト」を発生させることは可能か？</a></li>
<li><a href="#id7c8b2c">UNPにはTCPの状態遷移のダイアグラムは載ってないの？</a></li>
<li><a href="#idd6f37e">TCPの接続～read/write～切断までの、システムコールと実際のTCPフローの相関図が欲しい</a></li>
<li><a href="#id3120ee">accept(2) -&gt; fork(2) する形式で、サーバ側が同じポートにbindした状態のソケットを複数扱えるのはなぜ？</a></li>
<li><a href="#id7718a8">listen(2) -&gt; fork(2) した後に複数の子プロセスからaccept(2)できるのはなぜ？(pre-forkスタイル)</a></li>
<li><a href="#id9db278">shutdown(2)って何のためにあるの？</a></li>
<li><a href="#idc4c73e">socket周りのシステムコールに使う定数で、&quot;AF_&quot;で始まるものと&quot;PF_&quot;で始まるものがあるのはなぜ？どう使い分ける？</a></li>
<li><a href="#id1cf4d8">SO_LINGERっていうソケットオプションはどう使うのか？</a></li></ul></li>
<li><a href="#idb684e5">接続時のタイムアウト、read()時のタイムアウト</a><ul><li><a href="#idb94e5f">接続時のタイムアウト</a></li>
<li><a href="#id379db2">listen()してないportにconnect() -&gt; ConnectException</a></li>
<li><a href="#idd9f644">SocketのsetSoTimeout() -&gt; read()時のタイムアウト</a></li></ul></li>
<li><a href="#id11f527">参考資料</a></li></ul>
<hr />
<h3 id="id67a51e">実験環境とサンプルコード</h3>

<p class="paragraph">
サンプルコード:
<br />
</p>
<ul><li> <a class="externallink" href="https://gist.github.com/msakamoto-sf/9015555" target="_blank">https://gist.github.com/msakamoto-sf/9015555</a><ul><li> t_tcp_echo_with_strace_1.groovy : サーバサイド<ul><li> 1:1でのみ動作する、非常にシンプルなechoサーバです。</li>
<li> accept(), read()の後のwrite()の前後でconsole.readLine()を挟むことで、サーバの動きを一時停止させてます。</li>
<li> straceを別スレッドから起動して、サーバのスレッド自身のシステムコール呼び出しをトレースさせてます。</li></ul></li>
<li> t_tcp_echo_client_1.groovy : クライアントサイド<ul><li> 非常にシンプルなechoクライアントです。接続タイムアウトと、read()でのタイムアウトを設定できるようにしてます。</li></ul></li></ul></li></ul>

<p class="paragraph">
クライアントサイド実行環境：
<br />
</p>
<pre class="plugin_pre">
Windows7Pro SP1 64bit 日本語版
&gt;java -version
java version &quot;1.7.0_25&quot;
Java(TM) SE Runtime Environment (build 1.7.0_25-b17)
Java HotSpot(TM) 64-Bit Server VM (build 23.25-b01, mixed mode)

&gt;groovy -version
Groovy Version: 2.2.1 JVM: 1.7.0_25 Vendor: Oracle Corporation OS: Windows 7

VirtualBox 4.3.6 -&gt; サーバサイドのCentOS6をゲストOSとして稼働
</pre>

<p class="paragraph">
サーバサイド実行環境：
<br />
</p>
<pre class="plugin_pre">
CentOS6 x86_64版
クライアントサイド実行環境上のVirtualBox上で、GuestOSとして実行
Host Onlyのネットワークインターフェイスを設定し、192.168.56.101が割り振られている。

$ uname -a
Linux dev2c6x64.lab.glamenv-septzen.net 2.6.32-431.5.1.el6.x86_64 #1 SMP \
     Wed Feb 12 00:41:43 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux

$ java -version
java version &quot;1.7.0_51&quot;
Java(TM) SE Runtime Environment (build 1.7.0_51-b13)
Java HotSpot(TM) 64-Bit Server VM (build 24.51-b03, mixed mode)

$ groovy -version
Groovy Version: 2.2.1 JVM: 1.7.0_51 Vendor: Oracle Corporation OS: Linux
</pre>

<p class="paragraph">
※サーバサイドのCentOS6では、実験時はiptablesを停止しておきました。
<br />
</p>
<pre># service iptables stop
</pre>

<h3 id="idf12042">動かし方</h3>

<p class="paragraph">
今回はVirtualBox上のゲストOS(CentOS6)でサーバサイドを動作させ、ホストOS(Win7)からWiresharkを起動してEchoサーバ・クライアント間の通信をキャプチャ出来るようにして、クライアントサイドを動かしました。
<br />
</p>

<p class="paragraph">
まずサーバサイドで t_tcp_echo_with_strace_1.groovy を起動します。listenするポート番号は10007をハードコードしてますが、お好みに応じてカスタマイズして下さい。
<br />
</p>
<pre>$ groovy t_tcp_echo_with_strace_1.groovy
log stdout to 2014-02-15_18-29-07_10565.sout
log stderr to 2014-02-15_18-29-07_10565.serr
start : strace -e trace=socket,readv,recvfrom,write,writev,sendto,listen,bind,accept,shutdown,close -p 10565
ready?(入力待ち→Enterを入力)
echo server started, listening port: 10007
accpet?(入力待ち→Enterを入力すると、accept(2)が走ります)
</pre>

<p class="paragraph">
続けてホストOS側でWiresharkを起動します。&quot;Sun: \Device\NPF_{...(省略)...}&quot; となっているインターフェイスを選択して、余計なパケットをキャプチャしないよう、以下のcapture filterを設定してキャプチャを開始します。
<br />
</p>
<pre>tcp port 10007
</pre>

<p class="paragraph">
最後にホストOS側でクライアントサイドを実行します。
<br />
</p>

<pre>&gt; groovy t_tcp_echo_client_1.groovy 192.168.56.101 10007
connect() start
SO_REUSEADDR = false
SO_LINGER = -1
SO_TIMEOUT = 10000
SO_KEEPALIVE = false
OOBINLINE = false
TCP_NODELAY = false
connected to /192.168.56.101:10007
send1&gt;(入力待ち)
</pre>
<p class="paragraph">
ここでサーバ側を見てみると、accept()が接続を受付け、以下の様なメッセージが出力されます。
<br />
</p>
<pre>Remote(192.168.56.1:49878) -&gt; Local(192.168.56.101:10007)
</pre>
<p class="paragraph">
クライアント側で&quot;hello1&quot;+Enterと入力すると、サーバサイド側でread()します。
<br />
</p>
<pre>read 6 bytes.
echo?(入力待ち)
</pre>
<p class="paragraph">
→ここでサーバサイドを10秒以上放置すると、クライアント側ではread timeoutになります。ひとまずすぐにEnterを入力します。
<br />
クライアント側は、サーバからの読み込みはダミーで1バイト読み込んでおくだけにとどめていて、すぐに2つめの入力待ちに進みます。
<br />
</p>
<pre>send2&gt;(入力待ち)
</pre>
<p class="paragraph">
→&quot;hello2&quot;と入力すると、サーバサイド側でまたread()します。
<br />
</p>
<pre>read 6 bytes.
echo?(入力待ち)
</pre>
<p class="paragraph">
すぐにEnterを入力します。
<br />
クライアント側は、Socket#shutdownInput()前の入力待ちになります。
<br />
</p>
<pre>shutdownInput?(入力待ち)
</pre>
<p class="paragraph">
→Enterを入力すると、shutdownInput()が実行され、後述しますがRST+ACKがサーバ側に送信されます。
<br />
サーバ側ではread()中にIOExceptionが発生し、リモートからの切断として処理を進めます。
<br />
</p>
<pre>closed from remote
close?(入力待ち→Enterを入力)
end : exitValue = 0
</pre>
<p class="paragraph">
クライアント側はその後、shutdownOutput()とclose()がそれぞれ、入力待ちで実行されます。
<br />
</p>
<pre>shutdownOutput?(入力待ち→Enterを入力)
close?(入力待ち→Enterを入力)
</pre>

<h3 id="id8da126">SocketプログラミングとTCPフロー</h3>

<p class="paragraph">
上記の動かし方で動かした時の、TCPの流れを簡単にまとめます。
<br />
1. クライアントからのSocket#connect() -&gt; サーバでのaccept()
<br />
</p>
<pre>client --&gt;   SYN   --&gt; server
clinet &lt;-- SYN+ACK &lt;-- server
client --&gt;   ACK   --&gt; server
</pre>
<p class="paragraph">
2. クライアントからのOutputStream#write(&quot;hello1&quot;)
<br />
</p>
<pre>client --&gt; PUSH+ACK(&quot;hello1&quot;) --&gt; server
client &lt;--      ACK           &lt;-- server
</pre>
<p class="paragraph">
3. サーバからのechoによるwrite()
<br />
</p>
<pre>clinet &lt;-- PUSH+ACK(&quot;hello1&quot;) &lt;-- server
client --&gt;      ACK           --&gt; server
</pre>
<p class="paragraph">
4. クライアントからのOutputStream#write(&quot;hello2&quot;)
<br />
</p>
<pre>client --&gt; PUSH+ACK(&quot;hello2&quot;) --&gt; server
client &lt;--      ACK           &lt;-- server
</pre>
<p class="paragraph">
5. サーバからのechoによるwrite()
<br />
</p>
<pre>clinet &lt;-- PUSH+ACK(&quot;hello2&quot;) &lt;-- server
client --&gt;      ACK           --&gt; server
</pre>
<p class="paragraph">
6. クライアントからのSocket#shutdownInput()
<br />
</p>
<pre>client --&gt; RST + ACK --&gt; server
</pre>

<p class="paragraph">
※ちなみに、クライアント側の終了時の処理をclose()だけにすると、以下のようになりました。
<br />
</p>
<pre>clinet --&gt; FIN+ACK --&gt; server
clinet --&gt; RST+ACK --&gt; server
</pre>

<h3 id="id8f9893">サーバサイドのスレッドのシステムコール</h3>

<p class="paragraph">
サーバサイドのサンプルコードでは、straceを別スレッドで実行して、標準出力と標準エラー出力を分けてファイルに出力してます。で、どうもdettachしてJavaの方も終了しないと、バッファがフラッシュされないらしくて、内容を確認できるのはJavaの方が終了してからとなりました。標準出力は空っぽで、全部標準エラー出力の方に出てました。
<br />
socket(2)からのログをペタばりしておきます。見たまんまではあります。
<br />
</p>
<pre class="plugin_pre">
socket(PF_INET6, SOCK_STREAM, IPPROTO_IP) = 67
bind(67, {sa_family=AF_INET6, sin6_port=htons(10007), inet_pton(AF_INET6, &quot;::&quot;, &amp;sin6_addr), sin6_flowinfo=0, sin6_scope_id=0}, 28) = 0
listen(67, 50)                          = 0
write(1, &quot;echo server started, listening p&quot;..., 42) = 42
write(1, &quot;\n&quot;, 1)                       = 1
write(1, &quot;accpet?&quot;, 7)                  = 7
accept(67, {sa_family=AF_INET6, sin6_port=htons(49878), inet_pton(AF_INET6, &quot;::ffff:192.168.56.1&quot;, &amp;sin6_addr), sin6_flowinfo=0, sin6_scope_id=0}, [28]) = 69
write(1, &quot;Remote(192.168.56.1:49878) -&gt; Lo&quot;..., 57) = 57
write(1, &quot;\n&quot;, 1)                       = 1
recvfrom(69, &quot;hello1&quot;, 1024, 0, NULL, NULL) = 6
write(1, &quot;read 6 bytes.&quot;, 13)           = 13
write(1, &quot;\n&quot;, 1)                       = 1
write(1, &quot;echo?&quot;, 5)                    = 5
sendto(69, &quot;hello1&quot;, 6, 0, NULL, 0)     = 6
recvfrom(69, &quot;hello2&quot;, 1024, 0, NULL, NULL) = 6
write(1, &quot;read 6 bytes.&quot;, 13)           = 13
write(1, &quot;\n&quot;, 1)                       = 1
write(1, &quot;echo?&quot;, 5)                    = 5
sendto(69, &quot;hello2&quot;, 6, 0, NULL, 0)     = 6
recvfrom(69, 0x7f5040540760, 1024, 0, 0, 0) = -1 ECONNRESET (Connection reset by peer)
recvfrom(69, &quot;&quot;, 1024, 0, NULL, NULL)   = 0
close(69)                               = 0
write(1, &quot;closed from remote&quot;, 18)      = 18
write(1, &quot;\n&quot;, 1)                       = 1
write(1, &quot;close?&quot;, 6)                   = 6
close(67)                               = 0
</pre>

<p class="paragraph">
驚いたのが、recvfrom(2)とsendto(2)を使っていた点でした。最初、てっきりread(2)/write(2)だろうと思ってtrace対象システムコールを絞ってたのですが、全く使われてる様子が見られず、試しに&quot;-e&quot;を外して全部ログさせるモードでstraceしてみたらrecvfrom(2)とsendto(2)を使っていたという・・・。
<br />
</p>

<h3 id="id326d4a">&quot;UNIX Network Programming&quot; からのメモ</h3>

<p class="paragraph">
上記説明は、動かしてみれば「ふーん、まぁその通りに動くよねぇ。で？」となる話でわざわざ記事を書くほどのもんでも無いっちゃー無いんですが、ここまで突っ込んだきっかけとしては、ずっと積ん読状態だった&quot;UNIX Network Programming&quot;(3rd Edition, Volume 1, 以下、&quot;UNP&quot;)をパラパラめくってたら、長年の疑問がいくつか氷解したことでした。
<br />
</p>

<h4 id="id0d86c1">listen(2)の第二引数の&quot;int backlog&quot;って何？</h4>

<p class="paragraph">
これ、単純なサンプル組んだだけでは、適当な整数値入れても動きが変わらなくてずっと「なんだろこれ」って思ってたんですが。
<br />
UNPの p104, &quot;Elementary TCP Sockets&quot;, &quot;4.5 listen Function&quot; に、Figure 4.7でめっちゃ分かりやすく解説されてました。
<br />
もっと早く読んでおけばよかった。
<br />
accept()中のサーバに対してSYNパケットが殺到した時のキューなんですね。
<br />
そりゃ、サンプル程度の負荷じゃ影響しないわけだ・・・。
<br />
</p>

<h4 id="ide4db03">blockingモードのソケットを使ったconnect(2)は、POSIXレベルでは「接続タイムアウト」を指定できない。</h4>

<ul><li> Linux:<ul><li> <a class="externallink" href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man2/connect.2.html" target="_blank">http://linuxjm.sourceforge.jp/html/LDP_man-pages/man2/connect.2.html</a></li></ul></li>
<li> BSD:<ul><li> <a class="externallink" href="http://www.freebsd.org/cgi/man.cgi?query=connect&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.0-RELEASE&amp;arch=default&amp;format=html" target="_blank">http://www.freebsd.org/cgi/man.cgi?query=connect&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.0-RELEASE&amp;arch=default&amp;format=html</a></li></ul></li></ul>

<p class="paragraph">
POSIXレベルではconnect(2)では接続タイムアウトを指定できないみたいっすね。これはSE時代に仕事でconnect(2)弄ってた時に知りました。
<br />
ただ、解法としてSIGALRMによるタイムアウトの実装というのをきちんとした資料で確認できたのは今日が初めてかも？
<br />
UNPのp382, &quot;Advanced I/O Functions&quot; の &quot;14.2 Socket Timeouts&quot; 参照です。
<br />
</p>

<h4 id="id6ca32e">アプリケーションレイヤー(ユーザーランド)でaccept(2)を使うとき、サーバ側のプログラムで「接続タイムアウト」を発生させることは可能か？</h4>

<p class="paragraph">
クライアント側のconnect(2)は、SYNを送った後、サーバからのSYN+ACKを受け取ってユーザーランドにreturnしてきます。
<br />
ここで、「接続タイムアウト」を実装したプログラムを単体テストしようとするとどうしても「接続タイムアウト」を発生させる必要が生じます。
<br />
</p>

<p class="paragraph">
そこで長年の疑問だったのが、accept(2)を使うケースでサーバからのSYN+ACKを送るタイミングを操作できるか？でした。
<br />
これさえ自由に使えれば、いくらでもSYN+ACKを遅らせることで「接続タイムアウト」を任意に発生させることが出来るのに・・・。
<br />
</p>

<p class="paragraph">
で、今回UNPをめくってみたところ、accept(2)ではカーネルレベルで自動的にSYN+ACKを送ることが判明したため、ようやくこのもやもやに決着を付けることが出来ました。
<br />
</p>

<p class="paragraph">
UNPのp37, &quot;The Transport Layer: TCP, UDP and SCTP&quot; の &quot;2.6 TCP Connection Establishment and Termination&quot; に、Figure 2.2 で分かりやすく、connect(2)とaccept(2)の裏側で、どういうタイミングでSYN -&gt; SYN+ACK -&gt; ACKのやりとりがされ、どこで各システムコールからreturnするのかが図示されてました。
<br />
</p>

<p class="paragraph">
<strong> 結論としては、「接続タイムアウト」を発生させる = 新しく受信したSYNパケットの処理をDROPさせる、なので、iptablesなどのファイアーウォールの仕組みを使うと一発でした。 </strong>
<br />
</p>


<h4 id="id7c8b2c">UNPにはTCPの状態遷移のダイアグラムは載ってないの？</h4>

<p class="paragraph">
p40, &quot;The Transport Layer: TCP, UDP, and SCTP&quot; の &quot;TCP State Transition Diagram&quot;, Figure 2.4 を参照。
<br />
（ホントは裏表紙とかすぐ参照できるところに載せておいて欲しいとこだった）
<br />
</p>

<h4 id="idd6f37e">TCPの接続～read/write～切断までの、システムコールと実際のTCPフローの相関図が欲しい</h4>

<p class="paragraph">
TCPの接続と切断については、UNPのp37, &quot;The Transport Layer: TCP, UDP and SCTP&quot; の &quot;2.6 TCP Connection Establishment and Termination&quot; 参照。
<br />
</p>

<p class="paragraph">
read/writeも含めた相関図は、p42, &quot;The Transport Layer: TCP, UDP, and SCTP&quot; の &quot;Watching the Packets&quot;, Figure 2.5 参照。
<br />
</p>

<h4 id="id3120ee">accept(2) -&gt; fork(2) する形式で、サーバ側が同じポートにbindした状態のソケットを複数扱えるのはなぜ？</h4>

<p class="paragraph">
UNP p52, &quot;The Transport Layer: TCP, UDP, and SCTP&quot; の &quot;2.9 Port Numbers&quot; の &quot;Socket Pair&quot; と &quot;2.10 TCP Port Nubmers and Concurrent Servers&quot; にありますが、リモート接続のホスト+ポート番号と、ローカルのホスト+ポート番号の4点をペアにして&quot;Socket Pair&quot;として管理しているからのようです。
<br />
</p>

<h4 id="id7718a8">listen(2) -&gt; fork(2) した後に複数の子プロセスからaccept(2)できるのはなぜ？(pre-forkスタイル)</h4>

<p class="paragraph">
UNP p817, &quot;Client/Server Design Alternatives&quot; に、fork(2)した後の複数の子プロセスから同じfiledescriptorに対してaccept(2)できる理由(=&quot;prefork&quot;)と、その際に注意する事柄が、いくつかの実装パターンに分けて丁寧に解説されてますので、そちらを参照。
<br />
</p>

<h4 id="id9db278">shutdown(2)って何のためにあるの？</h4>

<p class="paragraph">
UNP p172, &quot;I/O Multiplexing: The select and poll Functions&quot; の &quot;6.6 shutdown Function&quot; 参照。
<br />
</p>

<h4 id="idc4c73e">socket周りのシステムコールに使う定数で、&quot;AF_&quot;で始まるものと&quot;PF_&quot;で始まるものがあるのはなぜ？どう使い分ける？</h4>

<p class="paragraph">
UNP p98, &quot;AF_xxx versus PF_xxx&quot; 参照。
<br />
</p>

<h4 id="id1cf4d8">SO_LINGERっていうソケットオプションはどう使うのか？</h4>

<p class="paragraph">
UNP p202, &quot;Socket Options&quot;, &quot;SO_LINGER Socket Option&quot; 参照。
<br />
</p>

<h3 id="idb684e5">接続時のタイムアウト、read()時のタイムアウト</h3>

<p class="paragraph">
JavaのSocketプログラミングの「テスト」で、一番悩ましいのが「タイムアウト」の発生のさせ方であります。
<br />
今回のサンプルコードで実験してみましたのでメモ。
<br />
なお、サンプルコードを見れば明らかですがいずれもサーバサイドがblockingモードでSocket処理をしている場合になります。select()やpoll()などのnon-blockingモードの場合に、特に接続時のタイムアウトがどういう挙動になるのかは検証が必要かもしれません。
<br />
</p>
<h4 id="idb94e5f">接続時のタイムアウト</h4>

<p class="paragraph">
JDK 1.4で導入されたSocketのconnect()メソッドでは接続時のタイムアウトミリ秒を指定できます。
<br />
で、実際にどんなケースでタイムアウトになるかというと・・・原理的には、SYNを投げたあとのSYN+ACKが返されない場合なのですが・・・基本的に、ユーザーランドでこの辺を制御するのは非常に難しいと思います。RAW Socket + BPFかDLPI使うともしかしたら可能かもしれませんが。
<br />
ユーザーランドでは難しいのですが、サーバ側でやりたいことは結局のところ SYN が来たら、SYN+ACKを返さないということなので、<strong>iptablesなどのファイアーウォールの仕組みでSYN+ACKを返さないように設定できます。</strong>というか、カーネルモジュールとかBPF/DLPI/Raw Socket使いたくないのであればそれが一番お手軽かと思います。
<br />
次点で、クライアント側の接続タイムアウトのテスト時に、connect()で指定するタイムアウトミリ秒に &quot;1&quot; を指定することだと思います。
<br />
</p>

<p class="paragraph">
例えば今回のサーバサイドの実験環境はCentOS6で、&quot;Minimal Desktop&quot;でインストールした環境ではデフォルトでこんなiptablesが設定されてました。
<br />
/etc/sysconfig/iptables:
<br />
</p>
<pre class="plugin_pre">

# Firewall configuration written by system-config-firewall
# Manual customization of this file is not recommended.
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT

</pre>
<p class="paragraph">
これですと、最後から3行目の
<br />
</p>
<pre>-A INPUT -j REJECT --reject-with icmp-host-prohibited
</pre>
<p class="paragraph">
これにより、デフォルトはREJECTになり、今回の例で動かしているTCPポート番号10007にconnect(2)しても、サーバ側はSYN+ACKを返さなくなります。
<br />
具体的にはWin7ProSP1上でクライアントプログラムを動かしたら、こんな動きになりました。
<br />
</p>
<pre>clinet --&gt; SYN --&gt; server
        (no reply)
3秒後:
clinet --&gt; SYN --&gt; server
        (no reply)
6秒後:
clinet --&gt; SYN --&gt; server
        (no reply)
→clinet側でConnectException or SocketTimeoutException発生
</pre>
<p class="paragraph">
なお、DROPポリシーを使えばRST+ACKを返す、つまりまるでそのポート番号でサービスが動いていないかのように動作する、という説明があるのですが、試しに
<br />
</p>
<pre>-A INPUT -j REJECT --reject-with icmp-host-prohibited
</pre>
<p class="paragraph">
を
<br />
</p>
<pre>-A INPUT -j DROP
</pre>
<p class="paragraph">
にしても、SYNパケットに対して無反応になるだけで同じでした・・・。
<br />
</p>

<p class="paragraph">
SYNパケットの送信間隔やリトライ回数は恐らくOSやkernelの設定に依存すると思いますので、他のプラットフォームで試すとまた異なる結果になるかもしれません。
<br />
</p>

<p class="paragraph">
とりあえず、単体テストでお手軽に「接続タイムアウト」を発生させたければ、サーバ側か途中のNW機器で、incommingのSYNパケットをdropするようなファイアーウォール設定をすればOKっぽいですね。
<br />
</p>

<p class="paragraph">
<strong>10年前に知っときたかったわー（血の涙）</strong>
<br />
</p>

<p class="paragraph">
iptables DROP/REJECT参考：
<br />
</p>
<ul><li> 連載記事 「ゼロから始めるLinuxセキュリティ」<ul><li> <a class="externallink" href="http://www.atmarkit.co.jp/flinux/index/indexfiles/securityindex.html" target="_blank">http://www.atmarkit.co.jp/flinux/index/indexfiles/securityindex.html</a></li></ul></li>
<li> linux - REJECT vs DROP when using iptables - Server Fault<ul><li> <a class="externallink" href="http://serverfault.com/questions/157375/reject-vs-drop-when-using-iptables" target="_blank">http://serverfault.com/questions/157375/reject-vs-drop-when-using-iptables</a></li></ul></li>
<li> Best practices: iptables | major.io<ul><li> <a class="externallink" href="http://major.io/2010/04/12/best-practices-iptables/" target="_blank">http://major.io/2010/04/12/best-practices-iptables/</a></li></ul></li></ul>


<p class="paragraph">
以下余談：
<br />
実は、今回の実験環境(Win7ProSP1)では「到達できないホストにconnect()」しようとしたらSocketTimeoutException例外が発生しました。ので、これをcatchすれば良いのではないか・・・と思ってLinux側でも試してみたのですが、そしたら普通にConnectExceptionになったり、java.net.NoRouteToHostExceptionになったりと、なかなか「このIPアドレスなら確実」というのが見つからなかったのです。
<br />
</p>
<pre class="plugin_pre">
(Win7ProSP1で存在しないホストに接続)
&gt; groovy t_tcp_echo_client_1.groovy 192.168.56.102 10007
connect() start
(10秒後)
Caught: java.net.SocketTimeoutException: connect timed out
java.net.SocketTimeoutException: connect timed out
        at java_net_Socket$connect$0.call(Unknown Source)
        at t_tcp_echo_client_1.run(t_tcp_echo_client_1.groovy:12)
</pre>

<p class="paragraph">
で、少しtry and errorしてみた結果、多分 connect() で1ミリ秒にするのが一番早そうでした。これとても、サーバスペックが異常に良ければ1ミリ秒以内にaccept()されてしまう可能性があるのでなんとも言えないのですが・・・。
<br />
</p>

<p class="paragraph">
もうちょっと調査・検証の余地があるのかもしれません。
<br />
</p>

<p class="paragraph">
あるいは、そもそも java.net.SocketTimeoutException は IOException の派生クラスなので、後述の通りIOExceptionでまるめてcatchして処理していれば、別に、他のConnectExceptionとかでcatchできていても、ロジックを通すだけのテストであれば観点としては問題ないかもしれません。
<br />
</p>

<p class="paragraph">
※ちなみにSE時代、接続時に「タイムアウトした」のか、「タイムアウト以外のエラーが発生した」のか、通信処理の実装で分けて検出する必要があって、どういう条件なら SocketTimeoutException になるのか / SocketTimeoutException以外のIOException になるのかえらい苦労した記憶があります。その時は結局、単体テスト環境下で存在しないホスト名を指定することでなんとかSocketTimeoutExceptionになってくれて、それで単体テスト観点で実施した記憶が。
<br />
</p>

<p class="paragraph">
も～ほんと、今になってiptables使えば一瞬でテストできることに気づいて、一体何時間無駄な時間を過ごしてしまったのかあーもー、ってな感じです。
<br />
（この辺、Raw SocketやBPF/DLPI使わないと駄目かもと思って勉強しようとしては「いやちょっと待て・・・」と引いたりしてずるずるしてたんですが、そっちの方面まで持ち込む必要はなかったっぽくてまぁソレはソレで。）
<br />
</p>

<h4 id="id379db2">listen()してないportにconnect() -&gt; ConnectException</h4>

<p class="paragraph">
ホストには到達したが、接続先のportがlisten()されてない場合は、即座に java.net.ConnectException (IOExceptionの派生) が発生しました。
<br />
</p>
<pre class="plugin_pre">
&gt; groovy t_tcp_echo_client_1.groovy 192.168.56.101 10008
connect() start
Caught: java.net.ConnectException: Connection refused: connect
java.net.ConnectException: Connection refused: connect
        at java_net_Socket$connect$0.call(Unknown Source)
        at t_tcp_echo_client_1.run(t_tcp_echo_client_1.groovy:12)
</pre>

<p class="paragraph">
パケット上は、クライアントからのSYNに対してサーバから即座にRST+ACKが返されれる x 3 回で、ConnectExceptionになりました。
<br />
（他のOSやプラットフォーム上だと異なってくると思います）
<br />
</p>

<p class="paragraph">
ソケットやファイルの操作ではIOExceptionのcatchを多用することになりますが、ConnectExceptionはIOExceeptionの派生なので、そこでcatchできそうです。
<br />
</p>

<h4 id="idd9f644">SocketのsetSoTimeout() -&gt; read()時のタイムアウト</h4>

<p class="paragraph">
今回のサーバサイドのサンプルコードでは、クライアントからのデータを受信して、echoする前に入力待ちになります。ここで10秒以上放置すると、クライアントサイドではread()での java.net.SocketTimeoutException が発生するように調整してます。
<br />
</p>

<h3 id="id11f527">参考資料</h3>

<p class="paragraph">
&quot;UNIX Network Programming&quot; (3rd Edition, Volume 1) : 英語ですが、Socket周りのシステムコールを呼ぶタイミングと、TCPのフローを重ねあわせた図を載せてくれてますので大変分かりやすいです。<strong>会社に一冊！おうちに一冊！</strong>
<br />
</p>
<a href="https://www.amazon.co.jp/dp/0131411551" target="_blank">Amazon | Unix Network Programming, Volume 1: The Sockets Networking API (Addison-Wesley Professional Computing Series) | Stevens, W. Richard Fenner, Bill Rudoff, Andrew M. | Software Development</a><br>
<p class="paragraph">
Kindle版はまだ無いようですが、ハードカバーで1000P近くありますので、面白そうなchapter/sectionをパラパラめくってあっちこっちのページを行ったり来たりしたい、今回の記事作成のようなシーンでは、紙媒体のほうが読んでて楽しかったですね。
<br />
</p>

<p class="paragraph">
JVMのスレッドは、Linuxのスレッドとどう対応するのか？参考：
<br />
</p>
<ul><li> How does JVM map a Java thread to a native thread?<ul><li> <a class="externallink" href="http://blog.narmnevis.com/2010/11/how-does-jvm-map-a-java-thread-to-a-native-thread/" target="_blank">http://blog.narmnevis.com/2010/11/how-does-jvm-map-a-java-thread-to-a-native-thread/</a><ul><li> 一番まとまりが良い。</li></ul></li></ul></li>
<li> <a class="externallink" href="http://ja.wikipedia.org/wiki/Native_POSIX_Thread_Library" target="_blank">http://ja.wikipedia.org/wiki/Native_POSIX_Thread_Library</a><ul><li> Linux Kernel 2.6 系ではNPTL(Native POSIX Thread Library)が使われている。</li></ul></li>
<li> linux - Distinguish Java threads and OS threads? - Stack Overflow<ul><li> <a class="externallink" href="http://stackoverflow.com/questions/1888160/distinguish-java-threads-and-os-threads" target="_blank">http://stackoverflow.com/questions/1888160/distinguish-java-threads-and-os-threads</a></li></ul></li>
<li> One to one mapping of Java Thread to Linux thread (LWP) - Stack Overflow<ul><li> <a class="externallink" href="http://stackoverflow.com/questions/17125101/one-to-one-mapping-of-java-thread-to-linux-thread-lwp" target="_blank">http://stackoverflow.com/questions/17125101/one-to-one-mapping-of-java-thread-to-linux-thread-lwp</a></li></ul></li>
<li> コラム: ネイティブスレッドとJavaスレッドのマッピング<ul><li> <a class="externallink" href="https://www.acroquest.co.jp/webworkshop/JavaTroubleshooting/column_004Main.html" target="_blank">https://www.acroquest.co.jp/webworkshop/JavaTroubleshooting/column_004Main.html</a><ul><li> LinuxではなくてSolarisでの話となっている。</li></ul></li></ul></li>
<li> Java Obsession: Figure out why is JAVA eating CPU?<ul><li> <a class="externallink" href="http://javadrama.blogspot.co.uk/2012/02/why-is-java-eating-my-cpu.html" target="_blank">http://javadrama.blogspot.co.uk/2012/02/why-is-java-eating-my-cpu.html</a><ul><li> psコマンドの結果から、CPU負荷の高いJavaのスレッドを突き止めるサンプル</li></ul></li></ul></li>
<li> スレッドIDを取得する - 揮発性のメモ<ul><li> <a class="externallink" href="http://d.hatena.ne.jp/iww/20101217/p1" target="_blank">http://d.hatena.ne.jp/iww/20101217/p1</a><ul><li> gettid(2)の使い方と、psコマンドでLWP関連情報の表示オプションの紹介 (&quot;ps -L aux&quot;)</li></ul></li></ul></li>
<li> Linux スレッドプログラミング<ul><li> <a class="externallink" href="http://www.tsoftware.jp/nptl/" target="_blank">http://www.tsoftware.jp/nptl/</a></li></ul></li>
<li> jstack関連<ul><li> <a class="externallink" href="http://docs.oracle.com/javase/jp/6/technotes/tools/share/jstack.html" target="_blank">http://docs.oracle.com/javase/jp/6/technotes/tools/share/jstack.html</a></li>
<li> <a class="externallink" href="http://aoking.hatenablog.jp/entry/20120629/1340965676" target="_blank">http://aoking.hatenablog.jp/entry/20120629/1340965676</a></li></ul></li></ul>


<p class="paragraph">
JVMでLinuxのNative Thread IDを取得してstraceするには：
<br />
</p>
<ul><li> <a class="externallink" href="https://gist.github.com/msakamoto-sf/9014695" target="_blank">https://gist.github.com/msakamoto-sf/9014695</a><ul><li> JavaからJNA(Java Native Access)でglibcのsyscall(2)にアクセスし、gettid()を使う。</li></ul></li></ul>

<p class="paragraph">
JNA(Java Native Access)参考：
<br />
</p>
<ul><li> twall/jna<ul><li> <a class="externallink" href="https://github.com/twall/jna" target="_blank">https://github.com/twall/jna</a></li></ul></li>
<li> linux - Invoke Syscalls from Java - Unix &amp; Linux Stack Exchange<ul><li> <a class="externallink" href="http://unix.stackexchange.com/questions/1681/invoke-syscalls-from-java" target="_blank">http://unix.stackexchange.com/questions/1681/invoke-syscalls-from-java</a><ul><li> JNAを使ってJavaからsyscall(2)を呼ぶサンプル</li></ul></li></ul></li>
<li> JNIより簡単にJavaとC/C++をつなぐ「JNA」とは（2/4）－＠IT<ul><li> <a class="externallink" href="http://www.atmarkit.co.jp/fjava/special/jna/jna_2.html" target="_blank">http://www.atmarkit.co.jp/fjava/special/jna/jna_2.html</a></li></ul></li></ul>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-1421.html" title="技術/Security/testssl.sh">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-1371.html" title="技術/Socketプログラミング/Wiresharkの使い方メモ">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-23.html" title="技術">技術</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/1268<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2007 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>