<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>C言語系/「デーモン君のソース探検」読書メモ/12, script(1) - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">C言語系/「デーモン君のソース探検」読書メモ/12, script(1)</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-01-28 13:44:32 &nbsp; / &nbsp; last updated at: 2010-01-29 10:01:45<br>
カテゴリ: <a href="category-32.html">BSD</a>&nbsp;<a href="category-10.html">C言語</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-555.html" title="C言語系/「デーモン君のソース探検」読書メモ/11, file(1)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-566.html" title="C言語系/「デーモン君のソース探検」読書メモ/13, man(1)とnroff(1)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
お題：&quot;script(1)&quot;コマンドの仕組みを追跡せよ
<br />
</p>

<p class="paragraph">
※最初に種を明かすと、仮想端末の説明は &quot;APUE: Advanced Programming in the UNIX Environment&quot; に依っています。またAPUEにはscriptコマンドの概要も図入りで載っていたりします。
<br />
</p>




<h3 id="idc2cfe2">実行ファイルとソースファイルの位置</h3>

<p class="paragraph">
実行ファイルとソースファイルの位置：
<br />
</p>
<pre>$ which script
/usr/bin/script
$ cd /usr/src/usr.bin/script/
$ ls
CVS/      Makefile  script.1  script.c
</pre>

<p class="paragraph">
Makefileもシンプル。libutil.soをリンクしている。
<br />
</p>
<pre class="plugin_pre">
#       $NetBSD: Makefile,v 1.3 1994/12/21 08:55:39 jtc Exp $
#       @(#)Makefile    8.1 (Berkeley) 6/6/93

PROG=   script
LDADD=  -lutil
DPADD=  ${LIBUTIL}

.include &lt;bsd.prog.mk&gt;
</pre>

<p class="paragraph">
ここで &quot;man 3 util&quot; してみると、libutilに収録されているシステムユーティリティ用の関数の一覧が表示される。
<br />
「こんな関数があったんだ～」という感じ。知らないと損かも。
<br />
</p>

<p class="paragraph">
今回のターゲットである script.c に話を戻すと、行数も248行とコンパクトにまとまっている。
<br />
</p>
<pre>$ wc -l script.c
     248 script.c
</pre>

<p class="paragraph">
NetBSD1.6でのscriptコマンドの動作をおさらいしておく。
<br />
</p>
<pre>script [-a] [file]
</pre>
<p class="paragraph">
最新のBSDやLinuxでは、他にも幾つかのオプションが使えるようになっている。
<br />
NetBSD1.6の段階では、&quot;-a&quot;によるファイル追記モードと、file名指定による保存先ファイル名の２つしかオプションが用意されていない。
<br />
fileが指定されない場合は&quot;typescript&quot;というファイル名に保存される。
<br />
</p>

<p class="paragraph">
「デーモン君のソース探検」では早速script.cの解析に入っていくが、今回の読書メモでは先に仮想端末についてまとめてしまう。本の方でも、一旦script.cの解析で手詰まりになり、仮想端末の解説が入った後、不明点を解消していく流れになっている。
<br />
</p>

<h3 id="id411c90">仮想端末</h3>

<p class="paragraph">
仮想端末については &quot;man 4 pty&quot; で調べることができる。
<br />
ただしBSD系列の仮想端末と、SUSv2(Unix98)の仮想端末とではデバイスファイル名などの仕様が異なっている点に注意が必要。
<br />
</p>

<p class="paragraph">
参考として、JManからの仮想端末関連manページを2点、また仮想端末のWikipediaへのリンクを載せる。
<br />
</p>
<ul><li> Manpage of PTY (疑似端末インタフェース)<ul><li> <a class="externallink" href="http://www.linux.or.jp/JM/html/LDP_man-pages/man7/pty.7.html" target="_blank">http://www.linux.or.jp/JM/html/LDP_man-pages/man7/pty.7.html</a></li></ul></li>
<li> Manpage of PTS (擬似端末のマスタとスレーブ)<ul><li> <a class="externallink" href="http://www.linux.or.jp/JM/html/LDP_man-pages/man4/pts.4.html" target="_blank">http://www.linux.or.jp/JM/html/LDP_man-pages/man4/pts.4.html</a></li></ul></li>
<li> Pseudo terminal - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Pseudo_terminal" target="_blank">http://en.wikipedia.org/wiki/Pseudo_terminal</a></li></ul></li>
<li> tty (Unix) - Wikipedia, the free encyclopedia<ul><li> <a class="externallink" href="http://en.wikipedia.org/wiki/Tty_%28Unix%29" target="_blank">http://en.wikipedia.org/wiki/Tty_%28Unix%29</a></li></ul></li></ul>

<p class="paragraph">
仮想端末は、物理的な端末の入出力を任意のプログラム(ソフトウェア)で代替・エミュレーション出来るようにする仕組みである。
<br />
以下の図は典型的な構成例で、APUEから拝借して枠内のテキストだけ若干調整した。
<br />
</p>
<pre class="plugin_pre">
+------------------+     fork    +------------------+
| user process (1) |------------&gt;| user process (2) |
+------------------+     exec    +------------------+
         ^                                  ^ stdin, stdout, stderr
         |                                  |
---------|----------------------------------|-----------------
         |                                  |     kernel world
         v                                  v
+------------------+               +------------------+
| read(2)/write(2) |               | read(2)/write(2) |
+------------------+               +------------------+
        | ^                                | ^
        | |                                | |
        | |                                v |
        | |                        +-----------------+
        | |                        |     terminal    |
        | |                        | line descipline |
        | |                        +-----------------+
        | |                                | ^
        | |                                | |
        v |                                v |
+-----------------+                +-----------------+
| pseudo-terminal |---------------&gt;| pseudo-terminal |
|    MASTER       |&lt;---------------|    SLAVE        |
+-----------------+                +-----------------+
</pre>
<p class="paragraph">
&quot;user process (1)&quot;が、端末の入出力をエミュレーションするプログラムに相当する。telnetやsshなど、ネットワーク経由でのターミナル入出力を制御するのがこれに相当する。&quot;user process (2)&quot;がエミュレーション環境で動く、実際にユーザが操作するプログラムに相当する。大抵はシェルが動作することになると思われる。
<br />
&quot;terminal line descipline&quot;というのはcanonicalモード用のモジュール。canonicalモードというのは、入出力を行単位でまとめて処理するモードを指す。non-canonicalモードは行単位でまとめずそのまま処理するモードを指す。
<br />
&quot;pseudo-terminal {MASTER|SLAVE}&quot;が仮想端末の中心であり、２つに分割されている。ファイルシステム上はデバイスファイルで操作できるようになっている。
<br />
</p>

<p class="paragraph">
仮想端末の仕組みをややこしくしているのは以下の3点であると思われる。
<br />
</p>
<ol><li> MASTER/SLAVEのデバイスファイル名が、BSD系列とUnix98系列で異なる命名ルールになっている。</li>
<li> デバイスファイルを単純に操作(open/read/write/close/dup)するだけでは仮想端末の仕組みを利用出来ない。</li>
<li> MASTER/SLAVEのデバイスファイルを処理する関数名や手順が、BSD系列とUnix98系列で異なる。</li></ol>

<p class="paragraph">
まずMASTER/SLAVEのファイル名の命名ルールについて見てみる。
<br />
BSD系列：(NetBSD1.6のmanページより, なお若干Wikipediaの記述とズレがある。)
<br />
</p>
<pre>/dev/pty[p-zP-T][0-9a-zA-Z]   master pseudo terminals
/dev/tty[p-zP-T][0-9a-zA-Z]   slave pseudo terminals
</pre>
<p class="paragraph">
Unix98系列：(Linux JManのpty(7)より)
<br />
</p>
<pre>/dev/ptmx (Unix 98 マスタ・クローン・デバイス) 
/dev/pts/* (Unix 98 スレーブデバイス) 
</pre>
<p class="paragraph">
Unix98系列の場合、&quot;/dev/ptmx&quot;をMASTERデバイスとして開くと、自動的に対応する &quot;/dev/pts/(自動連番)&quot; ノードが生成されるようになっている。
<br />
命名ルールが異なるというものの、実際に仮想端末を処理する場合はデバイスファイル名を意識する必要は無い。ライブラリ関数が用意されており、適切なデバイスファイルを自動的に選択してくれるようになっている。BSD系列であれば &quot;openpty(3)&quot;, Unix98系列であれば &quot;posix_openpt(3)&quot; がこれに相当する。
<br />
</p>

<p class="paragraph">
続いてMASTER/SLAVEデバイスファイルの操作について見てみる。
<br />
デバイスファイルを通常のシステムコールで操作しようとしても仮想端末として利用することは出来ない。MASTER/SLAVEをペアで操作して始めて１セットの仮想端末となるため、前述のように専用のライブラリ関数が用意されておりそれを使うことになる。
<br />
ところがBSD系列とUnix98系列で関数名や呼び出すお作法が異なってしまっている。
<br />
BSD系列：
<br />
</p>
<pre>openpty(3)/login_tty(3)/forkpty(3)
</pre>
<p class="paragraph">
Unix98系列：
<br />
</p>
<pre>posix_openpt(3)/grantpt(3)/unlockpt(3)/ptsname(3)
</pre>
<p class="paragraph">
これらの詳細までは今回は踏み込まない。
<br />
</p>

<p class="paragraph">
今回の読書メモとしては、仮想端末のまとめをここで一区切りとする。ここまでの知識をベースにすると、script.cも大分読みやすくなる。
<br />
</p>
<h3 id="id27ef73">script.c</h3>

<p class="paragraph">
ではscript.cの探検を始める。まずはグローバル変数の宣言部：解説は各行末コメント参照。
<br />
</p>
<pre class="plugin_pre">
FILE    *fscript;          /* 保存先ファイルのFILE構造体ポインタ */
int     master, slave;     /* openpty(3)で取得されるMASTER/SLAVEのファイル記述子 */
int     child, subchild;   /* main()内でのfork(2)したプロセスID保存先 */
int     outcc;             /* バッファフラッシュ判定用出力バイト数 */
char    *fname;            /* 保存先ファイル名 */

struct  termios tt;        /* scriptコマンド実行側端末情報 */
</pre>
<p class="paragraph">
各変数の使われ方は、追々出てくるソースコードを参照。
<br />
</p>

<h4 id="id5a447c">main()関数</h4>

<p class="paragraph">
main関数を見てみる。まず冒頭はローカル変数の宣言、オプションの解析、保存用のファイルをオープンしている。&quot;-a&quot;オプションに応じてfopen(3)の引数を調整している。保存先ファイルのFILE構造体ポインタはグローバル変数のfscriptに保存される。ファイル名は同様にfnameに保存される。
<br />
</p>
<pre class="plugin_pre">
int
main(argc, argv)
  int argc;
  char *argv[];
{
  int cc;
  struct termios rtt;
  struct winsize win;
  int aflg, ch;
  char ibuf[BUFSIZ];

  aflg = 0;
  while ((ch = getopt(argc, argv, &quot;a&quot;)) != -1)
    switch(ch) {
    case &#039;a&#039;:
      aflg = 1;
      break;
    case &#039;?&#039;:
    default:
      (void)fprintf(stderr, &quot;usage: script [-a] [file]\n&quot;);
      exit(1);
    }
  argc -= optind;
  argv += optind;

  if (argc &gt; 0)
    fname = argv[0];
  else
    fname = &quot;typescript&quot;;

  if ((fscript = fopen(fname, aflg ? &quot;a&quot; : &quot;w&quot;)) == NULL)
    err(1, &quot;fopen %s&quot;, fname);
</pre>

<p class="paragraph">
続いて現在の端末情報とウインドウサイズを取得し、openpty(3)を呼び出している。slave側には現在の端末情報とウインドウサイズがコピーされる。
<br />
</p>
<pre class="plugin_pre">
  (void)tcgetattr(STDIN_FILENO, &amp;tt);
  (void)ioctl(STDIN_FILENO, TIOCGWINSZ, &amp;win);
  if (openpty(&amp;master, &amp;slave, NULL, &amp;tt, &amp;win) == -1)
    err(1, &quot;openpty&quot;);
</pre>
<p class="paragraph">
この時点でmaster, slaveには仮想端末用のファイル記述子がセットされている。
<br />
</p>

<p class="paragraph">
続いてcfmakeraw(3)により端末の入出力処理をスキップさせ、さらに端末へのECHOを無効化する。もちろんscriptコマンド終了後に戻すので、この処理は上で取得したtermiosのコピーに対して行われる。
<br />
</p>
<pre>(void)printf(&quot;Script started, output file is %s\n&quot;, fname);
rtt = tt;
cfmakeraw(&amp;rtt);
rtt.c_lflag &amp;= ~ECHO;
(void)tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;rtt);
</pre>

<p class="paragraph">
いよいよfork(2)で子プロセスを生成する。
<br />
</p>
<pre> (void)signal(SIGCHLD, finish);
 child = fork();
 if (child &lt; 0) {
   warn(&quot;fork&quot;);
   fail();
 }
 if (child == 0) {
   subchild = child = fork();
   if (child &lt; 0) {
     warn(&quot;fork&quot;);
     fail();
   }
   if (child)
     dooutput();
   else
     doshell();
 }
</pre>
<p class="paragraph">
ここで、fork(2)が2回呼ばれている点がポイントとなる。main関数を最後まで見終わった後に、2段fork(2)について詳しく見てみる。
<br />
</p>

<p class="paragraph">
script自体のプロセスは、保存先ファイルへのFILE構造体ポインタは閉じてしまい、以降はscript自体のプロセスが動作する端末への入力をそのままmaster側へ出力する、ブリッジ動作になる。
<br />
</p>
<pre> (void)fclose(fscript);
 while ((cc = read(STDIN_FILENO, ibuf, BUFSIZ)) &gt; 0)
   (void)write(master, ibuf, cc);
 done();
 /* NOTREACHED */
 return (0);
}
</pre>

<p class="paragraph">
ここまでの流れをまとめると以下の図のようになる。script側のプロセスでは保存先ファイルへの書き込みが一切行われていない。ということは、doshell()またはdooutput()側で書き込み処理が実装されていると予想される。
<br />
また、まだこの時点ではforkされたプロセスはslave側とは結びついていない。
<br />
</p>
<pre class="plugin_pre">
+--------+   fork(2)   +-----------+   fork(2)   +-----------+
| script |------------&gt;| (child-0) |------------&gt;| (child-1) |
+--------+             +-----------+             +-----------+
    |                        |                         |
    |                        |                         |
    v                        v                         v
  while()               dooutput()                  doshell()
   /  |
  ^   |
  |   |
  |   |   input +--------+      +-------+
  |   +--------&gt;| MASTER |&lt;----&gt;| SLAVE |
STDIN           +--------+      +-------+
</pre>

<h4 id="ida0e937">doshell()関数</h4>

<p class="paragraph">
doshell()という名前から、いかにもシェルをexec(2)するような関数に見える。先にdoshell()を見てみる。
<br />
</p>
<pre class="plugin_pre">
void
doshell()
{
  char *shell;

  /* 環境変数からシェルの実行ファイル名を取得 */
  shell = getenv(&quot;SHELL&quot;);
  if (shell == NULL)
    shell = _PATH_BSHELL;

  /* 使わないmaster側のファイル記述子をクローズ */
  (void)close(master);
  /* 使わないscript保存先ファイルポインタをクローズ */
  (void)fclose(fscript);
  /* slaveを現在プロセスの制御端末に設定し、諸々準備 */
  login_tty(slave);
  /* シェルの実行 */
  execl(shell, shell, &quot;-i&quot;, NULL);
  warn(&quot;execl %s&quot;, shell);
  fail();
}
</pre>
<p class="paragraph">
これによりシェルプロセスにslaveが結びつき、前掲の図は次のように変化する。
<br />
</p>
<pre class="plugin_pre">
+--------+   fork(2)   +-----------+   fork(2)   +-----------+
| script |------------&gt;| (child-0) |------------&gt;| (child-1) |
+--------+             +-----------+             |     v     |
    |                        |                   | doshell() |
    |                        |                   |     v     |
    v                        v                   |   SHELL   |
  while()                dooutput()              +-----------+
   /  |                                           ^
  ^   |                                           |
  |   |                                           v
  |   |   input +--------+                    +-------+
  |   +--------&gt;| MASTER |&lt;------------------&gt;| SLAVE |
STDIN           +--------+                    +-------+
</pre>

<h4 id="idb295fb">dooutput()関数</h4>

<p class="paragraph">
続いてdooutput()を見てみると、ようやく入出力をファイルに保存している処理が見つかった。
<br />
</p>
<pre class="plugin_pre">
void
dooutput()
{
  struct itimerval value;
  int cc;
  time_t tvec;
  char obuf[BUFSIZ];

  /* 使わなくなったSTDINをクローズ */
  (void)close(STDIN_FILENO);
  tvec = time(NULL);
  (void)fprintf(fscript, &quot;Script started on %s&quot;, ctime(&amp;tvec));

  /* 定期的にバッファをフラッシュするための準備 */
  (void)signal(SIGALRM, scriptflush);
  value.it_interval.tv_sec = SECSPERMIN / 2;
  value.it_interval.tv_usec = 0;
  value.it_value = value.it_interval;
  (void)setitimer(ITIMER_REAL, &amp;value, NULL);

  /* masterデバイスからの出力を・・・ */
  for (;;) {
    cc = read(master, obuf, sizeof (obuf));
    if (cc &lt;= 0)
      break;
    /* 標準出力へコピー */
    (void)write(1, obuf, cc);
    /* ファイルに保存 */
    (void)fwrite(obuf, 1, cc, fscript);
    outcc += cc;
  }
  done();
}
</pre>
<p class="paragraph">
これでようやく、前掲の図が完成する。
<br />
</p>
<pre class="plugin_pre">
+--------+   fork(2)   +-----------+   fork(2)   +-----------+
| script |------------&gt;| (child-0) |------------&gt;| (child-1) |
+--------+             |     v     |             |     v     |
    |                  | dooutput()|             | doshell() |
    |                  +-----------+             |     v     |
    v                    ^    v                  |   SHELL   |
  while()                |    +--&gt; FILE          +-----------+
   /  |                  |    +--&gt; STDOUT         ^
  ^   |                  ^                        |
  |   |                  |output                  v
  |   |       input +--------+                 +-------+
  |   +------------&gt;| MASTER |&lt;---------------&gt;| SLAVE |
STDIN               +--------+                 +-------+
</pre>
<p class="paragraph">
ところで、MASTER/SLAVE周辺のIOを見てみると次のようになっている。
<br />
</p>
<pre class="plugin_pre">
                +--------+   STDIN   +-------+
STDIN --&gt;...---&gt;|-&gt;----&gt;-|----------&gt;|       |
                | MASTER |           | SLAVE |
STDOUT&lt;-+------&lt;|-&lt;----&lt;-|&lt;----------|       |
FILE&lt;---+       +--------+   STDOUT  +-------+
</pre>
<p class="paragraph">
MASTERに対するSTDINが、FILE側に保存されるのは何でだろう・・・って思ったんですよ。一瞬。
<br />
でもよくよく考えたら、SLAVE側で動作するシェルや端末情報ってデフォルトならECHO有り、つまり標準入力から読み込んだ文字が標準出力側にも出力される設定なので、結局STDOUTに戻ってくるわけです。なのでMASTER側から読み出してFILEに保存出来る仕掛けになってるみたいですね。
<br />
特殊な仕掛けも使ってない素直な流れなのですが、これのお陰でgetpass(3)を使ったり端末情報でECHOを落とした場合、ちゃんとFILEには隠したい入力が保存されない仕掛けになるわけです。script(1)で、パスワード入力を伴うプログラムを実行しても問題ないのはこういう仕組みになっているわけですね。
<br />
</p>

<hr />

<p class="paragraph">
最後にグローバル変数、outccとsubchildの使われどころを見てみる。
<br />
</p>

<p class="paragraph">
outccはdooutput()の中でカウントアップされ、scriptflush()の中でリセットされている。
<br />
</p>
<pre class="plugin_pre">
void
dooutput()
{
  /* ... */
  for (;;) {
    cc = read(master, obuf, sizeof (obuf));
    if (cc &lt;= 0)
      break;
    (void)write(1, obuf, cc);
    (void)fwrite(obuf, 1, cc, fscript);
    outcc += cc;
  }
  done();
}

void
scriptflush(signo)
  int signo;
{
  if (outcc) {
    void)fflush(fscript);
    outcc = 0;
  }
}
</pre>
<p class="paragraph">
dooutput()ではfor()ループに入る前に、定期的にscriptflushを呼ぶように調整している。もし最後にscriptflush()されてから入力があれば(=outcc &gt; 0)、fflush()によるバッファをフラッシュするようになっている。
<br />
</p>

<p class="paragraph">
subchildについてはdone()の中で使われている。
<br />
done()関数はmain()関数のプロセスと、dooutput()関数のプロセスで呼ばれる。dooutput()関数のプロセスまでsubchildグローバル変数は引き継がれている点に注意すれば、done()の内容も特に難しい所は無い。
<br />
</p>
<pre class="plugin_pre">
void
done()
{
  time_t tvec;

  if (subchild) {
    /* dooutput()関数のプロセス終了処理 */
    tvec = time(NULL);
    (void)fprintf(fscript,&quot;\nScript done on %s&quot;, ctime(&amp;tvec));
    /* 保存先ファイルポインタをclose */
    (void)fclose(fscript);
    /* 仮想端末のMASTER側をclose(SLAVE側はdoshell()の方でlogin_tty()内でclose) */
    (void)close(master);
  } else {
    /* main()関数のプロセス終了処理 */
    /* ECHOフラグを落としていた端末設定をバックアップから復元する */
    (void)tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;tt);
    (void)printf(&quot;Script done, output file is %s\n&quot;, fname);
  }
  exit(0);
}
</pre>

<p class="paragraph">
以上でscript(1)コマンドの仕組みが一通り解明出来た。なお、以下の疑問点については「デーモン君のソース探検」に書かれている為そちらを参照のこと。
<br />
</p>
<ul><li> なぜ2回もforkする必要があるのか？</li>
<li> パイプを使わない理由は？</li></ul>

<p class="paragraph">
今回のお題については、ここまで。
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-555.html" title="C言語系/「デーモン君のソース探検」読書メモ/11, file(1)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-566.html" title="C言語系/「デーモン君のソース探検」読書メモ/13, man(1)とnroff(1)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-546.html" title="C言語系/「デーモン君のソース探検」読書メモ">Up</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/563<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2001 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" target="_blank" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>