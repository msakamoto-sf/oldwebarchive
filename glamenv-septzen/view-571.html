<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>C言語系/「デーモン君のソース探検」読書メモ/16, malloc(3) - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">C言語系/「デーモン君のソース探検」読書メモ/16, malloc(3)</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-02-01 16:19:28 &nbsp; / &nbsp; last updated at: 2010-02-02 19:59:36<br>
カテゴリ: <a href="category-32.html">BSD</a>&nbsp;<a href="category-10.html">C言語</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-568.html" title="C言語系/「デーモン君のソース探検」読書メモ/15, mktemp(3),mkstemp(3)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-573.html" title="C言語系/「デーモン君のソース探検」読書メモ/A01, touch(1)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
お題：malloc(3)で確保したメモリをfree(3)するときに、なぜメモリサイズを渡す必要がないのか調査せよ
<br />
</p>



<ul><li><a href="#id5ee7df">malloc(3)とページサイズ取得、関係値の算出</a></li>
<li><a href="#id989826">pageround()マクロとptr2idx()マクロ</a></li>
<li><a href="#id2eb5bf">malloc_pages()：ページサイズの半分を越える領域の確保</a><ul><li><a href="#idf19167">ifree() → free_pages()による解放処理</a></li></ul></li>
<li><a href="#idfaebfc">malloc_bytes() : ページサイズの半分以下の領域確保</a><ul><li><a href="#id485b5e">malloc_make_chunks()の流れ</a></li></ul></li></ul>
<hr />

<h3 id="id5ee7df">malloc(3)とページサイズ取得、関係値の算出</h3>

<pre>$ locate malloc.c
...
/usr/src/lib/libc/stdlib/malloc.c
...
</pre>

<p class="paragraph">
malloc(3)のソースから主要部分を抜き書きすると、下のようになる。
<br />
</p>
<pre class="plugin_pre">
void *
malloc(size_t size)
{
    /* ... */
    if (!malloc_started)
        malloc_init();
    if (malloc_sysv &amp;&amp; !size)
        r = 0;
    else
        r = imalloc(size);
    /* ... */
    return (r);
}
</pre>
<p class="paragraph">
通常であればmalloc_init()の後にimalloc()を呼んでいる。imalloc()の主要コードを見てみる。
<br />
</p>
<pre class="plugin_pre">
/*
 * Allocate a piece of memory
 */
static void *
imalloc(size_t size)
{
    void *result;
    /* ... */
    if ((size + malloc_pagesize) &lt; size)        /* Check for overflow */
        result = 0;
    else if (size &lt;= malloc_maxsize)
        result =  malloc_bytes(size);
    else
        result =  malloc_pages(size);
    /* ... */
    return result;
}
</pre>
<p class="paragraph">
malloc_maxsizeを以下の場合はmalloc_bytes(), 越える場合はmalloc_pages()を呼んでいる。
<br />
malloc_maxsizeの定義を調べてみる。
<br />
</p>
<pre>#ifndef malloc_maxsize
#define malloc_maxsize   ((malloc_pagesize)&gt;&gt;1)
#endif
</pre>
<p class="paragraph">
malloc_pagesizeの半分になっている。malloc_pagesizeの定義を調べてみる。
<br />
</p>
<pre>/*
 * Page size related parameters, computed at run-time.
 */
static size_t malloc_pagesize;
static size_t malloc_pageshift;
static size_t malloc_pagemask;
</pre>
<p class="paragraph">
ファイル内グローバル変数になっている。値を初期化しているのは、malloc_init()中の以下のコードになっている。
<br />
</p>
<pre>   /*
    * Compute page-size related variables.
    */
   malloc_pagesize = (size_t)sysconf(_SC_PAGESIZE);
   malloc_pagemask = malloc_pagesize - 1;
   for (malloc_pageshift = 0;
        (1UL &lt;&lt; malloc_pageshift) != malloc_pagesize;
        malloc_pageshift++)
       /* nothing */ ;
</pre>
<p class="paragraph">
この箇所を切り出して動かしてみる。
<br />
test1.c:
<br />
</p>
<div class="hl-main"><pre><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdio.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">unistd.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
 
</span><span >static</span><span class="hl-code"> </span><span class="hl-identifier">size_t</span><span class="hl-code"> </span><span class="hl-identifier">malloc_pagesize</span><span class="hl-code">;
</span><span >static</span><span class="hl-code"> </span><span class="hl-identifier">size_t</span><span class="hl-code"> </span><span class="hl-identifier">malloc_pageshift</span><span class="hl-code">;
</span><span >static</span><span class="hl-code"> </span><span class="hl-identifier">size_t</span><span class="hl-code"> </span><span class="hl-identifier">malloc_pagemask</span><span class="hl-code">;
 
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">argc</span><span class="hl-code">, </span><span >char</span><span class="hl-code"> *</span><span class="hl-identifier">argv</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
 
  </span><span class="hl-identifier">malloc_pagesize</span><span class="hl-code"> = </span><span class="hl-brackets">(</span><span class="hl-identifier">size_t</span><span class="hl-brackets">)</span><span class="hl-identifier">sysconf</span><span class="hl-brackets">(</span><span class="hl-identifier">_SC_PAGESIZE</span><span class="hl-brackets">)</span><span class="hl-code">;
  </span><span class="hl-identifier">malloc_pagemask</span><span class="hl-code"> = </span><span class="hl-identifier">malloc_pagesize</span><span class="hl-code"> - </span><span class="hl-number">1</span><span class="hl-code">;
  </span><span class="hl-reserved">for</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">malloc_pageshift</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">;
    </span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-identifier">UL</span><span class="hl-code"> &lt;&lt; </span><span class="hl-identifier">malloc_pageshift</span><span class="hl-brackets">)</span><span class="hl-code"> != </span><span class="hl-identifier">malloc_pagesize</span><span class="hl-code">;
    </span><span class="hl-identifier">malloc_pageshift</span><span class="hl-code">++</span><span class="hl-brackets">)</span><span class="hl-code">
    </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> nothing </span><span class="hl-mlcomment">*/</span><span class="hl-code"> ;
 
  </span><span class="hl-identifier">printf</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">malloc_pagesize = %d</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">malloc_pagesize</span><span class="hl-brackets">)</span><span class="hl-code">;
  </span><span class="hl-identifier">printf</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">malloc_pageshift = %d</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">malloc_pageshift</span><span class="hl-brackets">)</span><span class="hl-code">;
  </span><span class="hl-identifier">printf</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">malloc_pagemask = %d</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">malloc_pagemask</span><span class="hl-brackets">)</span><span class="hl-code">;
 
  </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">0</span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>
<pre>$ cc -Wall -o test1 test1.c
$ ./test1
malloc_pagesize = 4096
malloc_pageshift = 12
malloc_pagemask = 4095
</pre>
<p class="paragraph">
malloc_pagesizeは4096バイトで、&quot;/sbin/sysctl -n hw.pagesize&quot;からも取得出来る。malloc_pageshiftについてはビットシフトさせるときの桁数として頻出している。malloc_pagemaskについては-1されているので、丁度 &quot;malloc_pageshift - 1&quot; 桁分が全て1となり、名前の通りbitmaskとして使われている。2進数で表せば次のようになる。
<br />
</p>
<pre>malloc_pagesize = 100...0 (12桁) = 4096
malloc_pagemask =  11...1 (11桁) = 4095
</pre>
<p class="paragraph">
malloc_maxsizeに戻れば、今回の環境では2048となる。imalloc()まで戻ると、次のように場合分けされる。
<br />
</p>
<pre>要求サイズが2048バイト以下：malloc_bytes()
要求サイズが2048バイトを越える：malloc_pages()
</pre>

<h3 id="id989826">pageround()マクロとptr2idx()マクロ</h3>

<p class="paragraph">
「デーモン君のソース探検」ではこの後malloc_pages()の探索に進む。今回の読書メモでも同様に進めてみるが、準備としてmalloc_pages()で使われている２つのマクロについて先に確認しておく。
<br />
</p>
<pre>#define pageround(foo) (((foo) + (malloc_pagemask))&amp;(~(malloc_pagemask)))
#define ptr2idx(foo) \
    (((size_t)(uintptr_t)(foo) &gt;&gt; malloc_pageshift)-malloc_origo)
</pre>

<p class="paragraph">
pageround()はpagesizeの倍数に丸める為のマクロになっている。たとえばfooが4098とすれば、
<br />
</p>
<pre>  100...10
+  11...11
----------
 1000...01 = (foo) + (malloc_pagemask)
&amp;1100...00 = &amp;(~(malloc_pagemask))
----------
 1000...00 = 8192
</pre>
<p class="paragraph">
と言う具合に、一旦malloc_pagemask分加算して端数が落ちないように底上げした後、malloc_pagemaskの反転bitでANDを取れば綺麗に4096の倍数に丸められる。
<br />
</p>

<p class="paragraph">
ptr2idx()は、アドレスからページ管理の為のインデックスに変換するマクロになっている・・・らしい。データ構造がまだこの時点では明らかになっていないため、断言出来ない。ptr2idxで使われているmalloc_origoについては、malloc_init()中の以下のコードで初期化されている。
<br />
</p>
<pre class="plugin_pre">
/* Allocate one page for the page directory */
page_dir = (struct pginfo **) MMAP(malloc_pagesize);

if (page_dir == (struct pginfo **) -1)
    wrterror(&quot;mmap(2) failed, check limits.\n&quot;);

/*
 * We need a maximum of malloc_pageshift buckets, steal these from the
 * front of the page_directory;
 */
malloc_origo = pageround((size_t)(uintptr_t)sbrk((intptr_t)0))
    &gt;&gt; malloc_pageshift;
malloc_origo -= malloc_pageshift;

malloc_ninfo = malloc_pagesize / sizeof *page_dir;
</pre>
<p class="paragraph">
まずMMAPはmalloc.c内のマクロ定義で次のようなmmap(2)のラッパーになっている。
<br />
</p>
<pre class="plugin_pre">
#ifndef MMAP_FD
#define MMAP_FD (-1)
#endif

/* ... */

/* Macro for mmap */
#define MMAP(size) \
        mmap(0, (size), PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, \
            MMAP_FD, (off_t)0);
</pre>
<p class="paragraph">
MAP_ANON + ファイル記述子が-1の場合、特にファイルとは結びつかずにメモリ領域が確保される。APUEのChapter14, Fig14.32を見る限りでは、mmap(2)が返すメモリアドレスはsbrk(2)が操作するheap領域とは重ならないようになっているらしい。つまり、sbrk(2)とは無関係なメモリ領域にmalloc_pagesize、つまり１ページ分のメモリ領域を確保した事になる。その領域はpginfo構造体のダブルポインタである page_dir に格納されている。
<br />
</p>

<p class="paragraph">
その後この時点でのheap先頭を sbrk(0) により取得し、そのアドレスをページサイズ単位で丸め、さらにpageshift分右シフトさせている。
<br />
</p>
<pre>malloc_origo = pageround((size_t)(uintptr_t)sbrk((intptr_t)0))
    &gt;&gt; malloc_pageshift;
</pre>
<p class="paragraph">
さらにpageshift分、縮めている。
<br />
</p>
<pre>malloc_origo -= malloc_pageshift;
</pre>

<p class="paragraph">
ここでptr2idx()マクロと比べてみると、ちょうどお互いに逆処理を行っていることが分かる。
<br />
</p>
<pre>ptr2idx(foo) = (foo &gt;&gt; malloc_pageshift) - malloc_origio
malloc_origo = (pageround(sbrk(0)) &gt;&gt; malloc_pageshift) - malloc_pageshift
よって、
ptr2idx(foo) = (foo &gt;&gt; malloc_pageshift)
               - ((pageround(sbrk(0)) &gt;&gt; malloc_pageshift)
               + malloc_pageshift
</pre>
<p class="paragraph">
fooに渡るのはmalloc()処理の中で扱われるので、おおむねページサイズの整数倍になっている=pageround()処理されているアドレスだろう。ptr2idxでmalloc.cを検索してみると、次のようにpage_dirを配列とした時の添字に使われている。
<br />
</p>
<pre>page_dir[ptr2idx(アドレス)]
</pre>
<p class="paragraph">
つまりptr2idxはアドレスを元にしてpage_dirにアクセスする時の添字を返すマクロであることが分かる。これにより、pginfo構造体のポインタにアクセス出来る(page_dirはpginfo構造体へのダブルポインタ)。またmalloc_pageshiftで底上げ調整が行われている為、例えアドレスが0だったとしても、ptr2idx()を通すと malloc_pageshift に変換される。
<br />
</p>
<pre>ptr2idx(0) == malloc_pageshift
</pre>
<p class="paragraph">
今回の環境であれば malloc_pageshift は 12 なので、
<br />
</p>
<pre>page_dir[ptr2idx(0)] =&gt; page_dir[12]
</pre>
<p class="paragraph">
となる。page_dir[0] - [11]の用途はページサイズ以下のメモリ割り当てで使われ、詳細は後述する。
<br />
</p>

<p class="paragraph">
もちろん、初期状態ではpginfo構造体へのポインタ用の領域は１ページサイズ分しかmmap(2)で確保されていない。pginfo構造体へのポインタがいくつ格納出来るかは、malloc_init()の次の行でmalloc_ninfo変数に初期値が計算され、格納されている。
<br />
</p>
<pre>malloc_ninfo = malloc_pagesize / sizeof *page_dir;
</pre>
<p class="paragraph">
もしpginfo構造体(へのポインタ)の数がこれを越えようとした場合は、map_pages()の中で自動判定・extend_pgdir()で再度MAP_ANONでmmap(2)しなおしている。
<br />
</p>

<h3 id="id2eb5bf">malloc_pages()：ページサイズの半分を越える領域の確保</h3>

<p class="paragraph">
malloc_pages()まで戻る。malloc_pages()のコードで重要部分を抜き書きすると次のようになる。エラー処理や過去にfree()したページの探索部分は削っている。
<br />
</p>
<pre class="plugin_pre">
/*
 * Allocate a number of complete pages
 */
static void *
malloc_pages(size_t size)
{
    void *p, *delay_free = 0;
    size_t idx;

    /* サイズをページサイズで丸める */
    idx = pageround(size);
    if (idx &lt; size) {
        errno = ENOMEM;
        return NULL;
    } else
        size = idx;

    p = 0;

    /* ... */

    /* ページ単位に変換してmap_pages()に渡す */
    size &gt;&gt;= malloc_pageshift;
    /* Map new pages */
    if (!p)
        p = map_pages(size);

    if (p) {
        /* 確保したアドレス範囲に対応する page_dir[XX]
           に、MALLOC_FIRSTを先頭にしてMALLOC_FOLLOWを埋める */
        idx = ptr2idx(p);
        page_dir[idx] = MALLOC_FIRST;
        for (i=1;i&lt;size;i++)
            page_dir[idx+i] = MALLOC_FOLLOW;
        if (malloc_junk)
            memset(p, SOME_JUNK, size &lt;&lt; malloc_pageshift);
    }

    /* ... */

    return p;
}
</pre>
<p class="paragraph">
MALLOC_FIRST, MALLOC_FOLLOWというのはmalloc.cの冒頭で次のようにdefineされている。
<br />
</p>
<pre>/*
 * Magic values to put in the page_directory
 */
#define MALLOC_NOT_MINE ((struct pginfo*) 0)
#define MALLOC_FREE     ((struct pginfo*) 1)
#define MALLOC_FIRST    ((struct pginfo*) 2)
#define MALLOC_FOLLOW   ((struct pginfo*) 3)
#define MALLOC_MAGIC    ((struct pginfo*) 4)
</pre>
<p class="paragraph">
実際にアドレスが0-4になることはまずあり得ない。コメントにあるとおり、page_dir用のマジックナンバーである。
<br />
複数ページに渡ってmalloc(3)する簡単なテストプログラムを作ってみると、page_dirの各インデックスに対してマジックナンバーがどのように振られるのかがよく分かる。
<br />
test3.c:
<br />
</p>
<div class="hl-main"><pre><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdio.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdint.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">stdlib.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
</span><span >#include</span><span > </span><span class="hl-quotes">&lt;</span><span class="hl-string">unistd.h</span><span class="hl-quotes">&gt;</span><span ></span><span class="hl-code">
 
</span><span >static</span><span class="hl-code"> </span><span class="hl-identifier">size_t</span><span class="hl-code"> </span><span class="hl-identifier">malloc_origo</span><span class="hl-code">;
</span><span >static</span><span class="hl-code"> </span><span class="hl-identifier">size_t</span><span class="hl-code"> </span><span class="hl-identifier">malloc_pagesize</span><span class="hl-code">;
</span><span >static</span><span class="hl-code"> </span><span class="hl-identifier">size_t</span><span class="hl-code"> </span><span class="hl-identifier">malloc_pageshift</span><span class="hl-code">;
</span><span >static</span><span class="hl-code"> </span><span class="hl-identifier">size_t</span><span class="hl-code"> </span><span class="hl-identifier">malloc_pagemask</span><span class="hl-code">;
</span><span >#define</span><span class="hl-code"> </span><span class="hl-identifier">pageround</span><span class="hl-brackets">(</span><span class="hl-identifier">foo</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">(</span><span class="hl-brackets">(</span><span class="hl-identifier">foo</span><span class="hl-brackets">)</span><span class="hl-code"> + </span><span class="hl-brackets">(</span><span class="hl-identifier">malloc_pagemask</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">&amp;</span><span class="hl-brackets">(</span><span class="hl-code">~</span><span class="hl-brackets">(</span><span class="hl-identifier">malloc_pagemask</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span ></span><span class="hl-code">
</span><span >#define</span><span class="hl-code"> </span><span class="hl-identifier">ptr2idx</span><span class="hl-brackets">(</span><span class="hl-identifier">foo</span><span class="hl-brackets">)</span><span class="hl-code"> \
     </span><span class="hl-brackets">(</span><span class="hl-brackets">(</span><span class="hl-brackets">(</span><span class="hl-identifier">size_t</span><span class="hl-brackets">)</span><span class="hl-brackets">(</span><span class="hl-identifier">uintptr_t</span><span class="hl-brackets">)</span><span class="hl-brackets">(</span><span class="hl-identifier">foo</span><span class="hl-brackets">)</span><span class="hl-code"> &gt;&gt; </span><span class="hl-identifier">malloc_pageshift</span><span class="hl-brackets">)</span><span class="hl-code">-</span><span class="hl-identifier">malloc_origo</span><span class="hl-brackets">)</span><span ></span><span class="hl-code">
 
</span><span >void</span><span class="hl-code"> </span><span class="hl-identifier">do_malloc</span><span class="hl-brackets">(</span><span class="hl-identifier">size_t</span><span class="hl-code"> </span><span class="hl-identifier">size</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
  </span><span >void</span><span class="hl-code"> *</span><span class="hl-identifier">ptr</span><span class="hl-code">;
  </span><span class="hl-identifier">size_t</span><span class="hl-code"> </span><span class="hl-identifier">idx</span><span class="hl-code">;
  </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">i</span><span class="hl-code">;
 
  </span><span class="hl-identifier">ptr</span><span class="hl-code"> = </span><span class="hl-identifier">malloc</span><span class="hl-brackets">(</span><span class="hl-identifier">size</span><span class="hl-brackets">)</span><span class="hl-code">;
  </span><span class="hl-identifier">printf</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">malloc(%d) = %p</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">size</span><span class="hl-code">, </span><span class="hl-identifier">ptr</span><span class="hl-brackets">)</span><span class="hl-code">;
  </span><span class="hl-identifier">idx</span><span class="hl-code"> = </span><span class="hl-identifier">ptr2idx</span><span class="hl-brackets">(</span><span class="hl-identifier">ptr</span><span class="hl-brackets">)</span><span class="hl-code">;
  </span><span class="hl-identifier">size</span><span class="hl-code"> = </span><span class="hl-identifier">pageround</span><span class="hl-brackets">(</span><span class="hl-identifier">size</span><span class="hl-brackets">)</span><span class="hl-code"> &gt;&gt; </span><span class="hl-identifier">malloc_pageshift</span><span class="hl-code">;
  </span><span class="hl-identifier">printf</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">page_dir[%d] = MALLOC_FIRST</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">idx</span><span class="hl-brackets">)</span><span class="hl-code">;
  </span><span class="hl-reserved">for</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">i</span><span class="hl-code"> = </span><span class="hl-number">1</span><span class="hl-code">; </span><span class="hl-identifier">i</span><span class="hl-code"> &lt; </span><span class="hl-identifier">size</span><span class="hl-code">; </span><span class="hl-identifier">i</span><span class="hl-code">++</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
    </span><span class="hl-identifier">printf</span><span class="hl-brackets">(</span><span class="hl-quotes">&quot;</span><span class="hl-string">page_dir[%d] = MALLOC_FOLLOW</span><span class="hl-special">\</span><span class="hl-string">n</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">idx</span><span class="hl-code"> + </span><span class="hl-identifier">i</span><span class="hl-brackets">)</span><span class="hl-code">;
  </span><span class="hl-brackets">}</span><span class="hl-code">
</span><span class="hl-brackets">}</span><span class="hl-code">
 
</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">main</span><span class="hl-brackets">(</span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">argc</span><span class="hl-code">, </span><span >char</span><span class="hl-code"> *</span><span class="hl-identifier">argv</span><span class="hl-brackets">[</span><span class="hl-brackets">]</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
  </span><span >void</span><span class="hl-code"> *</span><span class="hl-identifier">ptr</span><span class="hl-code">;
 
  </span><span class="hl-identifier">malloc_pagesize</span><span class="hl-code"> = </span><span class="hl-brackets">(</span><span class="hl-identifier">size_t</span><span class="hl-brackets">)</span><span class="hl-identifier">sysconf</span><span class="hl-brackets">(</span><span class="hl-identifier">_SC_PAGESIZE</span><span class="hl-brackets">)</span><span class="hl-code">;
  </span><span class="hl-identifier">malloc_pagemask</span><span class="hl-code"> = </span><span class="hl-identifier">malloc_pagesize</span><span class="hl-code"> - </span><span class="hl-number">1</span><span class="hl-code">;
  </span><span class="hl-reserved">for</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">malloc_pageshift</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">;
    </span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-identifier">UL</span><span class="hl-code"> &lt;&lt; </span><span class="hl-identifier">malloc_pageshift</span><span class="hl-brackets">)</span><span class="hl-code"> != </span><span class="hl-identifier">malloc_pagesize</span><span class="hl-code">;
    </span><span class="hl-identifier">malloc_pageshift</span><span class="hl-code">++</span><span class="hl-brackets">)</span><span class="hl-code">
    </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> nothing </span><span class="hl-mlcomment">*/</span><span class="hl-code"> ;
 
  </span><span class="hl-identifier">ptr</span><span class="hl-code"> = </span><span class="hl-identifier">sbrk</span><span class="hl-brackets">(</span><span class="hl-brackets">(</span><span class="hl-identifier">intptr_t</span><span class="hl-brackets">)</span><span class="hl-number">0</span><span class="hl-brackets">)</span><span class="hl-code">;
  </span><span class="hl-identifier">malloc_origo</span><span class="hl-code"> = </span><span class="hl-identifier">pageround</span><span class="hl-brackets">(</span><span class="hl-brackets">(</span><span class="hl-identifier">size_t</span><span class="hl-brackets">)</span><span class="hl-brackets">(</span><span class="hl-identifier">uintptr_t</span><span class="hl-brackets">)</span><span class="hl-identifier">ptr</span><span class="hl-brackets">)</span><span class="hl-code"> &gt;&gt; </span><span class="hl-identifier">malloc_pageshift</span><span class="hl-code">;
  </span><span class="hl-identifier">malloc_origo</span><span class="hl-code"> -= </span><span class="hl-identifier">malloc_pageshift</span><span class="hl-code">;
 
  </span><span class="hl-identifier">do_malloc</span><span class="hl-brackets">(</span><span class="hl-number">1</span><span class="hl-code"> * </span><span class="hl-number">4096</span><span class="hl-code"> + </span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
  </span><span class="hl-identifier">do_malloc</span><span class="hl-brackets">(</span><span class="hl-number">3</span><span class="hl-code"> * </span><span class="hl-number">4096</span><span class="hl-code"> + </span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code">;
 
  </span><span class="hl-reserved">return</span><span class="hl-code"> </span><span class="hl-number">0</span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>
<p class="paragraph">
コンパイル＋実行例
<br />
</p>
<pre class="plugin_pre">
$ cc -Wall -o test3 test3.c
$ ./test3
malloc(4097) = 0x804b000
page_dir[13] = MALLOC_FIRST
page_dir[14] = MALLOC_FOLLOW
malloc(12289) = 0x805d000
page_dir[31] = MALLOC_FIRST
page_dir[32] = MALLOC_FOLLOW
page_dir[33] = MALLOC_FOLLOW
page_dir[34] = MALLOC_FOLLOW
</pre>

<p class="paragraph">
この時点で、アドレスのみでfree(3)を行える手がかりは掴めてきた。アドレスからpage_dirのインデックスに変換するマクロは用意され、さらにmalloc(3)された時にページ単位で確保されたか判定する為のマジックナンバーも判明した。
<br />
そこで早速、free(3)の本体であるifree()関数を見てみる。
<br />
</p>

<h4 id="idf19167">ifree() → free_pages()による解放処理</h4>

<p class="paragraph">
ifree()で重要な部分は以下のコードである。見て分かる通り、ptr2idx()マクロで取得した添字でpage_dirにアクセスし、MALLOC_MAGIC以下ならページ単位で確保された事を意味するのでfree_pages()を呼んでいる。
<br />
</p>
<pre class="plugin_pre">
static void
ifree(void *ptr)
{
    struct pginfo *info;
    size_t idx;

    /* ... */

    idx = ptr2idx(ptr);
    /* ... */
    info = page_dir[idx];

    if (info &lt; MALLOC_MAGIC)
        free_pages(ptr, idx, info);
    else
        free_bytes(ptr, idx, info);
    return;
}
</pre>
<p class="paragraph">
free_pages()側では以下のコードでMALLOC_FREEに更新している。
<br />
</p>
<pre class="plugin_pre">
static __inline__ void
free_pages(void *ptr, size_t idx, struct pginfo *info)
{
    /* ... */

    /* Count how many pages and mark them free at the same time */
    page_dir[idx] = MALLOC_FREE;
    for (i = 1; page_dir[idx+i] == MALLOC_FOLLOW; i++)
        page_dir[idx + i] = MALLOC_FREE;
</pre>
<p class="paragraph">
この後に、free(3)された領域管理用のpgfree構造体の確保やリスト操作が続くが今回のお題とは関係が薄い為、省略する。
<br />
</p>

<p class="paragraph">
ここまででページ単位でのmalloc(3)/free(3)の関係は把握出来た。続いてページサイズの半分以下のケースについて追ってみる。
<br />
</p>

<h3 id="idfaebfc">malloc_bytes() : ページサイズの半分以下の領域確保</h3>

<p class="paragraph">
imalloc()のコードより、ページサイズの半分以下のメモリ確保にはmalloc_bytes()が使われる。
<br />
malloc_bytes()ではpginfo構造体が出てくるので、ここでpginfo構造体の定義をソースより抜き出してみる。
<br />
</p>
<pre class="plugin_pre">
struct pginfo {
    struct pginfo       *next;  /* next on the free list */
    void                *page;  /* Pointer to the page */
    u_short             size;   /* size of this page&#039;s chunks */
    u_short             shift;  /* How far to shift for this size chunks */
    u_short             free;   /* How many free chunks */
    u_short             total;  /* How many chunk */
    u_int               bits[1]; /* Which chunks are free */
};

/*
 * How many bits per u_int in the bitmap.
 * Change only if not 8 bits/byte
 */
#define MALLOC_BITS     (8*sizeof(u_int))
</pre>
<p class="paragraph">
今の時点ではコメント内容の多くが不明だが、とりあえずmalloc_bytes()の中へ進んでみる。
<br />
まず前半部分：
<br />
</p>
<pre class="plugin_pre">
static void *
malloc_bytes(size_t size)
{
    size_t i;
    int j;
    u_int u;
    struct  pginfo *bp;
    int k;
    u_int *lp;

    /* Don&#039;t bother with anything less than this */
    if (size &lt; malloc_minsize)
        size = malloc_minsize;

    /* Find the right bucket */
    j = 1;
    i = size-1;
    while (i &gt;&gt;= 1)
        /* サイズのビット桁をカウントし、page_dirの添字とする */
        j++;

    /* If it&#039;s empty, make a page more of that size chunks */
    if (!page_dir[j] &amp;&amp; !malloc_make_chunks(j))
        return 0;

    bp = page_dir[j];
</pre>
<p class="paragraph">
page_dirの添字については、ページ単位の場合はptr2idx()マクロによりpageshift分底上げされていたことを思い出すと、今回の環境ではpageshiftが12なので
<br />
</p>
<pre>malloc_pages : page_dir[12] -
malloc_bytes : page_dir[0] - [11]
</pre>
<p class="paragraph">
までアクセスされることになる。
<br />
なお最小サイズがmalloc_minsizeに補正され、上のdefineを見ると16になっている為、実際はpage_dir[4]以降を扱う。
<br />
</p>

<p class="paragraph">
添字はjに格納され、page_dir[j]が空の場合はmalloc_make_chunks()で領域が確保されるらしい。malloc_make_chunks()については後ほど追ってみるが、ざっと眺めた限りではpginfo構造体を確保して多少弄っているようだ。
<br />
bpにはpage_dir[j]で参照されるpginfo構造体のアドレスが格納される。そしてmalloc_bytes()の後半が以下のように続く。
<br />
</p>
<pre class="plugin_pre">
    /* Find first word of bitmap which isn&#039;t empty */
    for (lp = bp-&gt;bits; !*lp; lp++)
        ;

    /* Find that bit, and tweak it */
    u = 1;
    k = 0;
    while (!(*lp &amp; u)) {
        u += u;
        k++;
    }
    *lp ^= u;

    /* If there are no more free, remove from free-list */
    if (!--bp-&gt;free) {
        page_dir[j] = bp-&gt;next;
        bp-&gt;next = 0;
    }

    /* Adjust to the real offset of that chunk */
    k += (lp-bp-&gt;bits)*MALLOC_BITS;
    k &lt;&lt;= bp-&gt;shift;

    if (malloc_junk)
        memset((u_char*)bp-&gt;page + k, SOME_JUNK, (size_t)bp-&gt;size);

    return (u_char *)bp-&gt;page + k;
}
</pre>
<p class="paragraph">
最初にpginfo構造体のbitsメンバに対して、空でない要素を探すループがある。元々のpginfo構造体の定義としてはbitsメンバはu_intの1要素の配列なので、malloc_make_chunks()の中で弄られていることが予想される。
<br />
空でないu_int要素が見つかると、bitsを調べ空いているbitが見つかればXORでそのbitをセットするのが次のコードブロックにあたる。
<br />
</p>
<pre>   /* Find that bit, and tweak it */
   u = 1;
   k = 0;
   while (!(*lp &amp; u)) {
       u += u; /* 2倍している＝&quot;u &lt;&lt;= 1&quot; */
       k++;
   }
   *lp ^= u; /* XOR */
</pre>
<p class="paragraph">
freeについては省略して、その後、飛び越したu_intの要素分ｘそのbit桁(MALLOC_BITS)を計算し、shiftメンバ分だけシフトさせる事で実際のoffsetが計算される。
<br />
</p>
<pre>   /* Adjust to the real offset of that chunk */
   k += (lp-bp-&gt;bits)*MALLOC_BITS;
   k &lt;&lt;= bp-&gt;shift;
</pre>
<p class="paragraph">
最後にpageメンバにoffsetを加算した値を返すことで、malloc_bytes()は呼び出し元に戻る。
<br />
</p>
<pre>   return (u_char *)bp-&gt;page + k;
</pre>

<h4 id="id485b5e">malloc_make_chunks()の流れ</h4>

<p class="paragraph">
続いてpginfo構造体を初期化するmalloc_make_chunks()を見てみるが、解説の殆どは「デーモン君のソース探検」で書かれている為、こちらの読書メモではざっくりと読み散らす程度に留める。<span class="hidden">(</span><a class="footnote" href="#footnote_571_1" id="footnote_571_1_r"  title="べ、別にソースが理解出来なかったわけじゃ以下ｒｙ">*1</a><span class="hidden">)</span>
<br />
</p>

<p class="paragraph">
最初に1ページ分ざっくりと確保してしまう。
<br />
</p>
<pre>   /* Allocate a new bucket */
   pp = malloc_pages(malloc_pagesize);
</pre>

<p class="paragraph">
続いてmalloc_bytes()から渡されてきたbits桁数に応じて、u_intの配列要素bitsメンバを増やした場合の構造体サイズを計算している。
<br />
</p>
<pre>   /* Find length of admin structure */
   l = (int)offsetof(struct pginfo, bits[0]);
   l += sizeof bp-&gt;bits[0] *
       (((malloc_pagesize &gt;&gt; bits)+MALLOC_BITS-1) / MALLOC_BITS);
</pre>
<p class="paragraph">
&quot;offsetof&quot;についてはstddef.hで定義されたマクロである。0番地アドレスを仮の構造体先頭アドレスにすることで、メンバへのオフセットを計算出来る。
<br />
</p>
<pre>stddef.h:#define        offsetof(type, member)  \
                         ((size_t)(unsigned long)(&amp;((type *)0)-&gt;member))
</pre>

<p class="paragraph">
桁数と計算された構造体の大きさに応じて、先ほど確保した1ページの中にpginfo構造体を含めてやりくりするか、pginfo構造体は別の場所に確保するか場合分けしている。
<br />
</p>
<pre>   /* Don&#039;t waste more than two chunks on this */
   if ((1&lt;&lt;(bits)) &lt;= l+l) {
       bp = (struct  pginfo *)pp;
   } else {
       bp = (struct  pginfo *)imalloc((size_t)l);
       if (!bp) {
           ifree(pp);
           return 0;
       }
   }
</pre>

<p class="paragraph">
その後pginfo構造体の各メンバを初期化している。
<br />
</p>
<pre>   bp-&gt;size = (1&lt;&lt;bits);
   bp-&gt;shift = bits;
   bp-&gt;total = bp-&gt;free = malloc_pagesize &gt;&gt; bits;
   bp-&gt;page = pp;
</pre>

<p class="paragraph">
もしも1ページ内でpginfo構造体も含めてやりくりする場合は、
<br />
</p>
<pre>bp = bp-&gt;page = pp
</pre>
<p class="paragraph">
が成立する。
<br />
</p>

<p class="paragraph">
この後bitsメンバが初期化され(省略)、もし1ページ内でpginfo構造体も含めてやりくりする場合は、pginfo構造体の分だけbitsメンバを調整する処理が以下のコードブロックになる：
<br />
</p>
<pre>   if (bp == bp-&gt;page) {
       /* Mark the ones we stole for ourselves */
       for(i=0;l &gt; 0;i++) {
           bp-&gt;bits[i/MALLOC_BITS] &amp;= ~(1&lt;&lt;(i%MALLOC_BITS));
           bp-&gt;free--;
           bp-&gt;total--;
           l -= (1 &lt;&lt; bits);
       }
   }
</pre>

<p class="paragraph">
最後にpage_dirやnextメンバを調整して完了となる。
<br />
</p>
<pre>   page_dir[ptr2idx(pp)] = bp;
   bp-&gt;next = page_dir[bits];
   page_dir[bits] = bp;
</pre>

<p class="paragraph">
ざっくりとだがこれでmalloc_bytes()およびmalloc_make_chunks()の動きを把握出来た。
<br />
</p>

<p class="paragraph">
対になるfree_bytes()については解説を省略するが、pginfo構造体の情報を用いて該当bitをクリアし、同時にfreeした領域の管理情報をそうさしている。
<br />
</p>

<p class="paragraph">
かなりややこしかったが、以上でmalloc(3)とfree(3)で、なぜfree(3)がメモリアドレスだけで領域を解放できるのか判明した。まずページサイズの半分より大きい場合はページサイズ単位に丸め、アドレスから管理情報のインデックス番号へ変換するマクロにより、free(3)ではアドレスだけで管理情報を適切に操作出来る。
<br />
ページサイズの半分以下の場合はまず1ページ分確保してしまい、内部を実際に指定されたサイズで分割し、bitmapで利用状況を管理する。free(3)からも管理情報にアクセスできるようになっているため、同様にアドレスだけで解放処理を行うことが出来る。
<br />
</p>

<p class="paragraph">
ページサイズの半分以下の場合の処理が特に複雑になっているが、その理由とこのmallocの設計思想については「デーモン君のソース探検」を参照のこと。
<br />
</p>

<p class="paragraph">
今回のお題については、ここまで。
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-568.html" title="C言語系/「デーモン君のソース探検」読書メモ/15, mktemp(3),mkstemp(3)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-573.html" title="C言語系/「デーモン君のソース探検」読書メモ/A01, touch(1)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-546.html" title="C言語系/「デーモン君のソース探検」読書メモ">Up</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul><div class="footnote">
<a id="footnote_571_1" href="#footnote_571_1_r">*1</a>: べ、別にソースが理解出来なかったわけじゃ以下ｒｙ
</div>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/571<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2001 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" target="_blank" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>