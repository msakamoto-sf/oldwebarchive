<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>C言語系/「デーモン君のソース探検」読書メモ/A09, write(2) + O_APPEND - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">C言語系/「デーモン君のソース探検」読書メモ/A09, write(2) + O_APPEND</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-11-23 23:56:30 &nbsp; / &nbsp; last updated at: 2010-11-23 23:59:37<br>
カテゴリ: <a href="category-32.html">BSD</a>&nbsp;<a href="category-10.html">C言語</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-848.html" title="C言語系/「デーモン君のソース探検」読書メモ/A08, pause(3), sigsuspend(2)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-850.html" title="C言語系/「デーモン君のソース探検」読書メモ/A10, popen(3)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
お題：open(2)でO_APPENDが指定されたファイル記述子に対してwrite(2)するとき、ファイルポジションが自動的に末尾に設定する箇所を特定せよ
<br />
</p>

<p class="paragraph">
※この章は「デーモン君のソース探検」に載っていませんが、msakamoto-sf自身が個人的に興味を持って調べ、&quot;Appendix&quot;として読書メモシリーズに入れてありますのでご注意下さい。
<br />
</p>



<ul><li><a href="#idfddffa">O_APPENDとwrite(2)</a></li>
<li><a href="#id53996f">探索</a><ul><li><a href="#id66509c">sys/syscall.h : SYS_write</a><ul><li><a href="#id52e35c">src/sys/kern/init_sysent.c</a></li>
<li><a href="#id57628d">struct sysent (sys/systm.h)</a></li>
<li><a href="#id7c5ed0">struct sys_write_args (sys/syscallargs.h)</a></li></ul></li>
<li><a href="#id8c3224">sys_write() : src/sys/kern/sys_generic.c</a><ul><li><a href="#id84c0e1">struct proc (sys/proc.h)</a></li>
<li><a href="#id2692ae">struct filedesc (sys/filedesc.h)</a></li>
<li><a href="#id5181c1">struct file (sys/file.h)</a></li>
<li><a href="#id3d9dba">fd_getfile() : src/sys/kern/kern_descrip.c</a></li>
<li><a href="#id2ea794">sys_write()前半の解説まとめ</a></li></ul></li>
<li><a href="#id576c3c">dofilewrite() : src/sys/kern/sys_generic.c</a><ul><li><a href="#id4ab9f9">struct uio (sys/uio.h)</a></li>
<li><a href="#id65a1a6">実際の書き込み処理は struct file 構造体の f_ops-&gt;fo_write() へ</a></li></ul></li>
<li><a href="#id2718f2">vn_write() : src/sys/kern/vfs_vnops.c</a><ul><li><a href="#iddea5e0">struct vnode (sys/vnode.h)</a></li>
<li><a href="#id0e832a">VOP_WRITE()マクロ (sys/vnode_if.h)</a></li></ul></li>
<li><a href="#id0e6cd5">探索終了</a></li></ul></li>
<li><a href="#id6da349">まとめ</a></li></ul>
<hr />
<h3 id="idfddffa">O_APPENDとwrite(2)</h3>

<p class="paragraph">
open(2)でフラグにO_APPENDを組み合わせると、write(2)時に自動的にファイルオフセットが末尾に移動する。ファイル書き込みを追記モードで行いたいときに使う。
<br />
</p>

<p class="paragraph">
では、O_APPENDの有無に応じたファイルオフセットの移動はどこで行われているのか？今回はそれについて追ってみたい。
<br />
</p>

<h3 id="id53996f">探索</h3>

<p class="paragraph">
ソースの探索を始める。
<br />
</p>

<h4 id="id66509c">sys/syscall.h : SYS_write</h4>

<p class="paragraph">
まずwrite(2)の手がかりをつかむために、適当に&quot;/usr/include/sys&quot;をgrepしてみたところ syscall.h で以下の定義を見つけた。
<br />
</p>
<pre>/* syscall: &quot;write&quot; ret: &quot;ssize_t&quot; args: &quot;int&quot; &quot;const void *&quot; &quot;size_t&quot; */
#define SYS_write       4
</pre>

<h5 id="id52e35c">src/sys/kern/init_sysent.c</h5>

<p class="paragraph">
ではSYS_writeがカーネル内部ではどうマッピングされているのか？
<br />
適当にgrepで漁ってみると、どうやらinit_sysent.cの中でのstruct sysent構造体の配列でマッピングされているようだ。
<br />
/usr/src/sys/kern/init_sysent.c:
<br />
</p>
<pre class="plugin_pre">
struct sysent sysent[] = {
        { 0, 0, 0,
            sys_nosys },                        /* 0 = syscall (indir) */
        { 1, s(struct sys_exit_args), 0,
            sys_exit },                         /* 1 = exit */
        { 0, 0, 0,
            sys_fork },                         /* 2 = fork */
        { 3, s(struct sys_read_args), 0,
            sys_read },                         /* 3 = read */
        { 3, s(struct sys_write_args), 0,
            sys_write },                        /* 4 = write */
...
</pre>

<h5 id="id57628d">struct sysent (sys/systm.h)</h5>

<p class="paragraph">
struct sysentの定義は sys/systm.h で見つかった。
<br />
</p>
<pre class="plugin_pre">
typedef int     sy_call_t(struct proc *, void *, register_t *);

extern struct sysent {          /* system call table */
        short   sy_narg;        /* number of args */
        short   sy_argsize;     /* total size of arguments */
        int     sy_flags;       /* flags. see below */
        sy_call_t *sy_call;     /* implementing function */
} sysent[];
</pre>

<h5 id="id7c5ed0">struct sys_write_args (sys/syscallargs.h)</h5>

<p class="paragraph">
各システムコールの引数は、sys/syscallargs.h内で構造体として定義されているようだ。
<br />
</p>
<pre class="plugin_pre">
#define syscallarg(x)                                                   \
        union {                                                         \
                register_t pad;                                         \
                struct { x datum; } le;                                 \
                struct { /* LINTED zero array dimension */              \
                        int8_t pad[  /* CONSTCOND */                    \
                                (sizeof (register_t) &lt; sizeof (x))      \
                                ? 0                                     \
                                : sizeof (register_t) - sizeof (x)];    \
                        x datum;                                        \
                } be;                                                   \
        }

...

struct sys_write_args {
        syscallarg(int) fd;
        syscallarg(const void *) buf;
        syscallarg(size_t) nbyte;
};
</pre>

<h4 id="id8c3224">sys_write() : src/sys/kern/sys_generic.c</h4>

<p class="paragraph">
流れを戻すと、init_sysent.c内で sys_write というシンボルを参照している。
<br />
適当にgrepしてみると、sys_generic.cといういかにもなソースコード中に定義されていた。
<br />
</p>

<p class="paragraph">
sys_generic.c:
<br />
</p>
<pre class="plugin_pre">
/*
 * Write system call
 */
int
sys_write(struct proc *p, void *v, register_t *retval)
{
        struct sys_write_args /* {
                syscallarg(int)                 fd;
                syscallarg(const void *)        buf;
                syscallarg(size_t)              nbyte;
        } */ *uap = v;
        int             fd;
        struct file     *fp;
        struct filedesc *fdp;

        fd = SCARG(uap, fd);
        fdp = p-&gt;p_fd;

        if ((fp = fd_getfile(fdp, fd)) == NULL)
                return (EBADF);

        if ((fp-&gt;f_flag &amp; FWRITE) == 0)
                return (EBADF);

        FILE_USE(fp);

        /* dofilewrite() will unuse the descriptor for us */
        return (dofilewrite(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
            &amp;fp-&gt;f_offset, FOF_UPDATE_OFFSET, retval));
}
</pre>

<p class="paragraph">
struct proc, file, filedescと見慣れない構造体が出てきているので、確認してみる。
<br />
</p>

<h5 id="id84c0e1">struct proc (sys/proc.h)</h5>

<p class="paragraph">
プロセス情報の構造体である。メンバ数が多いので、今回のお題に関連するメンバのみメモしておく。
<br />
sys/proc.h:
<br />
</p>
<pre class="plugin_pre">
/*
 * Description of a process.
 *
 * This structure contains the information needed to manage a thread of
 * control, known in UN*X as a process; it has references to substructures
 * containing descriptions of things that the process uses, but may share
 * with related processes.  The process structure and the substructures
 * are always addressible except for those marked &quot;(PROC ONLY)&quot; below,
 * which might be addressible only on a processor on which the process
 * is running.
 */
struct proc {
...
        struct filedesc *p_fd;          /* Ptr to open files structure */
...
</pre>

<h5 id="id2692ae">struct filedesc (sys/filedesc.h)</h5>

<p class="paragraph">
ファイル記述子を管理するための構造体。sys/filedesc.h で定義されている。
<br />
</p>
<pre class="plugin_pre">
/*
 * This structure is used for the management of descriptors.  It may be
 * shared by multiple processes.
 *
 * A process is initially started out with NDFILE descriptors stored within
 * this structure, selected to be enough for typical applications based on
 * the historical limit of 20 open files (and the usage of descriptors by
 * shells).  If these descriptors are exhausted, a larger descriptor table
 * may be allocated, up to a process&#039; resource limit; the internal arrays
 * are then unused.  The initial expansion is set to NDEXTENT; each time
 * it runs out, it is doubled until the resource limit is reached. NDEXTENT
 * should be selected to be the biggest multiple of OFILESIZE (see below)
 * that will fit in a power-of-two sized piece of memory.
 */
#define NDFILE          20
#define NDEXTENT        50              /* 250 bytes in 256-byte alloc */

struct filedesc {
        struct file     **fd_ofiles;    /* file structures for open files */
        char            *fd_ofileflags; /* per-process open file flags */
        int             fd_nfiles;      /* number of open files allocated */
        int             fd_lastfile;    /* high-water mark of fd_ofiles */
        int             fd_freefile;    /* approx. next free file */
        int             fd_refcnt;      /* reference count */
};
</pre>

<h5 id="id5181c1">struct file (sys/file.h)</h5>

<p class="paragraph">
カーネルが使うファイル記述子で、vnodeあるいはsocketのエントリを表す。sys/file.hで定義されている。
<br />
</p>
<pre class="plugin_pre">
/*
 * Kernel descriptor table.
 * One entry for each open kernel vnode and socket.
 */
struct file {
        LIST_ENTRY(file) f_list;        /* list of active files */
        int             f_flag;         /* see fcntl.h */
        int             f_iflags;       /* internal flags */
#define DTYPE_VNODE     1               /* file */
#define DTYPE_SOCKET    2               /* communications endpoint */
#define DTYPE_PIPE      3               /* pipe */
        int             f_type;         /* descriptor type */
        u_int           f_count;        /* reference count */
        u_int           f_msgcount;     /* references from message queue */
        int             f_usecount;     /* number active users */
        struct ucred    *f_cred;        /* creds associated with descriptor */
        struct fileops {
                int     (*fo_read)      (struct file *fp, off_t *offset,
                                            struct uio *uio,
                                            struct ucred *cred, int flags);
                int     (*fo_write)     (struct file *fp, off_t *offset,
                                            struct uio *uio,
                                            struct ucred *cred, int flags);
                int     (*fo_ioctl)     (struct file *fp, u_long com,
                                            caddr_t data, struct proc *p);
                int     (*fo_fcntl)     (struct file *fp, u_int com,
                                            caddr_t data, struct proc *p);
                int     (*fo_poll)      (struct file *fp, int events,
                                            struct proc *p);
                int     (*fo_stat)      (struct file *fp, struct stat *sp,
                                            struct proc *p);
                int     (*fo_close)     (struct file *fp, struct proc *p);
        } *f_ops;
        off_t           f_offset;
        caddr_t         f_data;         /* descriptor data, e.g. vnode/socket */
};

...
#define FILE_USE(fp)                                                    \
do {                                                                    \
        (fp)-&gt;f_usecount++;                                             \
        FILE_USE_CHECK((fp), &quot;f_usecount overflow&quot;);                    \
} while (/* CONSTCOND */ 0)

#define FILE_UNUSE(fp, p)                                               \
do {                                                                    \
        if ((fp)-&gt;f_iflags &amp; FIF_WANTCLOSE) {                           \
                /* Will drop usecount */                                \
                (void) closef((fp), (p));                               \
        } else {                                                        \
                (fp)-&gt;f_usecount--;                                     \
                FILE_USE_CHECK((fp), &quot;f_usecount underflow&quot;);           \
        }                                                               \
} while (/* CONSTCOND */ 0)

/*
 * Flags for fo_read and fo_write.
 */
#define FOF_UPDATE_OFFSET       0x01    /* update the file offset */
</pre>

<h5 id="id3d9dba">fd_getfile() : src/sys/kern/kern_descrip.c</h5>

<p class="paragraph">
sys_write()に目を戻すと、fd_getfile()という関数が気になる。おそらく、プロセス情報(struct proc) → プロセスのファイル記述子テーブル(struct filedesc) → カーネルのファイル記述子(struct file) という順番で辿る関数だろうが、念のため目を通しておく。
<br />
</p>

<p class="paragraph">
src/sys/kern/kern_descrip.c というファイルに定義されている。
<br />
</p>
<pre class="plugin_pre">
struct file *
fd_getfile(struct filedesc *fdp, int fd)
{
        struct file *fp;

        if ((u_int) fd &gt;= fdp-&gt;fd_nfiles || (fp = fdp-&gt;fd_ofiles[fd]) == NULL)
                return (NULL);

        if (FILE_IS_USABLE(fp) == 0)
                return (NULL);

        return (fp);
}
</pre>
<p class="paragraph">
ちなみに、この下にはsys_dup()やsys_dup2()などが定義されていて興味深い。
<br />
</p>

<h5 id="id2ea794">sys_write()前半の解説まとめ</h5>

<p class="paragraph">
これでsys_write()を読み解くのに必要な情報は集まったので、コメントによる解説付きで再掲する。
<br />
</p>

<p class="paragraph">
sys_generic.c:
<br />
</p>
<pre class="plugin_pre">
/*
 * Write system call
 */
int
sys_write(struct proc *p, void *v, register_t *retval)
{
        struct sys_write_args /* {
                syscallarg(int)                 fd;
                syscallarg(const void *)        buf;
                syscallarg(size_t)              nbyte;
        } */ *uap = v;
        int             fd;
        struct file     *fp;
        struct filedesc *fdp;

        /* システムコールの引数からファイル記述子の番号を取得 */
        fd = SCARG(uap, fd);
        /* プロセス情報からファイル記述子の管理テーブル(struct filedesc)を取得 */
        fdp = p-&gt;p_fd;

        /* カーネル内のファイル記述情報(struct file)を取得 */
        if ((fp = fd_getfile(fdp, fd)) == NULL)
                return (EBADF);

        if ((fp-&gt;f_flag &amp; FWRITE) == 0)
                return (EBADF);

        FILE_USE(fp);

        /* dofilewrite() will unuse the descriptor for us */
        return (dofilewrite(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
            &amp;fp-&gt;f_offset, FOF_UPDATE_OFFSET, retval));
}
</pre>

<p class="paragraph">
実際の書き込み処理は、dofilewrite()内で行われていることが分かった。
<br />
</p>

<h4 id="id576c3c">dofilewrite() : src/sys/kern/sys_generic.c</h4>

<p class="paragraph">
まずdofilewrite()の引数を確認する。
<br />
</p>
<pre class="plugin_pre">
int
dofilewrite(
struct proc *p,    /* プロセス情報 */
int fd,            /* システムコールの引数：ファイル記述子番号 */
struct file *fp,   /* fdに対応するカーネルのファイル記述情報 */
const void *buf,   /* システムコールの引数：バッファ */
size_t nbyte,      /* システムコールの引数：バッファサイズ */
off_t *offset,     /* fp-&gt;f_offsetへのポインタ */
int flags,         /* FOF_UPDATE_OFFSET */
register_t *retval)
{
</pre>

<pre>off_t *offset
</pre>
<p class="paragraph">
がおそらくファイルのoffsetに相当すると思われる。sys_write()からは
<br />
</p>
<pre>&amp;fp-&gt;f_offset
</pre>
<p class="paragraph">
が渡されている。
<br />
</p>

<p class="paragraph">
念のため、ファイルoffsetを変更するシステムコールの代表であるlseek()のソースを確認する。
<br />
grepすると、vfs_syscalls.c 内でsys_lseek() が定義されているのが見つかる。
<br />
ざっくり読んでみると、最終的に
<br />
</p>
<pre>*(off_t *)retval = fp-&gt;f_offset = newoff;
</pre>
<p class="paragraph">
として、カーネルのファイル情報(struct file)のf_offsetメンバに新しいoffsetを設定している。
<br />
</p>

<p class="paragraph">
このことから、f_offsetメンバがファイルのoffsetであると考えてほぼ間違いないと思われる。
<br />
</p>

<p class="paragraph">
ではdofilewriteに戻り、KTRACEの&quot;#ifdef&quot;を除去したソースを載せる。
<br />
</p>

<pre class="plugin_pre">
int
dofilewrite(struct proc *p, int fd, struct file *fp, const void *buf,
        size_t nbyte, off_t *offset, int flags, register_t *retval)
{
        struct uio      auio;
        struct iovec    aiov;
        long            cnt, error;

        error = 0;
        aiov.iov_base = (caddr_t)buf;           /* XXX kills const */
        aiov.iov_len = nbyte;
        auio.uio_iov = &amp;aiov;
        auio.uio_iovcnt = 1;
        auio.uio_resid = nbyte;
        auio.uio_rw = UIO_WRITE;
        auio.uio_segflg = UIO_USERSPACE;
        auio.uio_procp = p;

        /*
         * Writes return ssize_t because -1 is returned on error.  Therefore
         * we must restrict the length to SSIZE_MAX to avoid garbage return
         * values.
         */
        if (auio.uio_resid &gt; SSIZE_MAX) {
                error = EINVAL;
                goto out;
        }

        cnt = auio.uio_resid;
        error = (*fp-&gt;f_ops-&gt;fo_write)(fp, offset, &amp;auio, fp-&gt;f_cred, flags);
        if (error) {
                if (auio.uio_resid != cnt &amp;&amp; (error == ERESTART ||
                    error == EINTR || error == EWOULDBLOCK))
                        error = 0;
                if (error == EPIPE)
                        psignal(p, SIGPIPE);
        }
        cnt -= auio.uio_resid;
        *retval = cnt;
 out:
        FILE_UNUSE(fp, p);
        return (error);
}
</pre>

<p class="paragraph">
処理内容は斜め読みで、雰囲気で分かるが、struct uioというのが登場しているので定義を確認しておく。
<br />
</p>

<h5 id="id4ab9f9">struct uio (sys/uio.h)</h5>

<p class="paragraph">
struct iovec については readv()/writev() のmanpageを参照。
<br />
</p>

<pre class="plugin_pre">
enum    uio_rw { UIO_READ, UIO_WRITE };

/* Segment flag values. */
enum uio_seg {
        UIO_USERSPACE,          /* from user data space */
        UIO_SYSSPACE            /* from system space */
};

struct uio {
        struct  iovec *uio_iov; /* pointer to array of iovecs */
        int     uio_iovcnt;     /* number of iovecs in array */
        off_t   uio_offset;     /* offset into file this uio corresponds to */
        size_t  uio_resid;      /* residual i/o count */
        enum    uio_seg uio_segflg; /* see above */
        enum    uio_rw uio_rw;  /* see above */
        struct  proc *uio_procp;/* process if UIO_USERSPACE */
};
</pre>

<h5 id="id65a1a6">実際の書き込み処理は struct file 構造体の f_ops-&gt;fo_write() へ</h5>

<p class="paragraph">
dofilewrite()に戻り、ポイントとなる箇所だけ見ていく。
<br />
</p>
<pre class="plugin_pre">
/* バッファを struct iovec の形で渡す */
aiov.iov_base = (caddr_t)buf;           /* XXX kills const */
aiov.iov_len = nbyte;
auio.uio_iov = &amp;aiov;
auio.uio_iovcnt = 1;

/* residual(残余)カウンタをシステムコール引数：バッファサイズに初期化 */
auio.uio_resid = nbyte;

auio.uio_rw = UIO_WRITE;
auio.uio_segflg = UIO_USERSPACE;
auio.uio_procp = p;

/* cnt = fo_write前の未writeバッファサイズ */
cnt = auio.uio_resid;
error = (*fp-&gt;f_ops-&gt;fo_write)(fp, offset, &amp;auio, fp-&gt;f_cred, flags);
if (error) {
    /* 省略 */
}
/* fo_write後の未writeバッファサイズをマイナス
   =&gt; fo_writeで書き込まれたバッファサイズ */
cnt -= auio.uio_resid;
*retval = cnt;
</pre>

<p class="paragraph">
実際の書き込み処理は、ファイルシステムごとのfo_write()に委譲される。
<br />
</p>
<pre>error = (*fp-&gt;f_ops-&gt;fo_write)(
    fp,         /* カーネルのファイル記述情報(struct file) */
    offset,     /* fp-&gt;f_offsetのポインタ */
    &amp;auio,      /* struct uio */
    fp-&gt;f_cred, /* struct ucred, sys/ucred.h 参照 */
    flags       /* FOF_UPDATE_OFFSET(sys_write()から引継ぎ) */
    );
</pre>

<p class="paragraph">
fo_writeに設定されるシンボルを探す必要があるが、ファイルシステムやマウントポイントが絡むため、お行儀よくそれらのアーキテクチャについて調査するといつまでも終わらない。
<br />
</p>

<p class="paragraph">
強引だが、お題目の趣旨からO_APPENDフラグを使っている箇所をgrepで検索してみる。
<br />
</p>

<h4 id="id2718f2">vn_write() : src/sys/kern/vfs_vnops.c</h4>

<p class="paragraph">
すると vfs_vnops.c 内でvn_write()という関数が見つかった。引数もfo_write()の呼び出しと一致するので、とりあえずこれが呼ばれるものと仮定して、ソースを読んでみる。
<br />
</p>
<pre class="plugin_pre">
/*
 * File table vnode write routine.
 */
int
vn_write(fp, offset, uio, cred, flags)
        struct file *fp;
        off_t *offset;
        struct uio *uio;
        struct ucred *cred;
        int flags;
{
        struct vnode *vp = (struct vnode *)fp-&gt;f_data;
        int count, error, ioflag = IO_UNIT;

        /* ようやく O_APPEND 登場 */
        if (vp-&gt;v_type == VREG &amp;&amp; (fp-&gt;f_flag &amp; O_APPEND))
                ioflag |= IO_APPEND;
        if (fp-&gt;f_flag &amp; FNONBLOCK)
                ioflag |= IO_NDELAY;
        if (fp-&gt;f_flag &amp; FFSYNC ||
            (vp-&gt;v_mount &amp;&amp; (vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_SYNCHRONOUS)))
                ioflag |= IO_SYNC;
        else if (fp-&gt;f_flag &amp; FDSYNC)
                ioflag |= IO_DSYNC;
        if (fp-&gt;f_flag &amp; FALTIO)
                ioflag |= IO_ALTSEMANTICS;
        VOP_LEASE(vp, uio-&gt;uio_procp, cred, LEASE_WRITE);
        vn_lock(vp, LK_EXCLUSIVE | LK_RETRY);

        /* ロックする迄待ってから、最新のファイルoffsetをuio_offsetにコピー */
        uio-&gt;uio_offset = *offset;
        count = uio-&gt;uio_resid;
        error = VOP_WRITE(vp, uio, ioflag, cred);
        if (flags &amp; FOF_UPDATE_OFFSET) {
                if (ioflag &amp; IO_APPEND)
                        /* !!!!!!!!!!!!!!!!!!!!!!!! */
                        *offset = uio-&gt;uio_offset;
                else
                        *offset += count - uio-&gt;uio_resid;
        }
        VOP_UNLOCK(vp, 0);
        return (error);
}
</pre>

<p class="paragraph">
ようやくそれらしきコードが見つかった。O_APPENDが設定されていると、VOP_WRITE()の後に、カーネルのファイル記述情報(struct file)のoffsetを struct uio の uio_offset で更新している。
<br />
</p>

<p class="paragraph">
ここでまた struct vnode や VOP_WRITE マクロが登場しているので、念のため確認しておく。
<br />
</p>

<h5 id="iddea5e0">struct vnode (sys/vnode.h)</h5>

<pre>/*
 * The vnode is the focus of all file activity in UNIX.  There is a
 * unique vnode allocated for each active file, each current directory,
 * each mounted-on file, text file, and the root.
 */
</pre>

<pre class="plugin_pre">
/*
 * Reading or writing any of these items requires holding the appropriate lock.
 * v_freelist is locked by the global vnode_free_list simple lock.
 * v_mntvnodes is locked by the global mntvnodes simple lock.
 * v_flag, v_usecount, v_holdcount and v_writecount are
 *     locked by the v_interlock simple lock
 */
struct vnode {
        struct uvm_object v_uobj;               /* the VM object */
#define v_usecount      v_uobj.uo_refs
#define v_interlock     v_uobj.vmobjlock
        voff_t          v_size;                 /* size of file */
        int             v_flag;                 /* flags */
        int             v_numoutput;            /* number of pending writes */
        long            v_writecount;           /* reference count of writers */
        long            v_holdcnt;              /* page &amp; buffer references */
        u_long          v_id;                   /* capability identifier */
        struct mount    *v_mount;               /* ptr to vfs we are in */
        int             (**v_op) __P((void *)); /* vnode operations vector */
        TAILQ_ENTRY(vnode) v_freelist;          /* vnode freelist */
        LIST_ENTRY(vnode) v_mntvnodes;          /* vnodes for mount point */
        struct buflists v_cleanblkhd;           /* clean blocklist head */
        struct buflists v_dirtyblkhd;           /* dirty blocklist head */
        LIST_ENTRY(vnode) v_synclist;           /* vnodes with dirty buffers */
        union {
                struct mount    *vu_mountedhere;/* ptr to mounted vfs (VDIR) */
                struct socket   *vu_socket;     /* unix ipc (VSOCK) */
                struct specinfo *vu_specinfo;   /* device (VCHR, VBLK) */
                struct fifoinfo *vu_fifoinfo;   /* fifo (VFIFO) */
        } v_un;
        struct nqlease  *v_lease;               /* Soft reference to lease */
        enum vtype      v_type;                 /* vnode type */
        enum vtagtype   v_tag;                  /* type of underlying data */
        struct lock     v_lock;                 /* lock for this vnode */
        struct lock     *v_vnlock;              /* pointer to lock */
        void            *v_data;                /* private data for fs */
};
</pre>

<h5 id="id0e832a">VOP_WRITE()マクロ (sys/vnode_if.h)</h5>

<pre class="plugin_pre">
struct vop_write_args {
        const struct vnodeop_desc *a_desc;
        struct vnode *a_vp;
        struct uio *a_uio;
        int a_ioflag;
        struct ucred *a_cred;
};
extern const struct vnodeop_desc vop_write_desc;

int VOP_WRITE(struct vnode *, struct uio *, int, struct ucred *);

#ifndef VNODE_OP_NOINLINE
static __inline int VOP_WRITE(vp, uio, ioflag, cred)
        struct vnode *vp;
        struct uio *uio;
        int ioflag;
        struct ucred *cred;
{
        struct vop_write_args a;
        a.a_desc = VDESC(vop_write);
        a.a_vp = vp;
        a.a_uio = uio;
        a.a_ioflag = ioflag;
        a.a_cred = cred;
        return (VCALL(vp, VOFFSET(vop_write), &amp;a));
}
#endif
</pre>

<h4 id="id0e6cd5">探索終了</h4>

<p class="paragraph">
これ以上はファイルシステムやデバイスドライバの領域になるため、今回はここまでにしておく。
<br />
もしさらに調べるのであれば、たとえば
<br />
</p>
<pre>src/sys/XXYYfs/
</pre>
<p class="paragraph">
などファイルシステムのソースツリー内でO_APPENDをgrepしてみると面白いだろう。
<br />
</p>
<pre class="plugin_pre">
$ cd /usr/src/sys/ufs
$ grep -r O_APPEND *
ext2fs/ext2fs_readwrite.c:              if (ioflag &amp; IO_APPEND)
ext2fs/ext2fs_vnops.c:          (ap-&gt;a_mode &amp; (FWRITE | O_APPEND)) == FWRITE)
ufs/ufs_readwrite.c:            if (ioflag &amp; IO_APPEND)
ufs/ufs_vnops.c:            (ap-&gt;a_mode &amp; (FWRITE | O_APPEND)) == FWRITE)
</pre>
<p class="paragraph">
かなり肉薄しつつあるのがgrep結果だけからも見て取れる。
<br />
</p>

<p class="paragraph">
しかしvnodeがファイルシステム、ひいてはデバイスドライバを隠蔽するインターフェイスとして存在する以上は、vnodeまでで探索を止めておくのが無難だろう。
<br />
</p>

<h3 id="id6da349">まとめ</h3>

<p class="paragraph">
open(2)でO_APPENDが指定されたファイル記述子に対してwrite(2)するとき、ファイルポジションが自動的に末尾に設定する箇所を特定することが出来た。
<br />
writeシステムコールは src/sys/kern/init_sysent.c 内で sys_write シンボルに結び付けられ、writeシステムコールは以下の流れでvn_write()へたどり着く。
<br />
</p>

<pre>sys_write() : src/sys/kern/sys_generic.c
 → dofilewrite() : src/sys/kern/sys_generic.c
     → vn_write() : src/sys/kern/vfs_vnops.c
</pre>

<p class="paragraph">
vn_write()内でvnodeインターフェイスを使って実際のファイルシステム・デバイスドライバに書き込み処理を委譲した後、O_APPENDフラグに応じてカーネルのファイル記述情報(struct file)のoffsetを更新している。これがすなわち、O_APPENDフラグが指定された時に、write()が自動的にoffsetをファイル末尾に移動する箇所に相当している。
<br />
</p>

<p class="paragraph">
今回のお題については、ここまで。
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-848.html" title="C言語系/「デーモン君のソース探検」読書メモ/A08, pause(3), sigsuspend(2)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-850.html" title="C言語系/「デーモン君のソース探検」読書メモ/A10, popen(3)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-546.html" title="C言語系/「デーモン君のソース探検」読書メモ">Up</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/849<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2007 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>