<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>C言語系/「デーモン君のソース探検」読書メモ/10, tail(1) - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">C言語系/「デーモン君のソース探検」読書メモ/10, tail(1)</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-01-14 17:37:50 &nbsp; / &nbsp; last updated at: 2010-01-14 17:45:24<br>
カテゴリ: <a href="category-32.html">BSD</a>&nbsp;<a href="category-10.html">C言語</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-553.html" title="C言語系/「デーモン君のソース探検」読書メモ/09, mv(1)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-555.html" title="C言語系/「デーモン君のソース探検」読書メモ/11, file(1)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
お題：tailコマンドの&quot;-f&quot;オプションを調査せよ。
<br />
</p>

<p class="paragraph">
今回も、tailコマンドのmanページで使い方をおさらいしておく。
<br />
</p>
<pre>tail [-f | -F | -r] [-b number | -c number | -n number] [file ...]
</pre>
<p class="paragraph">
&quot;-f&quot;はファイル監視モードを指示し、普段良く使うオプション。&quot;-F&quot;は&quot;-f&quot;に似ているが、5秒ごとにファイル名が変更されたりしていないかチェックし、もしそうなら再オープンする。syslogなど、ローテーションされるファイルを監視する時に使うと便利。
<br />
&quot;-b&quot;, &quot;-c&quot;, &quot;-n&quot; は初期表示するサイズ。順に、512バイトのブロック単位、バイト単位、行単位で指定する。
<br />
</p>

<p class="paragraph">
それではソースの探索に進む。
<br />
</p>
<pre>$ locate tail.c
/usr/src/usr.bin/tail/tail.c
$ cd /usr/src/usr.bin/tail
$ ls
CVS/
Makefile
extern.h
forward.c
misc.c
read.c
reverse.c
tail.1
tail.c
</pre>
<p class="paragraph">
幾つかのファイルに分かれている。とりあえずtail.cから探索を始める。
<br />
</p>



<ul><li><a href="#id002fa2">tail.cの探検</a></li>
<li><a href="#id80897a">forward.cのforward()関数の探検</a></li>
<li><a href="#idb895a0">forward.cのrlines()関数の探検</a></li>
<li><a href="#id9cc6f5">forward.cのforward()関数の探検（再開）</a></li></ul>
<hr />
<h3 id="id002fa2">tail.cの探検</h3>

<p class="paragraph">
tail.cについては &quot;-b&quot;, &quot;-c&quot;, &quot;-n&quot; オプションの処理や過去のオプション指定との互換性維持で特殊な部分がある。それ以外は素直に読めると思うので、駆け足で進める。
<br />
</p>

<p class="paragraph">
まず&quot;-r&quot;, &quot;-f&quot;オプションなどを保持しておく為のグローバル変数が宣言される。
<br />
</p>
<pre>int fflag, rflag, rval;
char *fname;
</pre>
<p class="paragraph">
関数のプロトタイプ宣言が続き、main()関数の冒頭でローカル変数が宣言される。
<br />
</p>
<pre class="plugin_pre">
int
main(argc, argv)
        int argc;
        char *argv[];
{
        struct stat sb;
        FILE *fp;
        long off;
        enum STYLE style;
        int ch, first;
        char *p;

        off = 0;
</pre>
<p class="paragraph">
ここで重要なのはsb, fp, off, styleである。sbとfpはファイル情報、offは&quot;-b&quot;, &quot;-c&quot;, &quot;-n&quot;で指定されたオフセット、styleは&quot;extern.h&quot;で定義されたenum値で、オフセット単位はバイトか行か・ファイル先頭からのオフセットか末尾からのオフセットか、などの組み合わせを指定出来るようになっている。
<br />
extern.h:
<br />
</p>
<pre>enum STYLE { NOTSET = 0, FBYTES, FLINES, RBYTES, RLINES, REVERSE };
</pre>

<p class="paragraph">
main()関数ではこれに続いて、いきなりARGV()というマクロが定義される。
<br />
</p>
<pre>#define ARG(units, forward, backward) { 
...
</pre>
<p class="paragraph">
詳細は割愛する。ソースも特に読みづらいものではないと思う。
<br />
概要だけ書いておくと、&quot;-b&quot;, &quot;-c&quot;, &quot;-n&quot; で指定された数値を元に&quot;off&quot;(オフセット)の計算と&quot;style&quot;の設定を行っている。
<br />
指定された数値が
<br />
</p>
<pre>-b +10
</pre>
<p class="paragraph">
のように&quot;+&quot;始まりの場合、ファイルの先頭からのオフセットとして扱う。
<br />
</p>
<pre>-b -10
-b 10
</pre>
<p class="paragraph">
のように&quot;-&quot;始まりor符号未指定の場合、ファイルの末尾からのオフセットとして扱う。
<br />
</p>

<p class="paragraph">
マクロ定義に続いてobsolete()という関数が呼び出されているが、これは過去のオプション指定方法との互換性維持なので、ここでは取りあげない。
<br />
</p>
<pre>obsolete(argv);
</pre>

<p class="paragraph">
その下にgetopt(3)によるオプション処理の見慣れたwhileループがある。
<br />
</p>
<pre class="plugin_pre">
while ((ch = getopt(argc, argv, &quot;Fb:c:fn:r&quot;)) != -1)
    switch(ch) {
    case &#039;F&#039;:
        fflag = 2;
        break;
    case &#039;b&#039;:
        ARG(512, FBYTES, RBYTES);
        break;
    case &#039;c&#039;:
        ARG(1, FBYTES, RBYTES);
        break;
    case &#039;f&#039;:
        fflag = 1;
        break;
    case &#039;n&#039;:
        ARG(1, FLINES, RLINES);
        break;
    case &#039;r&#039;:
        rflag = 1;
        break;
    case &#039;?&#039;:
    default:
        usage();
    }
</pre>
<p class="paragraph">
&quot;-b&quot;, &quot;-c&quot;, &quot;-n&quot; の処理で先ほど取りあげたARGVマクロが使われている。
<br />
</p>
<pre>{F|R}BYTES, {F|R}LINES
</pre>
<p class="paragraph">
についてはextern.hで定義されたenum値でARGVマクロの中でstyleにセットされる。
<br />
ARGVマクロの定義を振り返って整理すれば、オフセット値の符号指定で以下のようにstyleは設定される。
<br />
</p>
<pre>&quot;+&quot;始まりの数値     → style = FBYTES or FLINES (ファイル先頭からのオフセット)
&quot;-&quot;始まりor符号無し → style = RBYTES or RLINES (ファイル末尾からのオフセット)
</pre>

<p class="paragraph">
この後、&quot;-f&quot;が指定されていてかつ、fileが２つ以上指定された場合はエラーとしている。
<br />
</p>
<pre>if (fflag &amp;&amp; argc &gt; 1)
    err(1, &quot;-f and -F options only appropriate for a single file&quot;);
</pre>

<p class="paragraph">
続けて以下のifブロック。見たままなので特にソースは載せないが、&quot;-r&quot;が指定された場合はstyleを RBYTES or RLINES に強制的に再設定している。また&quot;-r&quot;と&quot;-f&quot;が同時指定されていたらエラーとしている。
<br />
</p>
<pre>if (rflag) {
    /* ... */
}
</pre>

<p class="paragraph">
さらに次のifブロックでは、&quot;-b&quot;,&quot;-c&quot;,&quot;-n&quot;が指定されなかった場合のoffとstyleのデフォルト値を設定している。
<br />
</p>
<pre>if (style == NOTSET) {
    if (rflag) {
        off = 0;
        style = REVERSE;
    } else {
        off = 10;
        style = RLINES;
    }
}
</pre>

<p class="paragraph">
これに続くifブロックのソースは割愛する。大雑把な概要だけ示すと、以下のようになる。
<br />
</p>
<ol><li> fileが指定された場合は、指定されたfile毎に fopen()の戻り値をfpに、fstat()の戻り値をsbに入れ、&quot;-r&quot;指定時はreverse()を、それ以外ならforward()を呼ぶ。</li>
<li> file未指定時は標準入力に対して reverse()/forward() を呼び分ける。</li></ol>

<p class="paragraph">
&quot;-r&quot;フラグに応じてreverse()/forward()を呼び分けるコードは以下のようになっている。
<br />
</p>
<pre>if (rflag)
    reverse(fp, style, off, &amp;sb);
else
    forward(fp, style, off, &amp;sb);
</pre>

<p class="paragraph">
reverse()/forward()は、それぞれ reverse.c / forward.c で定義されている。
<br />
今回のお題は&quot;-f&quot;オプション指定時の動作なのでforward.cの探索へ進む。
<br />
</p>

<p class="paragraph">
reverse.c にも軽く目を通してみたが、forward.cと比べてかなり読みやすい。というのもforward.cだと&quot;-f&quot;,&quot;-F&quot;オプションによる監視(ポーリング)処理があるのに対し、&quot;-r&quot;オプションのreverse()の場合は逆順に出力してお仕舞いだからだ。
<br />
reverse()本体は非常にスッキリしているし、ファイルが通常ファイル(S_ISREG==true)の場合に呼ばれるr_reg()関数もmmap()を使った短くて分かりやすいコードになっている。「デーモン君のソース探検」では、forward()の解析中にmmap()の解説も出てくるが、mmap()に注目するのであればreverse.cのr_reg()の方が分かりやすいかも知れない。
<br />
</p>

<p class="paragraph">
一応参考までにr_reg()を載せておく。
<br />
</p>
<div class="hl-main"><pre><span >static</span><span class="hl-code"> </span><span >void</span><span class="hl-code">
</span><span class="hl-identifier">r_reg</span><span class="hl-brackets">(</span><span class="hl-identifier">fp</span><span class="hl-code">, </span><span class="hl-identifier">style</span><span class="hl-code">, </span><span class="hl-identifier">off</span><span class="hl-code">, </span><span class="hl-identifier">sbp</span><span class="hl-brackets">)</span><span class="hl-code">
        </span><span class="hl-identifier">FILE</span><span class="hl-code"> *</span><span class="hl-identifier">fp</span><span class="hl-code">;
        </span><span >enum</span><span class="hl-code"> </span><span class="hl-identifier">STYLE</span><span class="hl-code"> </span><span class="hl-identifier">style</span><span class="hl-code">;
        </span><span >long</span><span class="hl-code"> </span><span class="hl-identifier">off</span><span class="hl-code">;
        </span><span >struct</span><span class="hl-code"> </span><span class="hl-identifier">stat</span><span class="hl-code"> *</span><span class="hl-identifier">sbp</span><span class="hl-code">;
</span><span class="hl-brackets">{</span><span class="hl-code">
        </span><span class="hl-identifier">off_t</span><span class="hl-code"> </span><span class="hl-identifier">size</span><span class="hl-code">;
        </span><span >int</span><span class="hl-code"> </span><span class="hl-identifier">llen</span><span class="hl-code">;
        </span><span >char</span><span class="hl-code"> *</span><span class="hl-identifier">p</span><span class="hl-code">;
        </span><span >char</span><span class="hl-code"> *</span><span class="hl-identifier">start</span><span class="hl-code">;
 
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">!</span><span class="hl-brackets">(</span><span class="hl-identifier">size</span><span class="hl-code"> = </span><span class="hl-identifier">sbp</span><span class="hl-code">-&gt;</span><span class="hl-identifier">st_size</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">
                </span><span class="hl-reserved">return</span><span class="hl-code">;
 
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">size</span><span class="hl-code"> &gt; </span><span class="hl-identifier">SIZE_T_MAX</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-identifier">err</span><span class="hl-brackets">(</span><span class="hl-number">0</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">%s: %s</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">fname</span><span class="hl-code">, </span><span class="hl-identifier">strerror</span><span class="hl-brackets">(</span><span class="hl-identifier">EFBIG</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-reserved">return</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
 
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-brackets">(</span><span class="hl-identifier">start</span><span class="hl-code"> = </span><span class="hl-identifier">mmap</span><span class="hl-brackets">(</span><span >NULL</span><span class="hl-code">, </span><span class="hl-brackets">(</span><span class="hl-identifier">size_t</span><span class="hl-brackets">)</span><span class="hl-identifier">size</span><span class="hl-code">, </span><span class="hl-identifier">PROT_READ</span><span class="hl-code">,
            </span><span class="hl-identifier">MAP_FILE</span><span class="hl-code">|</span><span class="hl-identifier">MAP_SHARED</span><span class="hl-code">, </span><span class="hl-identifier">fileno</span><span class="hl-brackets">(</span><span class="hl-identifier">fp</span><span class="hl-brackets">)</span><span class="hl-code">, </span><span class="hl-brackets">(</span><span class="hl-identifier">off_t</span><span class="hl-brackets">)</span><span class="hl-number">0</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code"> == </span><span class="hl-brackets">(</span><span class="hl-identifier">caddr_t</span><span class="hl-brackets">)</span><span class="hl-code">-</span><span class="hl-number">1</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                </span><span class="hl-identifier">err</span><span class="hl-brackets">(</span><span class="hl-number">0</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">%s: %s</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">fname</span><span class="hl-code">, </span><span class="hl-identifier">strerror</span><span class="hl-brackets">(</span><span class="hl-identifier">EFBIG</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">;
                </span><span class="hl-reserved">return</span><span class="hl-code">;
        </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-identifier">p</span><span class="hl-code"> = </span><span class="hl-identifier">start</span><span class="hl-code"> + </span><span class="hl-identifier">size</span><span class="hl-code"> - </span><span class="hl-number">1</span><span class="hl-code">;
 
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">style</span><span class="hl-code"> == </span><span class="hl-identifier">RBYTES</span><span class="hl-code"> &amp;&amp; </span><span class="hl-identifier">off</span><span class="hl-code"> &lt; </span><span class="hl-identifier">size</span><span class="hl-brackets">)</span><span class="hl-code">
                </span><span class="hl-identifier">size</span><span class="hl-code"> = </span><span class="hl-identifier">off</span><span class="hl-code">;
 
        </span><span class="hl-mlcomment">/*</span><span class="hl-mlcomment"> Last char is special, ignore whether newline or not. </span><span class="hl-mlcomment">*/</span><span class="hl-code">
        </span><span class="hl-reserved">for</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">llen</span><span class="hl-code"> = </span><span class="hl-number">1</span><span class="hl-code">; --</span><span class="hl-identifier">size</span><span class="hl-code">; ++</span><span class="hl-identifier">llen</span><span class="hl-brackets">)</span><span class="hl-code">
                </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-code">*--</span><span class="hl-identifier">p</span><span class="hl-code"> == '\</span><span class="hl-identifier">n</span><span class="hl-code">'</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                        </span><span class="hl-identifier">WR</span><span class="hl-brackets">(</span><span class="hl-identifier">p</span><span class="hl-code"> + </span><span class="hl-number">1</span><span class="hl-code">, </span><span class="hl-identifier">llen</span><span class="hl-brackets">)</span><span class="hl-code">;
                        </span><span class="hl-identifier">llen</span><span class="hl-code"> = </span><span class="hl-number">0</span><span class="hl-code">;
                        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">style</span><span class="hl-code"> == </span><span class="hl-identifier">RLINES</span><span class="hl-code"> &amp;&amp; !--</span><span class="hl-identifier">off</span><span class="hl-brackets">)</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
                                ++</span><span class="hl-identifier">p</span><span class="hl-code">;
                                </span><span class="hl-reserved">break</span><span class="hl-code">;
                        </span><span class="hl-brackets">}</span><span class="hl-code">
                </span><span class="hl-brackets">}</span><span class="hl-code">
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">llen</span><span class="hl-brackets">)</span><span class="hl-code">
                </span><span class="hl-identifier">WR</span><span class="hl-brackets">(</span><span class="hl-identifier">p</span><span class="hl-code">, </span><span class="hl-identifier">llen</span><span class="hl-brackets">)</span><span class="hl-code">;
        </span><span class="hl-reserved">if</span><span class="hl-code"> </span><span class="hl-brackets">(</span><span class="hl-identifier">munmap</span><span class="hl-brackets">(</span><span class="hl-identifier">start</span><span class="hl-code">, </span><span class="hl-brackets">(</span><span class="hl-identifier">size_t</span><span class="hl-brackets">)</span><span class="hl-identifier">sbp</span><span class="hl-code">-&gt;</span><span class="hl-identifier">st_size</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">
                </span><span class="hl-identifier">err</span><span class="hl-brackets">(</span><span class="hl-number">0</span><span class="hl-code">, </span><span class="hl-quotes">&quot;</span><span class="hl-string">%s: %s</span><span class="hl-quotes">&quot;</span><span class="hl-code">, </span><span class="hl-identifier">fname</span><span class="hl-code">, </span><span class="hl-identifier">strerror</span><span class="hl-brackets">(</span><span class="hl-identifier">errno</span><span class="hl-brackets">)</span><span class="hl-brackets">)</span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>
<p class="paragraph">
ソースが短いせいもあり、ぱっと見で大凡の動作は分かると思う。
<br />
</p>

<h3 id="id80897a">forward.cのforward()関数の探検</h3>

<p class="paragraph">
forward.c の forward() を見ていく。
<br />
ローカル変数宣言の後にswitchブロックが鎮座している。
<br />
</p>
<pre class="plugin_pre">
switch(style) {
case FBYTES:
        if (off == 0)
                break;
        if (S_ISREG(sbp-&gt;st_mode)) {
                if (sbp-&gt;st_size &lt; off)
                        off = sbp-&gt;st_size;
                if (fseek(fp, off, SEEK_SET) == -1) {
                        ierr();
                        return;
                }
        } else while (off--)
                if ((ch = getc(fp)) == EOF) {
                        if (ferror(fp)) {
                                ierr();
                                return;
                        }
                        break;
                }
        break;
/* ... */
</pre>
<p class="paragraph">
offで指定されたオフセット処理を行うが、caseブロックにより、styleの値に応じてパターンを分けている。
<br />
例えば上のFBYTESの場合は、ファイル先頭からのオフセットかつバイト単位になるので、
<br />
</p>
<pre>if (off == 0)
    break;
</pre>
<p class="paragraph">
→まずoffが0の場合はそもそもオフセット処理は無用。
<br />
</p>
<pre>if (S_ISREG(sbp-&gt;st_mode)) {
    /* ... */
    if (fseek(fp, off, SEEK_SET) /* ... */
</pre>
<p class="paragraph">
通常ファイル(S_ISREG()マクロについては&quot;sys/stat.h&quot;参照)であればfseek(3)にてオフセット位置まで移動。
<br />
</p>
<pre>} else while (off--)
    if ((ch = getc(fp)) == EOF) {
</pre>
<p class="paragraph">
通常ファイル以外なら、getc(3)を使ってオフセット位置まで読み飛ばす。
<br />
</p>

<p class="paragraph">
FLINES, RBYTES の場合も大同小異で、通常ファイルとそれ以外に分けた上で、fseek(3)やgetc(3)でオフセット位置までの移動を実現している。
<br />
RLINESの場合だけ特殊なので、詳しく見てみる。
<br />
</p>
<pre class="plugin_pre">
case RLINES:
    if (S_ISREG(sbp-&gt;st_mode)) {
        if (!off) {
            if (fseek(fp, 0L, SEEK_END) == -1) {
                ierr();
                return;
            }
        } else {
            if (rlines(fp, off, sbp))
                return;
        }
    } else if (off == 0) {
        while (getc(fp) != EOF);
        if (ferror(fp)) {
            ierr();
            return;
        }
    } else {
        if (lines(fp, off))
            return;
    }
    break;
</pre>
<p class="paragraph">
fseek(3), getc(3)だけで済むケースだけ見てみる。
<br />
</p>
<ol><li> 通常ファイルでoffが0の場合はfseek(3)でオフセット位置決め。</li>
<li> 通常ファイル以外でoffが0の場合はgetc()でEOFが出るまで読み飛ばし、つまり末尾へ移動。</li></ol>

<p class="paragraph">
それ以外では・・・
<br />
</p>
<ol><li> 通常ファイルでoffが0以外の場合は rlines() でオフセット処理</li>
<li> 通常ファイル以外でoffが0以外の場合は lines() でオフセット処理</li></ol>

<p class="paragraph">
lines()は read.c で定義されているが、「デーモン君のソース探検」では特に取りあげられていないので割愛する。rlines()ではmmap(2)を使っているのに対し、lines()ではmalloc()/realloc()/memset()/memmove()を使って行単位で構造体を確保し、処理している点だけメモしておく。
<br />
</p>

<p class="paragraph">
rlines()のソースだが、「デーモン君のソース探検」の方ではcvswebを使って過去の簡単なソースを使って解析している。
<br />
しかし落ち着いて読んでみたところNetBSD1.6の&quot;forward.c,v 1.18&quot;の状態でも理解できたので、メモしておく。
<br />
</p>

<h3 id="idb895a0">forward.cのrlines()関数の探検</h3>

<p class="paragraph">
先に概要を書くと、ファイル末尾から10MB単位で切り出し、改行の数を数える。offで指定された数だけ改行が見つかれば、その位置までfseek(3)でファイルポインタを進める。もし切り出した10MBの中に改行が足りない時は、さらにその前の10MBを切り出して調べていく。
<br />
</p>

<pre class="plugin_pre">
static int
rlines(fp, off, sbp)
        FILE *fp;
        long off;
        struct stat *sbp;
{
        off_t file_size;
        off_t file_remaining;
        char *p;
        char *start;
        off_t mmap_size;
        off_t mmap_offset;
        off_t mmap_remaining;

#define MMAP_MAXSIZE  (10 * 1024 * 1024)

        if (!(file_size = sbp-&gt;st_size))
                return (0);
        file_remaining = file_size;
</pre>
<p class="paragraph">
MMAP_MAXSIZEというのが、mmap(2)で切り出す最大サイズを定義していて、ここでは10MBになっている。その後、&quot;file_remaining&quot;を&quot;file_size&quot;、つまりファイルのサイズと同じにしている。
<br />
続いて、MMAP_MAXSIZEを境目として、最初にmmap(2)で切り出す時のサイズとオフセットを調整している。
<br />
</p>
<pre>if (file_remaining &gt; MMAP_MAXSIZE) {
    /* MMAP_MAXSIZEより大きいファイルの場合は、
       ファイルの末尾からMMAP_MAXSIZE分切り出す */
    mmap_size = MMAP_MAXSIZE;
    mmap_offset = file_remaining - MMAP_MAXSIZE;
} else {
    /* MMAP_MAXSIZEより小さい場合は、mmap_offset = 0にすることで
       ファイル全体を切り出してしまう。 */
    mmap_size = file_remaining;
    mmap_offset = 0;
}
</pre>
<p class="paragraph">
whileブロックが続く。ループ条件が&quot;off&quot;、つまりオフセット変数になっていることから、これが改行の数をカウントする部分。先にループ脱出条件に関連するコードを見てみる。
<br />
</p>
<pre class="plugin_pre">
while (off) {
    /* ... mmap, 改行検出処理, offのデクリメント ... */

    file_remaining -= mmap_size - mmap_remaining;

    if (off == 0)
            break;

    if (file_remaining == 0)
            break;

    /* ... */
}
</pre>
<p class="paragraph">
改行が検出されるたびにoffがデクリメントされていく。0になればループを抜ける。また、file_remainingはファイルの残りサイズを表すことになるが、それが0 = 逆から調べていき先頭まで到達した場合もループを抜ける。
<br />
ではwhileの中身を見ていく。まずmmap(2)で、while()の前に調整していたmmap_offsetからmmap_size分だけメモリにマッピングし、先頭アドレスをstartに格納する。
<br />
</p>
<pre>start = mmap(NULL, (size_t)mmap_size, PROT_READ,
             MAP_FILE|MAP_SHARED, fileno(fp), mmap_offset);
if (start == MAP_FAILED) {
        err(0, &quot;%s: %s&quot;, fname, strerror(EFBIG));
        return (1);
}
</pre>
<p class="paragraph">
続いて、確保した領域の末尾から逆方向へ1文字ずつ読み進め、改行コードの数をカウントしていく。末尾一文字は改行でもそれ以外でも無視することにしているらしく、for分の初期値で &quot;-1&quot; されている。
<br />
</p>
<pre>mmap_remaining = mmap_size;
/* Last char is special, ignore whether newline or not. */
for (p = start + mmap_remaining - 1 ; --mmap_remaining ; )
        if (*--p == &#039;\n&#039; &amp;&amp; !--off) {
                ++p;
                break;
        }
</pre>
<p class="paragraph">
mmap_remainingというのが、逆方向から読み進めた時の、メモリ上での残りサイズになっている。ということは
<br />
</p>
<pre>メモリ上で逆方向から読み終えたバイト数 = mmap_size - mmap_remaining
</pre>
<p class="paragraph">
となり、
<br />
</p>
<pre>file_remaining -= mmap_size - mmap_remaining;
</pre>
<p class="paragraph">
これにより
<br />
</p>
<pre>file_remaining = mmap(2)で切り出した分を計算に入れた上で、
                 まだ読み終えていないファイルの残りサイズ
</pre>
<p class="paragraph">
となる。
<br />
この後ループを抜けるifブロックが続き(前掲, 省略)、munmap(2)でメモリのマッピングを解除する。
<br />
</p>
<pre>if (munmap(start, mmap_size)) {
    err(0, &quot;%s: %s&quot;, fname, strerror(errno));
    return (1);
}
</pre>
<p class="paragraph">
ログファイル監視で良く使う
<br />
</p>
<pre>tail -f foobar.log
</pre>
<p class="paragraph">
であれば、
<br />
</p>
<pre>off = 10
style = RLINES
</pre>
<p class="paragraph">
となるので、通常のログファイルであればwhileループの１回目で改行を10個検出し、off = 0でループを抜けてしまう。offが非常に大きかったり一行が非常に巨大なログファイルの場合は、以下のif文で次にmmap(2)する領域とオフセットを調整する。
<br />
</p>
<pre>if (mmap_offset &gt;= MMAP_MAXSIZE) {
   /* mmap_offsetがまだMMAP_MAXSIZEを超えている場合は、
      さらにMMAP_MAXSIZE分引く = mmap(2)する先頭をファイルの前方にずらす */
   mmap_offset -= MMAP_MAXSIZE;
} else {
   /* mmap_offsetの値がMMAP_MAXSIZEより小さい場合は、
      次にmmap(2)する領域のサイズがMMAP_MAXSIZE以下になるので、
      mmap_offset = 0 とし、マップするサイズもfile_remaining、
      つまり未読のファイル領域全てにする。 */
   mmap_offset = 0;
   mmap_size = file_remaining;
}
</pre>
<p class="paragraph">
ループを抜けた段階での各種変数の関係は以下のようになる。なお、以下はファイルサイズが数十MBで、なおかつ末尾の10MBブロックだけでは改行を必要な数だけ検出出来ず、さらに前方の10MBブロックでようやく検出してwhileループを抜けた状態をイメージしている。
<br />
</p>
<pre>[file]
- file offset = 0 -----------------------
|                                       ^
(...)                                   |
|                [mmaped space]         |
+-&gt; mmap_offset -+-&gt; start              |
|       ^        |     ^             [file_remaining]
|       |        |     |                |
|       |        |    [mmap_remaining]  |
|    [10MB =     |     |                |
|   mmap_size]   &#039;\n&#039;  v                v
|       |        +------&gt; p -------------
|       |        |
|       v        |
+----------------+
|
(...)
|
- file_offse = file_size
</pre>
<p class="paragraph">
この段階で、「メモリ上は」オフセット位置までずらせた。後は
<br />
</p>
<pre>mmap_size - mmap_remaining
</pre>
<p class="paragraph">
で、メモリ上のpから、mmap(2)したブロックの末尾までのサイズになり、これをWRマクロで出力する。
<br />
</p>
<pre>WR(p, mmap_size - mmap_remaining);
</pre>
<p class="paragraph">
WRマクロはextern.hにて定義されている。
<br />
</p>
<pre>#define WR(p, size) \
    if (write(STDOUT_FILENO, p, size) != size) \
        oerr();
</pre>
<p class="paragraph">
そしてファイルポインタ側のオフセットを計算する。既に&quot;mmap_size - mmap_remaining&quot;分のデータはWRで出力したので、その分だけfile_remainingに加算すれば良い。
<br />
</p>
<pre>file_remaining += mmap_size - mmap_remaining;
</pre>
<p class="paragraph">
whileループを抜けるbreakは、munmap()を処理していない段階で抜けてしまう。そのためmunmap()をこちらで呼び、メモリマッピングを解放する。
<br />
</p>
<pre>if (munmap(start, mmap_size)) {
        err(0, &quot;%s: %s&quot;, fname, strerror(errno));
        return (1);
}
</pre>
<p class="paragraph">
最後にfseeko(3)で、ファイルポインタ側のオフセット位置を設定する。
<br />
</p>
<pre>if (fseeko(fp, file_remaining, SEEK_SET) == -1) {
    ierr();
    return (1);
}
</pre>

<p class="paragraph">
以上でrlines()のソースは読み解けた。なお、上で示した例のように、数十MBを超えるファイルで改行数や一行のサイズが巨大だった場合、rlines()を抜けた段階では最後にmmap(2)したエリアまでしか出力していないことになる：
<br />
</p>
<pre>[file]
- file offset = 0 -----------------------
|                                       ^
(...)                                   |
|                [mmaped space]         |
+-&gt; mmap_offset -+-&gt; start              |
|       ^        |     ^             [file_remaining]
|       |        |     |                |
|       |        |    [mmap_remaining]  |
|    [10MB =     |     |                |
|   mmap_size]   &#039;\n&#039;  v                |
|       |        +------&gt; p ------------|----+
|       |        |                      |    |&lt;- この領域がWR()されている。
|       v        |                      v    |
+----------------+--------+-------------+&lt;- ファイルポインタはココにfseeko(3)される
|                         |
(...)                     |&lt;- 【領域Ａ】この領域はWR()されていない！
|                         |
- file_offse = file_size -+
</pre>

<p class="paragraph">
【領域Ａ】は、forward()関数のソースに戻り読み進めていくとちゃんと出力されることが分かる。
<br />
</p>

<h3 id="id9cc6f5">forward.cのforward()関数の探検（再開）</h3>

<p class="paragraph">
forward()関数のソースへ戻る。オフセット位置を調整するswitchブロックに続くのは、forループになる。
<br />
</p>
<pre class="plugin_pre">
for (;;) {
    while ((ch = getc(fp)) != EOF)  {
        if (putchar(ch) == EOF)
            oerr();
    }
    if (ferror(fp)) {
        ierr();
        return;
    }
    (void)fflush(stdout);
    if (!fflag)
        break;
</pre>
<p class="paragraph">
最初のwhile()で、【領域Ａ】の分が出力される事になる。また&quot;-f&quot;or&quot;-F&quot;が指定されていない(= fflagが0)の場合はこれでforループを抜け、処理を終了している。
<br />
</p>

<p class="paragraph">
&quot;-f&quot;又は&quot;-F&quot;が指定されている場合は、引き続きループ内の処理を続行する。
<br />
まず&quot;-f&quot;が指定された場合は fflag = 1 となるため、以下のifブロックに進む。
<br />
</p>
<pre class="plugin_pre">
second.tv_sec = 1;
second.tv_usec = 0;
if (select(0, NULL, NULL, NULL, &amp;second) == -1)
        err(1, &quot;select: %s&quot;, strerror(errno));
clearerr(fp);

if (fflag == 1)
        continue;
</pre>
<p class="paragraph">
コメントにも書かれているが、select(2)で1秒間waitを入れた後、continueする。
<br />
</p>

<p class="paragraph">
&quot;-F&quot;が指定された場合は fflag = 2 となっているので、continueせずに下の処理に進む。
<br />
</p>
<pre class="plugin_pre">
if (dostat &gt; 0)  {
    dostat -= 1;
} else {
    dostat = 5;
    if (stat(fname, &amp;statbuf) == 0)  {
        if (statbuf.st_dev != lastdev ||
            statbuf.st_ino != lastino ||
            statbuf.st_size &lt; lastsize)  {
            /* ファイル名変更やinodeが変わった場合、
               fclose()した後もう一度fopen()しなおす処理 */
        } else {
                lastsize = statbuf.st_size;
        }
    }
}
</pre>
<p class="paragraph">
これにより、&quot;-F&quot;オプションによる「5秒間隔でチェック→ファイル名変更/inode変更に応じたファイルの再読込」が実現されている。
<br />
</p>

<p class="paragraph">
以上でtail(1)での&quot;-f&quot;オプションの挙動を解析出来た。
<br />
</p>

<p class="paragraph">
今回のお題については、ここまで。
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-553.html" title="C言語系/「デーモン君のソース探検」読書メモ/09, mv(1)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-555.html" title="C言語系/「デーモン君のソース探検」読書メモ/11, file(1)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-546.html" title="C言語系/「デーモン君のソース探検」読書メモ">Up</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/554<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2007 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>