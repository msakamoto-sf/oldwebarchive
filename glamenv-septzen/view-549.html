<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>C言語系/「デーモン君のソース探検」読書メモ/07, clear(1) - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">C言語系/「デーモン君のソース探検」読書メモ/07, clear(1)</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-01-12 18:50:29 &nbsp; / &nbsp; last updated at: 2010-01-12 18:55:17<br>
カテゴリ: <a href="category-32.html">BSD</a>&nbsp;<a href="category-10.html">C言語</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-547.html" title="C言語系/「デーモン君のソース探検」読書メモ/06, factor(1)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-550.html" title="C言語系/「デーモン君のソース探検」読書メモ/08, test(1)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
お題：&quot;clear&quot;コマンドの中身を追跡せよ。
<br />
</p>



<ul><li><a href="#id03ec78">clearの実体はtputコマンド</a><ul><li><a href="#id837cef">tput.c の main()関数前半を追ってみる。</a></li>
<li><a href="#id3abd10">&quot;term～&quot;の整理</a></li>
<li><a href="#id73a6ef">tput.c の main()関数後半を追ってみる。</a></li>
<li><a href="#idb47f5f">tput.c の process()関数を追ってみる。</a></li></ul></li>
<li><a href="#id267965">tgetent(), tgetstr()の小さな謎とソース探検</a></li></ul>
<hr />
<h3 id="id03ec78">clearの実体はtputコマンド</h3>

<p class="paragraph">
clearは端末画面をクリアするコマンド。その中身を調べてみる。
<br />
まずはソースコードを探す。
<br />
</p>
<pre>$ locate clear
...
/usr/bin/clear
...
/usr/src/usr.bin/tput/clear.sh
</pre>
<p class="paragraph">
「デーモン君のソース探検」にも書かれているとおり、本体がtputというプログラムで、clearコマンド自体はtputを呼び出すシェルスクリプトになっている。
<br />
</p>
<pre>$ which tput
/usr/bin/tput
$ file /usr/bin/tput
/usr/bin/tput: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), \
for NetBSD, dynamically linked (uses shared libs), stripped
</pre>

<pre>$ which clear
/usr/bin/clear
$ file /usr/bin/clear
/usr/bin/clear: Bourne shell script text executable
</pre>

<pre>$ cat /usr/bin/clear
#!/bin/sh -
#       $NetBSD: clear.sh,v 1.2 1994/12/07 08:49:09 jtc Exp $
(...)
exec tput clear
</pre>
<p class="paragraph">
clearシェルスクリプトでは、&quot;clear&quot;というコマンドライン引数を指定してtputを実行している。
<br />
ここからtputのソース探索に進む。
<br />
</p>
<pre>$ cd /usr/src/usr.bin/tput/
$ ls
CVS/      Makefile  clear.sh  tput.1    tput.c
</pre>

<p class="paragraph">
tput.cの主要関数はmain()とprocess()の二つ。それぞれ、少しずつソースを追っていきたい。
<br />
</p>

<h4 id="id837cef">tput.c の main()関数前半を追ってみる。</h4>

<p class="paragraph">
まずmain()から見ていく。
<br />
</p>
<pre class="plugin_pre">
int
main(argc, argv)
        int argc;
        char **argv;
{
        int ch, exitval, n;
        char *cptr, *p, *term, buf[1024], tbuf[1024];

        term = NULL;
        while ((ch = getopt(argc, argv, &quot;T:&quot;)) != -1)
                switch(ch) {
                case &#039;T&#039;:
                        term = optarg;
                        break;
                case &#039;?&#039;:
                default:
                        usage();
                }
        argc -= optind;
        argv += optind;

        if (!term &amp;&amp; !(term = getenv(&quot;TERM&quot;)))
errx(2, &quot;no terminal type specified and no TERM environmental variable.&quot;);
        if (tgetent(tbuf, term) != 1)
                err(2, &quot;tgetent failure&quot;);
        setospeed();
</pre>
<p class="paragraph">
まず変数の定義に続き、getopt()による引数解析。続いて端末名を取得する。コマンドライン引数で指定されていなければ&quot;TERM&quot;環境変数から取得している。ちなみにWindowsXPからputtyを使いSSHでログインし、ログインシェルがbashの状態では、&quot;TERM&quot;環境変数には &quot;xterm&quot; が設定されていた。
<br />
そして tgetent() にてtermcapデータベースから端末名のエントリをロードする。
<br />
続いて setospeed() という関数を呼び出している。これはtput.c内で定義されたstatic関数で、次のようになっている。
<br />
</p>
<pre class="plugin_pre">
static void
setospeed()
{
#undef ospeed
        extern short ospeed;
        struct termios t;

        if (tcgetattr(STDOUT_FILENO, &amp;t) != -1)
                ospeed = 0;
        else
                ospeed = cfgetospeed(&amp;t);
}
</pre>
<p class="paragraph">
結論から言うと、こちらは端末の出力速度(bps, baud rate)をtermios構造体より取り出し、termcapが公開しているospeed変数にセットしている。
<br />
</p>

<h4 id="id3abd10">&quot;term～&quot;の整理</h4>

<p class="paragraph">
&quot;term～&quot;というのを良く目にするが、今の段階では以下のように整理しておく。
<br />
</p>
<ol><li> termios構造体に関連するのは、端末それ自体に関連する設定と関わる。</li>
<li> termcapやterminfo, curses系は、端末それ自体というよりは端末の&quot;見た目&quot;制御に関わる。カーソル移動や画面クリアなど。</li></ol>

<p class="paragraph">
混乱を避ける為、termcap/terminfo/cursesの変遷について極簡単にまとめておく。
<br />
</p>
<ol><li> termcapというのは&quot;terminal capability&quot;の略。元々はBSDでviを作る為に構築されたデータベースファイルと、それを処理するルーチン群。</li>
<li> その後、viから関連するルーチンが抽出され、cursesライブラリに集約された。</li>
<li> さらにその後、termcapでの問題点を改善したterminfoファイルが構築された。</li>
<li> AT&amp;T System V UNIX Release 2.0 (SVR2)では、termcapの機能がterminfoに置き換えられた。</li>
<li> 以上のような流れで、歴史的にはSystemV系はterminfoを使い、BSD系はtermcapを使う流れが出来上がった。現在はSystemV/BSD系ともに、termcap/terminfo両方をサポートするようになっている。(Mac OS Xについては定かではない)</li></ol>

<p class="paragraph">
&quot;terminal capability&quot;という名前から分かるように、termcap/terminfoは端末それ自体の制御は行えず、「その端末で何が出来るか、それをするにはどういう制御文字を出力すればいいのか」というデータベースライブラリとなっている。
<br />
詳細は、以下のman/Wikipedia/書籍を参照。
<br />
</p>
<ul><li> &quot;termios&quot;関連<ul><li> man 4 termios</li>
<li> man 3 tcsetattr</li></ul></li>
<li> &quot;termcap&quot;, &quot;terminfo&quot;, &quot;curses&quot;<ul><li> man 3 termcap</li>
<li> man 5 termcap</li>
<li> man 5 terminfo</li>
<li> man 3 curses</li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Termcap" target="_blank">http://en.wikipedia.org/wiki/Termcap</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Terminfo" target="_blank">http://en.wikipedia.org/wiki/Terminfo</a></li>
<li> <a class="externallink" href="http://en.wikipedia.org/wiki/Curses_%28programming_library%29" target="_blank">http://en.wikipedia.org/wiki/Curses_%28programming_library%29</a></li>
<li> <a href="https://www.amazon.co.jp/dp/0937175226" target="_blank">Termcap and Terminfo (Nutshell Handbooks)</a></li></ul></li></ul>

<h4 id="id73a6ef">tput.c の main()関数後半を追ってみる。</h4>

<p class="paragraph">
main()関数の続きに戻る。
<br />
</p>
<pre class="plugin_pre">
  for (exitval = 0; (p = *argv) != NULL; ++argv) {
    switch (*p) {
    case &#039;c&#039;:
      if (!strcmp(p, &quot;clear&quot;))
        p = &quot;cl&quot;;
      break;
    case &#039;i&#039;:
      if (!strcmp(p, &quot;init&quot;))
        p = &quot;is&quot;;
      break;
    case &#039;l&#039;:
      if (!strcmp(p, &quot;longname&quot;)) {
        prlongname(tbuf);
        continue;
      }
      break;
    case &#039;r&#039;:
      if (!strcmp(p, &quot;reset&quot;))
        p = &quot;rs&quot;;
      break;
    }
    cptr = buf;
    if (tgetstr(p, &amp;cptr))
      argv = process(p, buf, argv);
    else if ((n = tgetnum(p)) != -1)
      (void)printf(&quot;%d\n&quot;, n);
    else
      exitval = !tgetflag(p);

    if (argv == NULL)
      break;
  }
  exit(argv ? exitval : 2);
}
</pre>
<p class="paragraph">
まずforループの中のswitchブロックは、&quot;clear&quot;/&quot;init&quot;/&quot;longname&quot;/&quot;reset&quot;という、tputのmanページにも書かれている特殊な引数の処理になっている。&quot;clear&quot;は&quot;cl&quot;という文字列に変換されることが分かる。
<br />
変換された文字列は&quot;p&quot;というcharポインタに格納され、tgetstr(),tgetnum(),tgetflag()の順にtermcapエントリの中での設定を調べていく。pが指す文字列は、termcapにおいては &quot;capability&quot; と呼ばれ、その端末で使える機能を英数字2文字の組み合わせで指定することになっている。&quot;cl&quot;だと以下のcapabilityが指定されたことになる。
<br />
</p>
<pre>clear_screen            cl      画面を消去しカーソルをホームに移動 (P*)
</pre>
<p class="paragraph">
他にも、capabilityにはブール値, 数値, 文字列型という分類があるが今回はそこまでは踏み込まない。
<br />
&quot;cl&quot;は &quot;man 5 termcap&quot; によると文字列型である。そこで実際にtermcapファイルを調べ、xtermでのエントリからclを探してみる。
<br />
</p>

<p class="paragraph">
/usr/share/misc/termcap:
<br />
</p>
<pre>x10term|vs100-x10|xterm terminal emulator (X10 window system):\
        :am:bs:km:mi:ms:xn:xo:\
        :co#80:it#8:li#65:\
        :AL=\E[%dL:DC=\E[%dP:DL=\E[%dM:RA=\E[?7l:SA=\E[?7h:\
        :al=\E[L:cd=\E[J:ce=\E[K:cl=\E[H\E[2J:cm=\E[%i%d;%dH:...
        ...                      ^^^^^^^^^^^^
</pre>
<p class="paragraph">
ここから、&quot;cl&quot;というcapabilityを使うには、xtermにおいては次のエスケープシーケンスを出力すればよいと予想出来る。
<br />
</p>
<pre>\E[H\E[2J
</pre>
<p class="paragraph">
実際にprintf(1)を使うと簡単に確認出来た。
<br />
</p>
<pre>$ printf &quot;\e[H\e[2J&quot;
</pre>

<h4 id="idb47f5f">tput.c の process()関数を追ってみる。</h4>

<p class="paragraph">
実際にエスケープシーケンスを出力しているのは、tput.c中の process() 関数になる。
<br />
</p>
<pre class="plugin_pre">
static char **
process(cap, str, argv)
        char *cap, *str, **argv;
{
  /* errXXXX系は省略 */
  char *cp;
  int arg_need, arg_rows, arg_cols;

  /* Count how many values we need for this capability. */
  for (cp = str, arg_need = 0; *cp != &#039;\0&#039;; cp++)
    if (*cp == &#039;%&#039;)
      switch (*++cp) {
      case &#039;d&#039;:
      case &#039;2&#039;:
      case &#039;3&#039;:
      case &#039;.&#039;:
      case &#039;+&#039;:
        arg_need++;
        break;
      case &#039;%&#039;:
      case &#039;&gt;&#039;:
      case &#039;i&#039;:
      case &#039;r&#039;:
      case &#039;n&#039;:
      case &#039;B&#039;:
      case &#039;D&#039;:
        break;
      default:
        /*
         * hpux has lot&#039;s of them, but we complain
         */
         errx(2, erresc, *cp, cap);
      }
</pre>
<p class="paragraph">
まずローカル変数を定義した後、forループでcapabilityが必要としている引数の数をカウントしている。
<br />
たとえばカーソルを移動させるcapability(ex:&quot;cm&quot;)は行と桁の二つの数字を必要としている。そしてcmを例に挙げると、xtermでは以下のようになっている。
<br />
</p>
<pre>cm=\E[%i%d;%dH
</pre>
<p class="paragraph">
このうち &quot;%d&quot; が引数で渡された数字が入るようになっているので、&quot;cm&quot;が必要とする引数は2つになる。他にも&quot;%&quot;始まりで数字を指定出来るようになっており、その仕掛けを使って引数の数をカウントしているのが上のifブロックに続くswitchブロックになる。
<br />
引数を渡すにはこの後で出てくる tgoto() を使う。そして tgoto() では数値を2つ渡せるようになっている。すなわち、続く次のコードのように引数の数は0から2までとなる。
<br />
</p>
<pre class="plugin_pre">
  /* And print them. */
  switch (arg_need) {
  case 0:
    (void)tputs(str, 1, outc);
    break;
  case 1:
    arg_cols = 0;

    if (*++argv == NULL || *argv[0] == &#039;\0&#039;)
      errx(2, errfew, 1, cap);
    arg_rows = atoi(*argv);

    (void)tputs(tgoto(str, arg_cols, arg_rows), 1, outc);
    break;
  case 2:
    if (*++argv == NULL || *argv[0] == &#039;\0&#039;)
      errx(2, errfew, 2, cap);
    arg_rows = atoi(*argv);

    if (*++argv == NULL || *argv[0] == &#039;\0&#039;)
      errx(2, errfew, 2, cap);
    arg_cols = atoi(*argv);

    (void) tputs(tgoto(str, arg_cols, arg_rows), arg_rows, outc);
    break;

  default:
    errx(2, errmany, arg_need, cap);
  }
  return (argv);
}
</pre>
<p class="paragraph">
上のswitchブロックで数値を0個、1個、2個とる場合に分け、1個以上の場合はargvからatoi()を使って数値を取り出している。
<br />
その後、数値を使う場合は一旦tgoto()を挟んだ後、tputs()を使って出力している。
<br />
</p>

<p class="paragraph">
例えば&quot;clear&quot;コマンドの場合はcapabilityは&quot;cl&quot;という文字列型になり、その値は
<br />
</p>
<pre>\E[H\E[2J
</pre>
<p class="paragraph">
である。これには数値引数が含まれていないので、上のswitchブロックでは0個のcaseを通り、tputs()を通じて出力される。tputs()の最後の引数は関数ポインタになっており、ここではtput.c内で定義されている次のstatic関数を渡している。
<br />
</p>
<pre class="plugin_pre">
static int
outc(c)
        int c;
{
        return (putchar(c));
}
</pre>

<p class="paragraph">
以上で&quot;clear&quot;コマンドが画面をクリアするエスケープシーケンスを出力する仕組みを解明することができた。
<br />
</p>

<h3 id="id267965">tgetent(), tgetstr()の小さな謎とソース探検</h3>

<p class="paragraph">
ここで少し寄り道し、tgetent()やtgetstr()で取得される文字列の中身を見てみようと思う。tputのソース一式をホームディレクトリ以下にコピーし、端末名取得, tgetent(), tgetstr()の直後で関連する値を表示させてみる。
<br />
</p>
<pre>DEBUG: term=[xterm]
DEBUG: tbuf=[xterm|vs100|xterm terminal emulator (X Window System)\
:am:bs:km:mi:ms:ut:xn:co#80:it#8:li#24:Co#8:pa#64:AB=\E[4%dm\
...
:cl=\E[H\E[2J:cm=\E[%i%d;%dH:...
DEBUG: cptr=buf=[ESC[HESC[2J]
</pre>
<p class="paragraph">
tgetent(), tgetstr()の動作を実際に確認することが出来た。
<br />
</p>

<p class="paragraph">
ここで、「デーモン君のソース探検」で一つの疑問が呈示される。
<br />
tput.cでは、tgetent()にて&quot;tbuf&quot;変数にエントリ内容が保存されている。
<br />
</p>
<pre>if (tgetent(tbuf, term) != 1)
    err(2, &quot;tgetent failure&quot;);
</pre>
<p class="paragraph">
一方、続くtgetstr()では保存されたtbuf変数が引数にあらわれていない。
<br />
</p>
<pre>cptr = buf;
if (tgetstr(p, &amp;cptr))
    argv = process(p, buf, argv);
</pre>
<p class="paragraph">
ではtgetstr()は端末のエントリをどこから読み込んでいるのか？
<br />
</p>

<p class="paragraph">
これを調べる為、tgetent(), tgetstr()のソースを読んでみる。
<br />
</p>

<p class="paragraph">
$ locate tgetent
<br />
/usr/share/man/cat3/tgetent.0
<br />
/usr/share/man/man3/tgetent.3
<br />
$ locate tgetstr
<br />
/usr/share/man/cat3/tgetstr.0
<br />
/usr/share/man/man3/tgetstr.3
<br />
ハズレである。ここで、&quot;man 3 termcap&quot;をもう一度見直してみると
<br />
</p>
<pre>LIBRARY
     Termcap Access Library (libtermcap, -ltermcap)
</pre>
<p class="paragraph">
とある。そこで、単純に &quot;termcap&quot; でlocateしてみると &quot;/usr/src/lib/libterm&quot; というディレクトリが見つかる。
<br />
</p>
<pre>$ locate termcap
...
/usr/src/lib/libterm/termcap.3
/usr/src/lib/libterm/termcap.c
...
</pre>
<p class="paragraph">
中を見てみるといかにもそれらしきソースファイルが揃っている。
<br />
</p>
<pre>$ cd /usr/src/lib/libterm/
$ ls
CVS/
Makefile
TEST/
pathnames.h
shlib_version
termcap.3
termcap.c
termcap.h
termcap_private.h
tgoto.c
tputs.c
</pre>
<p class="paragraph">
grepしてみる。
<br />
</p>
<pre>$ grep tgetent *.c
termcap.c: * tgetent only in a) the buffer is malloc&#039;ed for the caller and
termcap.c:tgetent(bp, name)
</pre>
<p class="paragraph">
termcap.cを見てみると、tgetent(), tgetstr()両方とも定義されていた。
<br />
</p>
<pre class="plugin_pre">
int
tgetent(bp, name)
        char *bp;
        const char *name;
{
        int i, plen, elen, c;
        char *ptrbuf = NULL;

        i = t_getent(&amp;fbuf, name);

        if (i == 1) {
                /* ... */
                strcat(bp, ptrbuf);
                tbuf = bp;
</pre>
<p class="paragraph">
tgetent()を見てみると、t_getent()にてファイルstaticなtinfo構造体 &quot;fbuf&quot; に情報を格納した後、引数で渡されたbpにエントリ内容をコピーし、最後にtbufにポインタをコピーしている。
<br />
</p>
<pre>tbuf = bp;
</pre>
<p class="paragraph">
tbufというのもファイルstaticなcharポインタである。
<br />
</p>
<pre>static char *tbuf = NULL;               /* termcap buffer */
static struct tinfo *fbuf = NULL;       /* untruncated termcap buffer */
</pre>

<p class="paragraph">
続いてtgetstr()を見てみると、fbufをそのまま、あるいはtbufをダミーのtinfo構造体にセットして t_getstr() に委譲していることが分かる。
<br />
</p>
<pre class="plugin_pre">
char *
tgetstr(id, area)
        const char *id;
        char **area;
{
        struct tinfo dummy;
        char ids[3];

        /* ... */

        if ((id[0] == &#039;Z&#039;) &amp;&amp; (id[1] == &#039;Z&#039;)) {
                dummy.info = tbuf;
                return t_getstr(&amp;dummy, ids, area, NULL);
        }
        else
                return t_getstr(fbuf, ids, area, NULL);
}
</pre>
<p class="paragraph">
このように、tgetent()した段階でtermcap.c内のグローバル変数 tbuf, fbuf に内容がコピーされ、tgetstr()はそこからcapabilityの内容を調べている。これが、tput.cのmain()関数でtgetent()で取得したバッファ領域をtgetstr()に渡さなくとも動作する理由である。
<br />
</p>

<p class="paragraph">
今回のお題については、ここまで。
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-547.html" title="C言語系/「デーモン君のソース探検」読書メモ/06, factor(1)">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-550.html" title="C言語系/「デーモン君のソース探検」読書メモ/08, test(1)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-546.html" title="C言語系/「デーモン君のソース探検」読書メモ">Up</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/549<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2007 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>