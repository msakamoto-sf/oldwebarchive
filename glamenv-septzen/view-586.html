<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>C言語系/memos/VC++/03, UNICODE対応とtchar.h - Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</title>
<!-- favicon 2017's reference:
https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/
https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx
https://developer.chrome.com/multidevice/android/installtohomescreen
https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html
-->
<link rel="shortcut icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="icon" href="../favicons/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="../favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="../favicons/favicon-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-160x160.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-196x196.png" sizes="96x96">
<link rel="icon" type="image/png" href="../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../favicons/favicon-32x32.png" sizes="32x32">

<!-- browserconfig.xml : https://msdn.microsoft.com/ja-jp/library/dn455106(v=vs.85).aspx -->
<meta name="msapplication-TileColor" content="#990000">
<meta name="msapplication-TileImage" content="../favicons/mstile-144x144.png">

<!-- these favicon files were generated by https://ao-system.net/favicongenerator/ , thanks!!(2017-02-18) -->

<style type="text/css"></style>

<link href="./css/pcbrowser.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_plugins.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/pcbrowser_wiki.css" rel="stylesheet" type="text/css" media="screen"/>
<link href="./css/print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<!-- body start -->
<div class="body">
<div style="display: inline"><a name="pagetop"></a></div>
<div id="header-wrap">
<img src="./images/logo1.jpg" style="float: left; margin-right: 1em;"/>
<a href="./index.html" title="Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)"><img src="./icons/home.png" alt="home"/>&nbsp;Glamenv-Septzen(ぐらめぬ・ぜぷつぇん)(archive)</a>


<h1 style="margin-bottom: 10px;">C言語系/memos/VC++/03, UNICODE対応とtchar.h</h1>

<div style="clear: both;"></div>
</div><!-- //header-wrap -->

<!-- content-wrap start -->
<div id="content-wrap"><div class="contents_s">

<!-- data_main -->
<div class="data_main">

<div class="data_attrs_pre">
作成日: 2010-02-12 13:46:27 &nbsp; / &nbsp; last updated at: 2010-05-18 20:36:08<br>
カテゴリ: <a href="category-10.html">C言語</a>&nbsp;<a href="category-8.html">Windows</a>&nbsp;</div>

<div class="data_body">
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-584.html" title="C言語系/memos/VC++/02, 共通系リンカオプション">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-587.html" title="C言語系/memos/VC++/04, Win32のEXE,LIB,DLL開発入門(C言語)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
<hr class="full_hr" />

<p class="paragraph">
Visual C++ 2008 Expressn Edition でのC言語のUNICODEサポートについて、Win32コンソールアプリを題材に簡単にまとめる。
<br />
</p>

<p class="paragraph">
※詳細はMSDNを参照して下さい。この記事で題材にしている非UNICODEアプリをUNICODE対応に変更する手順なども、あくまでもサンプルです。MSDNを一次情報として参照して下さい。この記事はあくまでもUNICODE対応を確認する為のメモや実験のまとめで、MSDNの一次情報を代替しません。また、C++/CLR/.NETについてはこの記事では扱いません。
<br />
</p>

<p class="paragraph">
参考MSDN(Express Edition):
<br />
</p>
<ul><li> 「Visual C++」→「一般的なプログラミング手順」→「文字セット」<ul><li> →「Unicodeのサポート」→「wmainの使用」</li>
<li> →「Tchar.h における汎用テキストのマッピング」</li></ul></li>
<li> 「Visual C++」→「リファレンス」→「ライブラリリファレンス」→「カテゴリ別ランタイムルーチン」<ul><li> →「入出力」→「テキスト モードとバイナリ モードの Unicode ストリーム入出力」</li>
<li> →「国際化」→「Unicode: ワイド文字セット」</li>
<li> →「国際化」→「汎用テキスト マップの使用」</li></ul></li>
<li> 「Visual C++」→「リファレンス」→「ライブラリリファレンス」→「汎用テキスト マップ」</li></ul>


<hr />
<ul><li><a href="#id44bc87">tchar.h と &quot;/D UNICODE&quot;, &quot;/D _UNICODE&quot;</a></li>
<li><a href="#id0d0ddd">非UNICODE版Win32コンソールアプリケーションをUNICODE対応させてみるサンプル</a><ul><li><a href="#id17266e">tchar.hの追加とエントリポイント、データ型の修正</a></li>
<li><a href="#ide7223e">&quot;_T()&quot;マクロの適用＋汎用テキストのマッピング用の関数に修正する</a></li>
<li><a href="#id88fe89">ストリーム入出力関数とUNICODEとロケール対応</a></li>
<li><a href="#id6e028d">&quot;UNICODE&quot;と&quot;_UNICODE&quot;, &quot;TCHAR&quot;と&quot;_TCHAR&quot;</a></li></ul></li>
<li><a href="#id5be683">注意点や参考Webページなど</a></li></ul>
<hr />
<h3 id="id44bc87">tchar.h と &quot;/D UNICODE&quot;, &quot;/D _UNICODE&quot;</h3>

<p class="paragraph">
Visual C++ 2008 Express Edition のプロジェクトの新規作成で、ウィザードを使用してWin32プロジェクトを作成すると、デフォルトで次の&quot;/D&quot;オプションがコンパイラオプションに含まれる。
<br />
</p>
<pre>/D &quot;_UNICODE&quot; /D &quot;UNICODE&quot;
</pre>
<p class="paragraph">
これはWin32 アプリケーション ウィザードの [アプリケーションの設定] ページ、[アプリケーションの種類] で何を選んだかに依らない。コンソール/Windows/DLL/スタティックライブラリのいずれの場合も、上記コンパイラオプションがデフォルトで有効になっている。
<br />
</p>

<p class="paragraph">
この定義により、UNICODE対応をサポートする為に Tchar.h が提供しているマクロが使用可能になる。
<br />
また、コンソールとWindowsアプリケーションのテンプレートを見ると、&quot;tchar.h&quot;がインクルードされ、エントリポイントも次のように変化している。
<br />
</p>

<p class="paragraph">
コンソール：
<br />
</p>
<pre>int _tmain(int argc, _TCHAR* argv[])
</pre>

<p class="paragraph">
Windows：
<br />
</p>
<pre>int APIENTRY _tWinMain(HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPTSTR    lpCmdLine,
                    int       nCmdShow)
</pre>

<p class="paragraph">
&quot;_tmain&quot;, &quot;_TCHAR&quot;, &quot;_tWinMain&quot;, &quot;LPTSTR&quot;は Tchar.h により、UNICODE用の適切なエントリポイントや型名に置換される。これらのマクロを活用することで、UNICODE/MBCS/ASCIIを&quot;#define&quot;だけで切り替えることができるようになる。
<br />
</p>

<p class="paragraph">
逆にこの状態で
<br />
</p>
<pre>printf()
</pre>
<p class="paragraph">
のようにASCII用の関数を直接呼ぶと、他はUNICODE/MBCSで処理しているのにそこだけASCIIとして処理する為、UNICODEではNULL文字(\00)が含まれる場合もあるため、おかしな結果になってしまう。
<br />
</p>

<h3 id="id0d0ddd">非UNICODE版Win32コンソールアプリケーションをUNICODE対応させてみるサンプル</h3>

<p class="paragraph">
次のWin32コンソールアプリケーションをUNICODE対応させてみる。
<br />
chartest01.c : ソースコード自体はCP932(Windows-31J)で保存する
<br />
</p>
<pre class="plugin_pre">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char *argv[]) {
	int i = 0;
	for (i = 0; i &lt; argc; i++) {

		printf(&quot;argv[%d] = %s\n&quot;, i, argv[i]);

		if (!strcmp(&quot;foo&quot;, argv[i])) {
			printf(&quot;foo!\n&quot;);
		}

		if (!strcmp(&quot;あああ&quot;, argv[i])) {
			printf(&quot;あいうえお!\n&quot;);
		}
	}
	return 0;
}
</pre>
<p class="paragraph">
とりあえずコンパイル＆実行してみる：
<br />
</p>
<pre class="plugin_pre">
&gt; cl /nologo chartest01.c
chartest01.c

&gt; chartest01 a foo bar foobar あああ
argv[0] = chartest01
argv[1] = a
argv[2] = foo
foo!
argv[3] = bar
argv[4] = foobar
argv[5] = あああ
あいうえお!
</pre>

<h4 id="id17266e">tchar.hの追加とエントリポイント、データ型の修正</h4>

<ol><li> tchar.hをincludeする。</li>
<li> エントリポイントをUNICODE用の&quot;wmain()&quot;関数に変更するが、ここではtchar.hによる汎用テキストマッピング機能を使い、&quot;_tmain()&quot;に修正する。</li>
<li> char, intのデータ型を wchar_t, wint_t に変更するが、同様にtchar.hの汎用テキストマッピング機能を使い、&quot;_TCHAR&quot;, &quot;_TINT&quot; に修正する。</li></ol>

<p class="paragraph">
修正後：chartest02.c
<br />
</p>
<pre class="plugin_pre">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;tchar.h&gt;

int _tmain(int argc, _TCHAR *argv[]) {
(以下同じ)
</pre>

<p class="paragraph">
まず&quot;UNICODE&quot;定義無しでコンパイル＆実行してみる：
<br />
</p>
<pre class="plugin_pre">
&gt; cl /nologo chartest02.c
chartest02.c

&gt; chartest02 a foo bar foobar あああ
argv[0] = chartest02
argv[1] = a
argv[2] = foo
foo!
argv[3] = bar
argv[4] = foobar
argv[5] = あああ
あいうえお!
</pre>
<p class="paragraph">
プリプロセス結果を見てみると、前と変わっていない事が分かる：
<br />
</p>
<pre class="plugin_pre">
&gt; cl /nologo /P chartest02.c
chartest02.c

&gt; type chartest02.i
(...)
typedef char            _TCHAR;
(...)
int main(int argc, _TCHAR *argv[]) {
(...)
</pre>

<p class="paragraph">
では、&quot;UNICODE&quot;, &quot;_UNICODE&quot;定義付でコンパイル＆実行してみる：
<br />
</p>
<pre class="plugin_pre">
&gt; cl /D &quot;UNICODE&quot; /D &quot;_UNICODE&quot; /nologo chartest02.c
chartest02.c
chartest02.c(9) : warning C4133: \
                  &#039;関数&#039; : &#039;_TCHAR *&#039; と &#039;const char *&#039; の間で型に互換性がありません。
chartest02.c(12) : warning C4133: \
                   &#039;関数&#039; : &#039;_TCHAR *&#039; と &#039;const char *&#039; の間で型に互換性がありません。

&gt; chartest02 a foo bar foobar あああ
argv[0] = c
argv[1] = a
argv[2] = f
argv[3] = b
argv[4] = f
argv[5] = B0B0B0
</pre>
<p class="paragraph">
9行/12行で発生しているのはstrcmp()にargvを渡している箇所で、argvがwchar_tになったためと思われる。
<br />
実行結果だが、argv[0]が&quot;c&quot;で終わっている。これはargv[0]がUNICODEになったため、&quot;chartest02.exe&quot;が実際には
<br />
</p>
<pre>c \00 h \00 a \00 ...
</pre>
<p class="paragraph">
となり、cの次のNULLバイトが文字列終端と見なされたことが原因だろう。argv[5]も文字セットの処理がずれてしまっているため「文字化け」を興してしまっている。さらにstrcmp()もUNICODEになった文字列との比較で、「foo」や「あああ」が不一致になってしまっている。
<br />
</p>

<h4 id="ide7223e">&quot;_T()&quot;マクロの適用＋汎用テキストのマッピング用の関数に修正する</h4>

<ol><li> リテラル文字列を&quot;_T()&quot;マクロで囲む。</li>
<li> printf(), strcmp()を汎用テキストのルーチン マップの関数に修正する。<ol><li> printf()は&quot;_tprintf()&quot;に対応するが、書式文字列などセキュリティ強化された&quot;_tprintf_s()&quot;に直す。</li>
<li> strcmp()は&quot;_tcscmp()&quot;に修正する。</li></ol></li></ol>

<p class="paragraph">
修正後：chartest03.c:
<br />
</p>
<pre class="plugin_pre">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;tchar.h&gt;

int _tmain(int argc, _TCHAR *argv[]) {
	int i = 0;
	for (i = 0; i &lt; argc; i++) {

		_tprintf_s(_T(&quot;argv[%d] = %s\n&quot;), i, argv[i]);

		if (!_tcscmp(_T(&quot;foo&quot;), argv[i])) {
			_tprintf_s(_T(&quot;foo!\n&quot;));
		}

		if (!_tcscmp(_T(&quot;あああ&quot;), argv[i])) {
			_tprintf_s(_T(&quot;あいうえお!\n&quot;));
		}
	}
	return 0;
}
</pre>

<p class="paragraph">
コンパイル＆実行：
<br />
</p>
<pre class="plugin_pre">
&gt; cl /D &quot;UNICODE&quot; /D &quot;_UNICODE&quot; /nologo chartest03.c
chartest03.c

&gt; chartest03 a foo bar foobar あああ
argv[0] = chartest03
argv[1] = a
argv[2] = foo
foo!
argv[3] = bar
argv[4] = foobar
argv[5] = ???
</pre>
<p class="paragraph">
日本語を除く箇所についてはうまく動き出した。
<br />
日本語の問題についてはひとまず置いておき、プリプロセス結果を確認してみる：
<br />
</p>
<pre class="plugin_pre">
&gt; cl /D &quot;UNICODE&quot; /D &quot;_UNICODE&quot; /P /nologo chartest03.c
chartest03.c

&gt; chartest03.i
(...)
typedef wchar_t     _TCHAR;
(...)
int wmain(int argc, _TCHAR *argv[]) {
	int i = 0;
	for (i = 0; i &lt; argc; i++) {

		wprintf_s(L&quot;argv[%d] = %s\n&quot;, i, argv[i]);

		if (!wcscmp(L&quot;foo&quot;, argv[i])) {
			wprintf_s(L&quot;foo!\n&quot;);
		}

		if (!wcscmp(L&quot;あああ&quot;, argv[i])) {
			wprintf_s(L&quot;あいうえお!\n&quot;);
		}
	}
	return 0;
}
</pre>
<p class="paragraph">
それぞれ適切なUNICODE用関数に置換されていることが確認できた。
<br />
</p>

<h4 id="id88fe89">ストリーム入出力関数とUNICODEとロケール対応</h4>

<p class="paragraph">
printf()はストリーム入出力関数に分類される。関連する関数の説明は、以下のMSDNから辿ることができる。
<br />
</p>
<pre>「Visual C++」→「リファレンス」→「ライブラリリファレンス」→
  「カテゴリ別ランタイムルーチン」→「入出力」
</pre>
<p class="paragraph">
この中の「テキスト モードとバイナリ モードの Unicode ストリーム入出力」では、テキストモードで開かれたファイルに対してUNICODE対応のストリーム入出力関数を使うと、mbtowc()/wctomb()が呼び出されたかのようにしてUNICODEとマルチバイト文字セットへの変換が行われるという記述が見つかった。
<br />
今回はwprintf_s()を使っている、出力部分でおかしくなっている。そこで、UNICODE→マルチバイト文字セットへの変換について調べる為wctomb()(関数名から、UNICODE:ワイド文字列からマルチバイト文字セットへ変換する関数だろうと&quot;アタリ&quot;をつけた)のMSDNを確認してみる。
<br />
すると次のような記述が見つかった：
<br />
</p>
<pre>wctomb 関数は、すべてのロケールに依存する動作に現在のロケールを使用します。
</pre>
<p class="paragraph">
ここから、適切なロケールが設定されていない為に wctomb() が &quot;???&quot; に変換しているのではないか、と推測される。
<br />
</p>

<p class="paragraph">
ロケール関連のMSDNを調べると、次のような記述が見つかった：
<br />
</p>
<ul><li> 「setlocale、_wsetlocale」：</li></ul>
<pre>プログラムの起動時に、次のステートメントと同等の処理が実行されます。

setlocale( LC_ALL, &quot;C&quot; );
</pre>

<ul><li> 「カテゴリ別ランタイム ルーチン」→「国際化」→「コード ページ」:</li></ul>
<pre>既定では、Microsoft ランタイム ライブラリにあるロケール依存のルーチンはすべて、
&quot;C&quot; ロケールに対応するコード ページを使用します。
</pre>

<p class="paragraph">
ここから、プログラム起動時はデフォルトで&quot;C&quot;ロケールになっており、これを日本語用のロケールに変更すればwctomb()が適切に動作すると予想される。
<br />
</p>

<p class="paragraph">
そこで、まずsetlocale()で「プログラム起動時のロケール」を確認するテストプログラムを作ってみる。
<br />
</p>

<p class="paragraph">
getlocale.c:
<br />
</p>
<pre class="plugin_pre">
#include &lt;stdio.h&gt;
#include &lt;locale.h&gt;
#include &lt;mbctype.h&gt;

int main() {
	char *l;
	int cp;

	/* プログラム起動直後のロケールを取得 */
	l = setlocale(LC_ALL, NULL);
	if (NULL == l) {
		printf(&quot;error.\n&quot;);
		return 1;
	} else {
		printf(&quot;LC_ALL = %s\n&quot;, l);
	}
	/* プログラム起動直後のコードページを取得 */
	cp = _getmbcp();
	printf(&quot;CodePage = %d\n&quot;, cp);

	/* ロケールを変更
	 * - 言語：日本
	 * - 国：日本
	 * - コードページはシステムデフォルト
	 */
	l = setlocale(LC_ALL, &quot;japanese_jpn&quot;);
	if (NULL == l) {
		printf(&quot;error.\n&quot;);
		return 1;
	} else {
		printf(&quot;LC_ALL = %s\n&quot;, l);
	}

	/* ロケール変更後のコードページを取得 */
	cp = _getmbcp();
	printf(&quot;CodePage = %d\n&quot;, cp);
	return 0;
}
</pre>
<p class="paragraph">
コンパイル＆実行：
<br />
</p>
<pre class="plugin_pre">
&gt; cl getlocale.c
Microsoft(R) 32-bit C/C++ Optimizing Compiler Version 15.00.30729.01 for 80x86
Copyright (C) Microsoft Corporation.  All rights reserved.

getlocale.c
Microsoft (R) Incremental Linker Version 9.00.30729.01
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:getlocale.exe
getlocale.obj

&gt; getlocale.exe
LC_ALL = C
CodePage = 932
LC_ALL = Japanese_Japan.932
CodePage = 932
</pre>
<p class="paragraph">
コードページは932になっているが、ロカールはデフォルトで&quot;C&quot;になっていることが確認出来た。またsetlocale()により日本語ロケールに変更出来ることも確認出来た。
<br />
</p>

<p class="paragraph">
以上の確認を踏まえ、setlocale(LC_ALL, &quot;japanese_jpn&quot;)を最初に呼ぶようにしてみる。また、&quot;setlocale()&quot;も汎用テキストマッピングの&quot;_tsetlocale()&quot;に変更する。
<br />
</p>

<p class="paragraph">
chartest04.c:(ソースファイルはWindows-31Jで保存されている)
<br />
</p>
<pre class="plugin_pre">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;tchar.h&gt;
#include &lt;locale.h&gt;

int _tmain(int argc, _TCHAR *argv[]) {
	int i = 0;

	if (NULL == _tsetlocale(LC_ALL, _T(&quot;japanese_jpn&quot;))) {
		_tprintf_s(_T(&quot;error.\n&quot;));
		return 1;
	}

	for (i = 0; i &lt; argc; i++) {

		_tprintf_s(_T(&quot;argv[%d] = %s\n&quot;), i, argv[i]);

		if (!_tcscmp(_T(&quot;foo&quot;), argv[i])) {
			_tprintf_s(_T(&quot;foo!\n&quot;));
		}

		if (!_tcscmp(_T(&quot;あああ&quot;), argv[i])) {
			_tprintf_s(_T(&quot;あいうえお!\n&quot;));
		}
	}
	return 0;
}
</pre>
<p class="paragraph">
コンパイル＆実行：
<br />
</p>
<pre class="plugin_pre">
&gt; cl /D &quot;UNICODE&quot; /D &quot;_UNICODE&quot; /nologo chartest04.c
chartest04.c

&gt; chartest04 a foo bar foobar あああ
argv[0] = chartest04
argv[1] = a
argv[2] = foo
foo!
argv[3] = bar
argv[4] = foobar
argv[5] = あああ
あいうえお!
</pre>

<p class="paragraph">
予想通り、ロケールを日本語に設定することで、UNICODE対応のストリーム入出力関数が正常にマルチバイト文字セットに変換できるようになった事を確認出来た。&quot;&gt;&quot;を使えば、Windows-31J文字コードのファイルとして文字化けすることなく保存される。
<br />
</p>

<p class="paragraph">
OSのロケールに合わせる場合は、setlocale()の第二引数を空文字列にする。
<br />
</p>
<pre>setlocale(LC_ALL, &quot;&quot;);
</pre>
<p class="paragraph">
日本語のWindowsの場合は、こちらでも問題ない。
<br />
</p>

<h4 id="id6e028d">&quot;UNICODE&quot;と&quot;_UNICODE&quot;, &quot;TCHAR&quot;と&quot;_TCHAR&quot;</h4>

<p class="paragraph">
Win32APIおよびVC++で提供されるUNICODE機能を調べていくと、&quot;UNICODE&quot;と&quot;_UNICODE&quot;, &quot;TCHAR&quot;と&quot;_TCHAR&quot;というように紛らわしいキーワードにぶつかる。これについては以下のように区別できる。
<br />
</p>
<dl>
<dt> UNICODE, TCHAR </dt>
<dd>Win32API関連のヘッダーファイル経由</dd>
<dt> _UNICODE, _TCHAR </dt>
<dd>C RunTime library(CRT) ヘッダーファイル経由</dd>
</dl>

<p class="paragraph">
従って、純粋にWin32API「だけ」で構成するのであれば&quot;UNICODE&quot;をdefineし、文字列型としては&quot;TCHAR&quot;を使えばよい。
<br />
&quot;strlen&quot;などCRTで提供されている関数を利用するのであれば&quot;_UNICODE&quot;をdefineし、文字列型としては&quot;_TCHAR&quot;を使う。
<br />
一般的なプログラミングではWin32APIとCRT両方を用いることになるので、&quot;UNICODE&quot;, &quot;_UNICODE&quot;の両方をdefineした上で、TCHAR/_TCHARについては好きな方を使えばよい。
<br />
2010年5月現在のVC++2008 Express Edition上では、TCHAR/_TCHARとも、UNICODE/_UNICODEのdefine切り替えに応じてchar/wchar_tにそれぞれ切り替わるため、プリプロセス結果としてはTCHAR/_TCHARのどちらを使っても構わない。
<br />
</p>

<h3 id="id5be683">注意点や参考Webページなど</h3>

<p class="paragraph">
VC++2008のUNICODE対応については、こちらでも丁寧にまとめられています：
<br />
</p>
<ul><li> Visual C++のUNICODE対応<ul><li> <a class="externallink" href="http://yy2.sakura.ne.jp/006_vccp_unicode/vcpp_unicode.html" target="_blank">http://yy2.sakura.ne.jp/006_vccp_unicode/vcpp_unicode.html</a></li></ul></li></ul>

<p class="paragraph">
コンソール出力関数を使うとsetlocale()無しでも問題ない・・・というのは自分も確認しました。&quot;_tcprintf, _tcprintf_s&quot;関数を使えば、setlocale()無しでも文字化けしません。ただし、やはり「コンソールのロケールがOSのロケールと一緒」という記載が見つからないんですよね・・・。コンソール出力関数のデフォルトロケールに依存するコードは避けた方が良いのかな・・・。
<br />
</p>

<p class="paragraph">
VC++2005の時の話題ですが、日本語PATH名やC++のIOストリームが絡むとややこしくなるようです：
<br />
</p>
<ul><li> 日本語PATH文字化け<ul><li> <a class="externallink" href="http://social.msdn.microsoft.com/Forums/ja-JP/vcexpressja/thread/4cd48e70-4789-419d-b958-87d5f6236113" target="_blank">http://social.msdn.microsoft.com/Forums/ja-JP/vcexpressja/thread/4cd48e70-4789-419d-b958-87d5f6236113</a></li></ul></li></ul>

<p class="paragraph">
VC6の時代からマルチバイト, UNICODE対応についてCのランタイムライブラリが相当変化しています。
<br />
MSDNの関数リファレンスだけから推測を積み重ねて実験を繰り返して確認するよりは、遠回りでも体系的に解説されたMSDNのページ群を確認して一通りUNICODE/マルチバイト文字セットの対応の仕組みを把握してからの方が、トラブルになった場合も「なぜこうなるのか」「なぜこの対応方法で回避出来るのか」を理解しやすくなると思います。
<br />
</p>

<hr class="full_hr" />
<ul class="plugin_navi">
<li>[&nbsp;<a href="./view-584.html" title="C言語系/memos/VC++/02, 共通系リンカオプション">Prev</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-587.html" title="C言語系/memos/VC++/04, Win32のEXE,LIB,DLL開発入門(C言語)">Next</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-582.html" title="C言語系/memos/VC++">Up</a>&nbsp;]</li>
<li>[&nbsp;<a href="./view-478.html" title="C言語系">C言語系</a>&nbsp;]</li>
</ul>
</div>

<div class="data_attrs_post">
original url: https://www.glamenv-septzen.net/view/586<br>
</div>

</div>
<!-- //data_main -->

</div>


</div>
<!-- /content-wrap end -->

<!-- footer start -->
<div id="footer">
Copyright &copy; 2007 - 2025 Masahiko Sakamoto(msakamoto-sf)<br>
License&nbsp;:&nbsp;<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a><br>
Contact&nbsp;:&nbsp;<a target="_blank" href="https://x.com/msakamoto_sf">x(twitter)</a> / <a target="_blank" href="https://github.com/msakamoto-sf/">github</a> / <a class="maillink" href="mailto:&#x73;&#x61;&#x6B;&#x61;&#x6D;&#x6F;&#x74;&#x6F;&#x2E;&#x67;&#x73;&#x79;&#x63;&#x2E;&#x33;&#x73;&#x40;&#x67;&#x6D;&#x61;&#x69;&#x6C;&#x2E;&#x63;&#x6F;&#x6D;">email</a><br>
--&nbsp;Beautiful Icons&nbsp;--<br />
<a href="http://www.famfamfam.com/lab/icons/silk/" target="_blank" title="Mark James Silk icon set 1.3">Mark James Silk icon set 1.3</a> by famfamfam<br />
<a href="http://www.pinvoke.com/" target="_blank" title="Fugue Icons">Fugue Icons</a> by Yusuke Kamiyamane<br />
</div>
<!-- /footer end -->

</div>
<!-- /body end -->

</body>
</html>