<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>プログラマーでない人のための「共有ライブラリ」講座</title>
<style>
</style>
</head>
<body >
<!-- i.e. -->
<!-- $title := "タイトル" -->
<a href="../../index.html">トップページ</a>＞＞＞<a href="../index.html#qt_junkbox">「ぷろぐらみんぐ」目次</a><br>
<br>
<h1>プログラマーでない人のための「共有ライブラリ」講座</h1>
初版作成：2003/01/11<br>
2015年時点での参考資料追記：2015/06/29<br>
<!-- 二版作成：$date_2<br> -->
<br>
<h2><a name="contents">目次</a></h2>
<ol>
	<li><a href="#preface">前書き</a></li>
	<li><a href="#main">本題</a></li>
	<li><a href="#postscript">後書き或いは感想</a></li>
	<li><a href="#refs201506">2015年時点での参考・推薦資料</a></li>
</ol>

<h2><a name="preface">前書き</a></h2>
<br>
<b style="font-size: x-large;"><a href="#refs201506">2015年時点での、より正確で分かりやすい参考書籍の紹介を追記しましたので、そちらもぜひご確認ください。</a></b><br>
<br>
　LinuxやUNIXを扱っていると<b>「共有ライブラリ(shared library)」「ライブラリ(library)」</b>という言葉をしばしば耳に
します。特に、最新版を使おうとソースコードから見よう見まねでビルド、コンパイルとやらをおそるおそる行っては見たものの
見事に失敗したときや、或いは上手く動かないときのログファイル中で現れることもあります。<br>
<br>
　プログラマーであれば、<b>例え初めてLinuxに触ったとしても何となく語感だけで</b>ぼんやりと原因が想像できます。<br>
　しかしごく普通の ---つまりプログラミングなどに興味関心も無かった--- 人たちにとって、<b>「何だそりゃ、しらねーよ。」</b>
な世界です（以前、パソコンに全く興味のない身内にプログラミング関連の愚痴を垂れたところ「日本語で話してくれ」と言わ
れたことがあります）。<br>
<br>
　今回の特別講座では、<font size=+1><b>Windowsから移ってきたばっかりの、非プログラマー向けに</b></font>この「ライブ
ラリ」がいったい何者なのか。<br>
　<font size=+1><b>そして「/lib」、「/usr/lib」下の大量のシンボリックリンクと「lib****.so.***」はいったい何か</b></font>
を適当に話していきたいと思います。<br>
<br>
　今回の話をお読みいただき、少しでもLinux/UNIXシステムに対する不安が解消されれば<b>ひっじょーにうれしい</b>かな、と。<br>
　ちなみに「何でおまえを喜ばせるためにわざわざ貴重な時間を割いてまでこんな初心者の書いた文書読まないかんのだ」とか言う
つっこみはイタすぎですので無視させていただきます。<br>
<br>
　ぶっちゃけた話、<b>「プログラマーである自分自身が後学を兼ねてまとめた自分自身用レポート」</b>なのはいつものことです
から・・・。<br>
<br>
<b>参考資料</b><br>
・<a href="http://www.linux.or.jp/JF/JFdocs/Program-Library-HOWTO/index.html" target=_blank>JFドキュメント「Program Library HOWTO」</a><br>
・その他各種コマンドのmanページ<br>
<br>
<font size=-1><a href="#contents">目次に戻る</a></font>
<br>
<h2><a name="main">本題</a></h2>
<ol>
	<li><a href="#main_01">まずは Windows に戻りましょう。</a></li>
	<li><a href="#main_02">DLLについて。</a></li>
	<li><a href="#main_03">例え話も程々に。</a></li>
	<li><a href="#main_04">Linux/UNIX へ。</a></li>
	<li><a href="#main_05">Linux/UNIX 特有のお約束。</a></li>
</ol>
<br>
<font size=+1><b><a name="main_01">まずは Windows に戻りましょう。</a></b></font><br>
<font size=-1><a href="#main">「本題」に戻る</a></font><br>
<br>
　生粋の Linux/UNIX ユーザーはこの文章は読んでいない、と仮定して大胆にも一旦話を Windows に引き戻します。<br>
　というのは、最近になってLinux/UNIXをいじり始めた人たちは大半が Windows も使っている人たちであろうからです。<br>
<br>
　んで。Windows でもやっぱり「共有ライブラリ」や「ライブラリ」といった言葉が頻発するわけです。<b>が、何故かLinux/UNIX
程には恐怖感がありません。</b><br>
　まずはそこから入っていきましょうか。<br>
<br>
　単刀直入に切り出します。「共有ライブラリ」や「ライブラリ」と言われているシロモノの実体は単なるファイルです。<br>
　で、<b>Windows では「****.dll」、Linux/UNIX では「lib****.so.****」というファイル名</b>（*の部分はライブラリの名前
何かが入ります。つまり何でも良い）が「共有ライブラリ」や「ライブラリ」といわれているシロモノの本体です。<br>
<br>
　ほら、<b>Windows で言うところの悪名高い<font size=+1>VBランタイムライブラリ</font>何かがまさにそれですよ。</b><br>
　すこし Windows に詳しくなれば誰もが口にする<b>「DLL」</b>というのが、Windows 版の「共有ライブラリ」です（後述します
がDLLファイルは「ライブラリ」とはちょっと違う場合もあります）。<br>
<br>
　Windows を始めた頃を思い出して下さい。うっかり「****.dll」を削除してしまったばっかりに重要なアプリケーションが起動
しなくなったりしたこと、ありませんか？あれと同様の事が Linux/UNIX でも起こりうるのです。<br>
　もっともLinux/UNIXシステムの場合、システム中枢に関わるライブラリは root 権限がないと消去できないパーミッションが
与えられていますのでおいそれとは（サーバーマシンなどでは）上記のような現象は起こらないでしょうが・・・。<br>
　Linux/UNIX ではむしろ、「ライブラリのバージョンが違うために動作しない」現象の方が圧倒的に多いと思われます。<br>
<br>
　そういえば、<b>VBランタイムライブラリにも<font size=+1>「VB5」とか「VB6」</font>みたくバージョンがありました</b>
ねえ。フリーソフトなどを利用するときはVBランタイムライブラリのバージョンが違って動かなかった、みたいなこと。経験
しませんでした？<br>
<br>
　話がまとまりませんが、<font size=+1><b>「あ、共有ライブラリとかって Windows で言うところの DLL か！」</b></font>と
頭の上にろうそくが灯って頂ければ十分かな、と。<br>
<br>
<font size=+1><b><a name="main_02">DLLについて。</a></b></font><br>
<font size=-1><a href="#main">「本題」に戻る</a></font><br>
<br>
　何だかとりとめない話になってしまいし、「何でLinux/UNIXでは共有ライブラリに対する恐怖感を覚えるのか」が終わっていません。<br>
<br>
　これは人によりけりですので、どうせ（私個人が）汎用的（だと思っている）な理由を挙げても大した足しにはなりません。<br>
　ここでは<b>私自身がなぜ恐怖感を覚えたのか</b>語らせていただきます。<br>
<br>
　私が「共有ライブラリ」に出会ったのは<b>やっぱりWindowsで、DLLファイルを削除してしまった</b>事件でした。<br>
　エラーメッセージが表示されたんですよね。「****.dllが見つかりません」みたいな。<br>
　んで、（幸いにも）ゴミ箱に入れてた ****.dll を元に戻したら動くようになりました。<br>
<br>
　私自身はプログラミングを勉強中でした。特にC言語を学んでいたせいもあってか、「DLL」の意味するところが朧気ながら（当然
誤解も含めて）直感的に察しがついていました。何となく、<b>複数のアプリケーションから使用される機能の固まり</b>ではないか
な、と。まあ、<b>パソコン雑誌を拾い読みしていたせいもありましたが。</b><br>
<br>
　そう言うわけで、Windowsでは大規模なアプリケーションにはDLLが使われているんだな、ということ。そして、<b>「DLLファイルは
大概、C:\WINDOWSディレクトリの中か、個別のアプリケーションのフォルダの中にあるんだな。」</b>ということをフリーソフトの
インストール作業から学びました。<br>
　現実問題として DLL 絡みの問題があまり起こらなかったということもあるのかもしれません。<br>
<br>
　<b>で、Linux/UNIXです。</b><br>
　やっぱり最初、「ライブラリって何だっぺ」状態でした。<br>
　C言語の知識から、「やっぱりコンパイル時に使うものだろうか」とか、「それとも Windows のDLLみたいなものじゃろか」とか。<br>
<br>
　実は Windows において（特にプログラミングに於いて）<b>「ライブラリ」と「共有ライブラリ」は相当意味が違う</b>シロモノ
なのです（詳細は後述）。<br>
　それが、Linux/UNIXではずいぶんとごちゃ混ぜに使われています。その時点ですでに若干の混乱を引き起こしていました。<br>
<br>
　極めつけは /lib ディレクトリ内にある大量の「lib****.so.****」ファイルとそれへのリンク。<br>
　実例を下に示します。ls -l から適当に引っ張ってきた部分です。<br>
<br><pre>
lrwxrwxrwx    1 root     root           11  9月 10日 07:25 libpam.so -> libpam.so.0*
lrwxrwxrwx    1 root     root           14  9月 10日 07:25 libpam.so.0 -> libpam.so.0.75*
-rwxr-xr-x    1 root     root        38656  4月 28日  2002 libpam.so.0.75*
</pre><br>
　<b>どれがどうリンクしてるのかさっぱり分からん！！<font size=+1>というか、なんでわざわざこんなにリンク張る必要が
あるわけ！？</font></b><br>
　リンクはWindowsで言うところのショートカットにあたります。<br>
　ですが・・・なんでこんなにリンクを張ってるのか、全く謎でした。今まで。<br>
<br>
　しかもですね。<b>/lib, /usr/lib, /usr/local/lib と分散してしまっている・・・</b>。<br>
　Windows と共有ライブラリの配置に対する哲学がまるで異なっています。<br>
<br>
　Windows ではDLLは大抵 C:\WINDOWS(NT/2000では C:\WINNT)か、アプリケーション固有のディレクトリにまとめられます。<br>
　ところが Linux/UNIX では<b>アプリ固有だろうと何だろうと見境なしに /lib, /usr/lib ディレクトリにつっこまれてる</b>
ので、分散してしまって分かりづらかったんです。<br>
<br>
　いえ、分かりづらかったわけではありません。選択肢は /lib, /usr/lib, /usr/local/lib の三つしか無いわけですから。<br>
　どちらかというと<br>
<h2>居こごちが悪かった。</h2>
　というわけです。全てが「何となく想像はつくんだけど・・・でも何でこうなってんの？」という疑問で埋め尽くされている
わけです。<br>
　そんなわけで、JFのドキュメントに出会った今日までずっともやもやした不安というか気持ち悪さが Linux/UNIX の共有ライブラリ
にはあったわけです。<br>
<h2>つまり Linux/UNIX の哲学に慣れていなかった。</h2>
　慣れた者がちです、この世界。一旦慣れれば（自転車を初めて一人で乗れるようになった子供のように）応用や新しい方向への
チャレンジへの道が開けますし、少なくとも目の前の靄の一つくらいは吹き飛ばせるはずです。<br>
<br>
　というわけで、<b><font size=+1>そろそろ「だーかーら、ライブラリってなんなんだよ！！！」と喚きたく</font></b>なった
頃合いでしょうか。では。例え話を用いてライブラリの本質を語らせていただきます。<br>
<br>
<font size=+1><b><a name="main_03">例え話も程々に。</a></b></font><br>
<font size=-1><a href="#main">「本題」に戻る</a></font><br>
<br>
　私は今大変狂喜しています。というのは、私自身今まであやふやだった「ライブラリ」「共有ライブラリ」を相当日常生活に
例えた形で解説できる機会に出会えたからです。多くのユーザーが心の隅で抱いて居るであろう、この謎についてなぜ今まで
これほどわかりやすい例えが用いられなかったのか不思議に思う（以下めんどいので削除）<br>
<br>
　ライブラリを語る前に、まずそもそもみなさんが日常使っている「アプリケーションソフト」とは何なのかの説明から始めましょう。<br>
<br>
　アプリケーションソフト、サーバー、デーモン・・・。色々呼び名はありますが、一般にソフトウェア本体とされているファイルが
Windowsにも、Linux/UNIX にも存在します。<br>
　<b>よーするにWindowsではアイコンをダブルクリックするとアプリケーションが起動するファイルで拡張子が「EXE」のやつ。</b><br>
　Linux/UNIXの場合はシェルから直接打ち込むことにより何らかのソフトが起動するファイルです。<br>
<br>
　これらは<b>「実行形式のファイル」</b>とも呼ばれています。<br>
　ぶっちゃけた話、<b>パソコンのCPUが理解できる言語で書かれた処理手順書</b>です。<br>
　そのアプリケーションが何をどうするか。それを記述した手順書が実行形式ファイルです。<br>
　CPUつまり中央処理装置は全てを数値で処理します。それを直接人間が書こうとするにはとてつもない知識と技量が必要になります
（まれにそれをやってのけてしまう人種も居ます。OSの開発者達です）。<br>
<br>
　とにかく、CPUにだけ分かる言語で「最初にあーしろ、次どーしろ、もしユーザーがこのボタンクリックしたらこーしろ・・・」
といった処理手順が書き連なったファイルが「実行形式のファイル」と呼ばれるものです。<br>
<br>
　<b>これは料理で言えば一種のレシビ</b>、職人さんなら一種の設計図にあたります。<br>
<br>
　で、こっからが話の本題です。<br>
　もっともわかりやすいレシピ（または設計図）は<b>一つのレシピ（または設計図）に、必要な処理手順が逐一書かれている</b>
状態でしょう。そのレシピさえ見れば、包丁の使い方からジャガイモの皮の向き方、おまけに食器の後かたづけ方法まで全て載っている
わけです。<br>
　ところが、全てのレシピに対していちいちそこまで記述するのは（もしそのレシピが紙で出来ているなら）紙の無駄遣いですし、
何よりも慣れてくると鬱陶しくなります。<br>
　そこで、包丁の握り方やキャベツの千切り方法など、殆どのレシピでおよそ共通している部分を抜き出します。<br>
<br>
　<b>この抜き取った共通部分のレシピこそが、<font size=+1>ライブラリ</font>にあたります。</b><br>
<br>
　ただし・・・もとのレシピに、「ここは他のレシピでも共通に使われてる部分だから切り抜いたよ。」という印が無かったら
どうなるでしょうか。たとえば「三枚おろし」に関する部分が切り抜かれている状態で、「ここで三枚おろしにします。」
などという記述がレシピに出てきたらどうなるでしょう。<br>
<br>
　人間なら「どっかに書かれてなかったかな」と他のレシピをめくりますが、CPUはそう言った自分で何か考える能力は文句無くゼロ
です（仮にあるように見えても、それはレシピにそう振る舞うように指示が書かれていたからです）。<br>
　<b>というわけで、もし切り抜かれた共通部分（ライブラリ）が見つからないとCPUは「そんなこと知りませんよ。」とエラーを
発生してくれます。</b><br>
　今回の例なら「三枚おろし？どうやるの、それ。」と自分で調べもせずに聞いてくる、あまつさえ多くの場合、そのままやる気を
無くしてレシピの料理を作ろうとするのを止めてしまいます。<br>
<br>
　このようなとき、正しく「三枚おろしってのはこうするんだよ。」と教える方法はざっと３通りあります。<br>
<br>
１．人間側で予め、レシピに「三枚おろし」の部分を<b>糊とかで貼り付けて剥がれないように一体化してから</b>
CPUにレシピを渡す。<br>
<br>
２．レシピに、<b>「三枚おろしについて知りたければどこそこの本棚のこういうファイルに載っている」</b>と、本体の
レシピの<b><font size=+1>冒頭部分に</font></b>付け足してからCPUに渡す。<br>
<br>
３．<b><font size=+1>「三枚おろし」の記述が現れる時点でようやく</font></b>「ここの本棚のこういうファイルに載っている」
という記述を付け足してからCPUに渡す。<br>
<br>
<br>
　特に２．と３．の違いについて注意して下さい。２．では予め共通部分のレシピの存在箇所を<b>冒頭で、まとめて</b>書き付けて
おきます。３．では、<b>共通部分を使う段になって初めて</b>その共通部分の存在箇所を教えています。<br>
<br>
　実際にはこんな風なレシピを渡すことになります。<br>
<table border>
<tr>
	<td align=center>１．</td><td align=center>２．</td><td align=center>３．</td>
</tr>
<tr>
	<td>
		材料：サンマ一匹<br>
		手順１：包丁を握ります。<br>
		・・・<br>
		手順２：サンマを三枚おろしにします。<br>
		魚をのせ、包丁を尻尾の方から...<br>
		...<br>
		...<br>
		手順３：...<br>
	</td>
	<td>
		・包丁の握り方についてはこういう名前のファイルに書き付けときました。<br>
		・三枚おろしの方法についてはこんな名前のファイルに書き付けときました。<br>
		材料：サンマ一匹<br>
		手順１：包丁を握ります。<br>
		手順２：サンマを三枚おろしにします。<br>
		手順３：...<br>
	</td>
	<td>
		材料：サンマ一匹<br>
		手順１：包丁を握ります。
			・包丁の握り方についてはこの名前のファイル名に。<br>
			・<b>また、包丁が果物包丁しか無い場合は</b>こちらの名前のファイルに書き付けてあります。<br>
		手順２：サンマを三枚おろしにします。<br>
			・三枚おろしの方法についてはこんな名前のファイルを参照。<br>
		手順３：...<br>
	</td>
</tr>
</table><br>
<br>
　まあ、こんな感じです。特に３．で、<b>そのときの条件によって参照先を変えている</b>事に注目して下さい。<br>
<br>
<font size=+1><b><a name="main_04">Linux/UNIX へ。</a></b></font><br>
<font size=-1><a href="#main">「本題」に戻る</a></font><br>
<br>
<b style="font-size: x-large;"><a href="#refs201506">2015年時点での、より正確で分かりやすい参考書籍の紹介を追記しましたので、そちらもぜひご確認ください。</a></b><br>
<br>
　まず、１．のレシピについて考えてみましょう。<br>
　一番これが「手抜き」なレシピでもあります。単に共通部分をぺたりと貼り付けただけですから。<br>
　ただ、もしも他のレシピにもこういったことをするとどうなるでしょう。レシピを作る度に共通部分をいちいち貼り付けていく
訳ですから、一つ二つのレシピしかCPUに渡さないのであればそうでもないでしょうが、数百のレシピをCPUに渡す事になると、
重複部分の無駄は無視できなくなってきます。<br>
　他にもその三枚おろしの方法は自分の家では出来るやり方であっても（包丁の種類や職人の腕前など）、別の家に持っていっても
出来るとは限りません。<br>
<br>
　そこで２．の出番です。共通部分を書き付けたファイル名を予め冒頭でリストしておきます。CPUは三枚おろしと出てきたら
冒頭のリストを参照し、どのファイルに書かれているか（ようやく自分で）調べに行きます（実はこれとて、とある共通部分に
そうしなさいと書かれているから）。<br>
　こうすれば１．で起こり得た重複部分の無駄は激減します。また、共通部分を書き付けたファイル名は一般にどの家でも一緒
（大抵の料理集にはそのままの名前で目次に載っている）です。そして、家毎に共通部分はカスタマイズしてある（はず）ので
２．のレシピを違う家のCPUに頼んでも、CPUはその家に応じた共通部分をとってきてくれるのでエラーになりません。<br>
　デメリットとしては、共通部分に依存するレシピが多くなってしまい逆に共通部分を管理する負担が増えてくることです。<br>
　またレシピの共通部分に依存する率が高くなるので、ちょっとした家の違いでも「この共通部分が無い」といった現象が発生
しやすくなります。<br>
　それでも、家を管理している人たちがよく使われる共通部分をそれぞれしっかり管理していれば、よほどカスタマイズされた
レシピを渡さない限り、大抵は問題なく料理してくれます。<br>
<br>
　３．は、その場その場の条件によって、共通部分の参照先を変更できるメリットがあります。<br>
　たとえば、包丁の握り方一つとっても和包丁、ナイフ、果物包丁、中華包丁・・・とあるわけです。<br>
　そのときそのときの条件によって、「今日は和包丁」「昨日はナイフ」と柔軟に切り替えられます。つまり、問題へのアプローチ
方法がリアルタイムで複数存在するときに威力を発揮します。<b>これこそがブラウザなどでお世話になる<font size=+1>プラグイン
</font>の正体です。</b><br>
　今回の例ではちょっと分かりづらいかもしれません。というのも、包丁の種類は家の違いと考えてしまえば別段、２．の方式
をとっても問題ないからです。<br>
　非現実的ですが、マグロが材料に渡されてきたとしましょう。そうなってくると２．では対処が難しくなります。<br>
<br>
　本マグロを捌くのは並大抵の技量では出来ません。とにかく、包丁からして普通のものでは無理です。<br>
　しかし、家と家の間で互換性を維持するためには、「包丁が無い」からといって終わりにするのはよくありません。<br>
　むしろこの場合、「包丁はどうでも良い。むしろ、その場にある包丁でどう捌くか」という捌く手順を複数用意します。<br>
<br>
　・・・よくよく考えるとこれは２．でも出来てしまいます。つまり、今回は<b>「材料として渡された魚に応じて捌き方を変える」</b>
必要があるのです。これは２．では不可能です。２．では予め渡される材料が分かっているか、予測できる場合は有効です。しかし
全く未知の場合はいったいいくつの「＊＊魚の捌き方」共通部分を冒頭に書き付けておく必要があるのでしょうか。<br>
　こういうときこそ、３．の出番になります。こうすれば万事解決です。<br>
<br>
・包丁の握り方は「houtyou_nigirikata.dll」ファイルに書き付けてあります。<br>
材料：とりあえず魚一匹。<br>
手順１：包丁を握ります。<br>
手順２：魚を三枚おろしにします。<br>
　　　　もしも魚がサンマだった場合は「sabakikata_sannma.dll」ファイルに捌き方が載っています。<br>
　　　　もしも魚が本マグロだった場合は「sabakikata_honnmaguro.dll」ファイルに・・・<br>
　　　　もしも・・・<br>
　　　　というわけでとにかく魚を三枚おろしにします。<br>
手順３：...<br>
<br>
　もうちょっと改良を加えましょう。魚の種類と、捌き方を載せた共通部分(dllファイル)を対にした内容のファイルを作っておきます。<br>
<br>
ファイル名：「tui_sakana_sabakikata.txt」<br>
サンマ：sabakikata_sannma.dll<br>
本マグロ：sabakikata_honnmaguro.dll<br>
イワシ：sabakikata_iwasi.dll<br>
...<br>
<br>
　そして、いざ三枚に下ろすときにこのファイルを参照して、対応するDLLをロードするようにすればいいのです。<br>
<br>
（省略）
手順２：魚を三枚に下ろします。<br>
　　　　魚の種類と捌き方を載せたファイルの対応表は「tui_sakana_sabakikata.txt」にあります。<br>
　　　　それみて適切な捌き方を調べて下さい。<br>
　　　　というわけでとにかく魚を三枚おろしにします。<br>
手順３：...<br>
<br>
　こうすれば新しい魚が入ってきたときでも対応表に、対応するDLLを書き付けるだけで対処できるようになります。<br>
　<b>まさしく<font size=+1>「魚の三枚おろし」に関するプラグインシステム</font>を作ってきたわけです。</b><br>
<br>
<br>
　以上、１．、２．、３．と全く同じ仕組みが Windows, Linux/UNIX 両OSに備わっています。<br>
　各レシピの共通部分が Windows で言うところの DLLファイル であり、Linux/UNIXでの 共有ライブラリ になることが実感して
頂けたでしょうか。<br>
<br>
　・・・Windowsの場合はDLLファイルであるのは周知の通りです。では、<b>肝心のLinux/UNIXではどんなファイル名の命名規則が
使われているのか</b>。そして、なぜlib****.so****はあんなにリンクが張ってあり、しかも分散しているのか。<br>
　引き続きこの謎に迫っていきたいと思います。<br>
<br>
<font size=+1><b><a name="main_05">Linux/UNIX 特有のお約束。</a></b></font><br>
<font size=-1><a href="#main">「本題」に戻る</a></font><br>
<br>
　ここでは、主に「命名規則」と「配置場所」に絞ってお話しします。<br>
　まずは命名規則からです。<br>
<br>
　共有ライブラリのファイル名は次の形式に従ってリンクファイルを含めて作成する必要があります。<br>
　下に示す例の「****」の部分はそのライブラリを表す文字列が入ります。たとえばlibpam.soはPAMを実装するためのライブラリです。<br>
<br>
<table border>
<tr>
<td>ファイル名の形式自体の名前</td><td>ファイル名の形式</td><td>例</td><td>リンク先</td>
</tr>
<tr><td>real name</td><td>lib****.so.(メジャー番号).(マイナー番号群)</td>
	<td>libhogehoge.so.2.0.1.2</td><td>（共有ライブラリ本体なのでリンク先は無し）</td></tr>
<tr><td>soname</td><td>lib****.so.(メジャー番号)</td><td>libhogehoge.so.2</td><td>libhogehoge.so.2.0.1.2</td></tr>
<tr><td>linker name</td><td>lib****.so</td><td>libhogehoge.so</td><td>libhogehoge.so.2</td></tr>
</table><br>
<br>
　・・・何でこんな事になっちゃったんでしょう。その原因は、Linux/UNIXの実行ファイル形式にあります。<br>
<br>
　先ほどの例えで、「（ようやく自分で）調べに行きます（実はこれとて、とある共通部分にそうしなさいと書かれているから）」
とあった部分を思い出して下さい。この「とある共通部分」が<b>「プログラムローダー」や「リンカローダー」</b>と呼ばれる部分です。<br>
　このプログラムローダー（ld-linux.so）は前述の命名規則に従っていない、超特別な共通部分です。<br>
<br>
　先ほどの例えで言うと、まさに「人間の読めるレシピからCPUの読めるレシピに変換する」とき<b>デフォルトで</b>冒頭に宣言
される共通部分です。これがないと、他の共通部分をCPUが読み込めないほどの重要な部分です。<br>
<br>
　で、上に挙げた命名規則やリンク生成はこのプログラムローダーの仕様に基づきます。<br>
<br>
　さて。人間の読めるレシピからCPUの読めるレシピに変換する（以降、この動作を「コンパイルする」と言います）時、使用する
共有ライブラリ名を<b>「-l****」(上の例なら -lhogehoge)</b>とする事がプログラムローダーの仕様になっています。<br>
　****はすなわち、linker nameのlib****.soに該当します（メジャー番号を無視してますし）。すると<b>リンク先のsonameが
プログラムの内部で</b>使われるようにな（るらしい）ります。<br>
<br>
　んで。この段階ではライブラリの「ファイル名」は判明しても「ディレクトリ」が分かりません。実はLinux/UNIXには「/sbin/
ldconfig」というコマンドがあります。このコマンドが（設定ファイルに登録済みの）ディレクトリを検索し、ライブラリの
「ファイル名」とそのディレクトリ位置を目録化してくれます。この目録は/etc/ld.so.cacheファイルに格納
されます。<br>
　で、この目録の作成に使われる「ファイル名」が soname なわけです。んで、プログラムからプログラムローダ、そして
ファイルシステム上のリンクをたどってようやく realname に至るわけです。<br>
<br>
　とにかく、プログラムローダーとldconfigの仕様によって２種類のリンクを作成する必要があったわけです。<br>
<br>
　次に<b>配置場所</b>について解説します。今までの説明ですと、プログラム内部で共有ライブラリを指定するときはsonameを
使います。が、これだけですと「どのディレクトリにあるのか」が分かりません。そのために、sonameを検索するときのインデックス
として/etc/ld.so.cacheがあり、そのインデックスを更新するのが/sbin/ldconfigでした。<br>
　で。実際にldconfigはどのディレクトリを検索してインデックスを作成しているのか。検索するディレクトリをリストしたのが
<b>「/etc/ld.so.conf」</b>ファイルです。これは単純なテキストファイルです。私の(TLXW8)を載っけます。<br>
<pre>
[fenjin@seisyuu fenjin]$ cat /etc/ld.so.conf
/usr/X11R6/lib
/usr/lib/gconv
/usr/lib/qt/lib
/usr/local/lib
/usr/i386-linuxaout/lib
/usr/lib/libc5-compat
/usr/lib/sane
/usr/lib/Omni
[fenjin@seisyuu fenjin]$
</pre><br>
　・・・<b>「/lib」や「/usr/lib」はどこ行ったのでしょう。</b>実はこの二つのディレクトリは<b>ldconfigがデフォルトで必ず
チェックするディレクトリ</b>です。そのため、わざわざ/etc/ld.so.confに記述する必要がない訳です。<br>
　/usr/local/libもしっかり指定されています。実は、/usr/local/libはldconfigのデフォルトではありません(RHL6.2以降)。その
ためわざわざld.so.confに記述する必要があったわけです。<br>
<br>
　結局、<b>パターンさえ掴めてしまえばWindowsと同じか、それ以上にきめ細かくライブラリを管理できる</b>というへんてこな
具合になってしまいます。<br>
　なぜならライブラリの指定に用いているのはsonameですが、これはrealnameへのシンボリックリンクです。<br>
　ということは、<b>もしライブラリがバージョンアップされたとき</b>などは、<b>古いライブラリを上書きせずに</b>リンクだけ
変更することによって、万が一に備えたライブラリのバージョンアップが出来るわけです。<br>
<br>
　そして、ライブラリのインストール先は「/lib」「/usr/lib」、そして/etc/ld.so.confに記述されているディレクトリ内である
ことも確実です（本当はLD_LIBRARY_PATH環境変数でローカルに変更もできるのですが）。<br>
<br>
　まあこんな感じで、Linux/UNIXの共有ライブラリの仕組みは成り立っています。<br>
<br>
<font size=-1><a href="#contents">目次に戻る</a></font>
<br>
<h2><a name="postscript">後書き或いは感想</a></h2>
　最後に、C言語における厳密な意味での<b>ライブラリと共有ライブラリの違い</b>について言及しておきます。<br>
　C言語ではコンパイルするときに一緒に抱き合わせるのがライブラリです。つまり、魚の三枚おろしで言う１．のパターンの時
用いている共通部分を「ライブラリ」といいます。<b>拡張子が「.a」になっている</b>ことが大きな特徴です（Windowsでは「.lib」になっている場合が多い）。<br>
　Linux/UNIX, Windowsで「共有ライブラリ」と言う場合、それは「.a」ファイルではありません。<br>
　というのは、.aファイルは<b>その他のメインプログラムに抱き合わされる</b>事が予想されているため、<b>.a自身が使用している
共通部分(printfとか)は.aには含めない</b>ようになっています。抱き合わせ先のメインプログラム側で一緒にしてくれる事を
予想されているからです。<br>
　ところが共有ライブラリは、それ自体で完結するようになっています。共通部分としてのライブラリも<b>（あたかもメイン
プログラムと同等の存在であるかのように）</b>きちんとリンクされて、lib****.so****が生成されるわけです(Windowsなら*.dll)。
<br>
　厳密な定義を追いかけるとこういった違いも出てきます。まあ、非プログラマの人たちにはおよそ関係ない話です。<br>
<br>
<br>
　もしあなたがC/C++のプログラマ（学習者）で、共有ライブラリの実際のソースコードで実験したければ、本ページの前書きで
載せてあるJFドキュメントを参照すると良いでしょう。ここではプログラミングには一切立ち入らず話をしたため、物足りない向きは
当然あったと思われます。<br>
　どちらにせよ、このページがあなたのLinux/UNIXのライブラリに対する漠とした不安感を幾分でも軽減できれば大変うれしいです。<br>
<br>
<h2><a name="refs201506">2015年時点での参考・推薦資料</a></h2>
<p>
2015-06位に、こちらの記事への「はてなブックマーク」が急増しました。
参考にしていただけるのはありがたいのですが、なにしろ2003年頃に自身も勉強中の状態で、整理も兼ねて執筆した記事です。
比喩として適切でなかったり、そもそもこうした記事を読もうとする人達の技術レベルを考慮していなかったり、そもそも理解や記述に不正確・不十分な点もあります。
</p>
<p>
2015年現在、unix、特にLinuxでの共有ライブラリ(.soファイル)について、より正確かつ分かりやすく学べる書籍が出ています。
Linuxを使われていて、共有ライブラリ(.soファイル)の仕組みについて興味を持たれた方は、ぜひそちらの書籍で、より正確で分かりやすい文章で学んでいただくことを推奨します。
</p>
<p>
推奨書籍その1（基礎から解説されていますので、一番オススメ）<br>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=glamenvseptze-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=4789838072&linkId=daf3717a3f9f6c86dcc26377099d0175"></iframe>
</p>
<p>
推奨書籍その2（よりgccコンパイラとELFフォーマットのディープな話題が多く、プログラマ中級～上級者向け）<br>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=glamenvseptze-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=4873112885&linkId=c248256310aa671435384757c3fb025b"></iframe>
</p>
<p>
Windowsの場合のDLL(Dynamic Link Library)については、Visual C++開発者向けのドキュメントや、Microsoftからの解説資料が出ていますので、まずそちらを確認されることを推奨します。<br>
<ul>
<li>DLL について : <a href="https://support.microsoft.com/ja-jp/kb/815065/ja" target="_blank">https://support.microsoft.com/ja-jp/kb/815065/ja</a></li>
<li>Visual C++ の DLL : <a href="https://msdn.microsoft.com/ja-jp/library/1ez7dh12.aspx" target="_blank">https://msdn.microsoft.com/ja-jp/library/1ez7dh12.aspx</a></li>
</ul>
<br>
※MSDN上のURLは時々サイト構成のアップデートで変化します。また、利用しているVisual C++/Visual Studioのバージョンと同じドキュメントを参照したほうが正確です。そのため、上記リンクがNot Foundになった場合や、ご利用のVisualC++/Visual Studioのバージョンと異なる場合は、お手数ですが検索しなおしてください。<br>
</p>
<p>
Windowsの場合、EXEファイルやDLLファイルはPortable Executableフォーマット(PEフォーマット)という形式で構成されています。
DLLで使える色々な機能やオプションは、PEフォーマットと密接に関連しています。
そのため、DLLを学ぶにはPEフォーマットについても学んだほうがバランスが良いと思います。
</p>
<p>
2015-06時点で軽く検索したところ、日本語では以下の記事がオススメです。最初のvectorのHPについては2010年頃自分もPEフォーマットの勉強の際に参考にした記事です。<br>
<ul>
<li><a href="http://hp.vector.co.jp/authors/VA050396/index.html" target="_blank">http://hp.vector.co.jp/authors/VA050396/index.html</a></li>
<li>Windows実行ファイル「EXE」の謎に迫る：CodeZine（コードジン） : <a href="http://codezine.jp/article/corner/61" target="_blank">http://codezine.jp/article/corner/61</a></li>
</ul>
<br>
英語になってしまいますが、Matt Pietrek氏のPEフォーマットの解説も非常に詳しいです。PEファイルにリンクされる手前の、OBJファイルやLIBファイルについても解説されています。
ただしMSDN上の記事であり、サイト構成のリニューアルでURLが変わってしまいます。
以下の紹介記事のタイトルを参考に、MSDNの記事を検索してみてください。<br>
"Matt Pietrek - MSDN &amp; MSJ Articles" : <a href="http://www.wheaty.net/articles.htm" target="_blank">http://www.wheaty.net/articles.htm</a>
</p>
<font size=-1><a href="#contents">目次に戻る</a></font><br>
<br>
<a href="../../index.html">トップページ</a>＞＞＞<a href="../index.html#qt_junkbox">「ぷろぐらみんぐ」目次</a>
</body>
</html>
